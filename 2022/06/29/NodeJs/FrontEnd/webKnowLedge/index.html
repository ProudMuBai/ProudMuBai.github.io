<!-- build time:Sun Nov 06 2022 22:05:41 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="源夢" href="https://proudmubai.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="源夢" href="https://proudmubai.github.io/atom.xml"><link rel="alternate" type="application/json" title="源夢" href="https://proudmubai.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Http协议,浏览器跨域"><link rel="canonical" href="https://proudmubai.github.io/2022/06/29/NodeJs/FrontEnd/webKnowLedge/"><title>Http基础知识 - web前端 | MuBai Boat = 源夢 = 人生如逆旅, 我亦是行人</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="loader-container"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Http基础知识</h1><div class="meta"><span class="item" title="创建时间：2022-06-29 18:26:39"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-29T18:26:39+08:00">2022-06-29</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">MuBai Boat</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclx29mstj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph47e9vtj20zk0m8x6l.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciundwu5j20zk0m8n9e.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/nodejs/" itemprop="item" rel="index" title="分类于 web前端"><span itemprop="name">web前端</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://proudmubai.github.io/2022/06/29/NodeJs/FrontEnd/webKnowLedge/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="MuBai"><meta itemprop="description" content="人生如逆旅, 我亦是行人, 萌新小白 & 学习点滴"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="源夢"></span><div class="body md" itemprop="articleBody"><h1 id="http基础知识"><a class="anchor" href="#http基础知识">#</a> Http 基础知识</h1><h2 id="1-http-和-https"><a class="anchor" href="#1-http-和-https">#</a> 1. HTTP 和 HTTPS</h2><h4 id="1http-和https-的基本概念"><a class="anchor" href="#1http-和https-的基本概念">#</a> 1.http 和 https 的基本概念</h4><p>http: 是一个客户端和服务器请求和应答的标准 (TCP), 用于从 www 服务器传输超文本到本地浏览器的超文本传输协议</p><p>https: 是以安全为目的的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密。作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性</p><h4 id="2http-和-https-的区别及优缺点"><a class="anchor" href="#2http-和-https-的区别及优缺点">#</a> 2.http 和 https 的区别及优缺点</h4><ul><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取，改变，确保数据的完整性 (并非绝对安全)</li><li>http 协议的 <code>默认端口</code> 为 80, https 的默认端口为 443</li><li>http 的连接很简单模，是无状态的. https 握手阶段比较费时，会使页面加载时间延长 50%, 增加 10%~20% 耗电</li><li>https <code>缓存</code> 不如 http 高效，会增加数据开销</li><li>https 协议需要 ca 证书，费用较高，功能越强大的 <code>证书</code> 费用越高</li><li>SSL 证书需要绑定 IP, 不能在同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗</li></ul><h4 id="3-https协议的工作原理"><a class="anchor" href="#3-https协议的工作原理">#</a> 3. https 协议的工作原理</h4><blockquote><p>客户端在使用 HTTPS 方式与 web 服务器通信时有以下几个步骤:</p></blockquote><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器 <code>建立ssl链接</code></li><li>web 服务器接收到客户端请求后，会将 <code>网站证书(证书中包含了公钥),传输给客户端</code></li><li>客户端 和 web 服务器端开始协商 <code>SSL链接的安全等级</code> ，也就是加密等级</li><li>客户端浏，览器通过双方协商一直的安全等级， <code>建立会话秘钥</code> ，然后通过网站的公钥来加密会话秘钥，并传送给网站</li><li>web 服务器通过 <code>自己的私钥解密出会话秘钥</code></li><li>web 服务器 <code>通过会话秘钥加密与客户端之间的通信</code></li></ol><p>相关文章: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTk1MTA5NDA3NTQ1NjIyNTQy">解读 HTTP1/HTTP2/HTTP3</span></p><h2 id="2-tcp协议"><a class="anchor" href="#2-tcp协议">#</a> 2. TCP 协议</h2><h4 id="1tcp三次握手"><a class="anchor" href="#1tcp三次握手">#</a> 1.TCP 三次握手</h4><ol><li>第一次握手: <code>建立连接时,客户端发送sync包(syn=j)到服务器,并进入SYN_SETNT状态</code> ；SYN: 同步序列编号 (Synchronize Sequence Numbers)</li><li>第二次握手: <code>服务器收到sync包并确认客户的SYN</code> (ack=j+1), <code>同时也发送一个自己的SYN包 (syn=k)</code> , 即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</li><li>第三次握手: <code>客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=k+1)</code> , 此包发送完毕，客户端和服务器进入 ESTABLISHED (TCP 连接成功状态), 完成三次握手</li></ol><blockquote><p>握手过程中传送的包中不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据</p></blockquote><h4 id="2tcp四次握手"><a class="anchor" href="#2tcp四次握手">#</a> 2.TCP 四次握手</h4><ol><li><code>客户端进程发出连接释放报文</code> ，并且停止发送数据。释放数据报文收不，FIN =1, 其序列号为 seq=u (等于前面已经传送过来的数据的最后一个字节的序号加 1), 此时， <code>客户端进入FIN-WAIT-1(终止等待)状态</code> .TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号</li><li><code>服务器收到链接释放报文,发出确认报文</code> ，ACK=1, ack=u+1, 并且带上自己的序列号 seq=v, 此时， <code>服务端就进入了CLOSE-WAIT(关闭等待)状态</code> .TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受，这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态的持续时间</li><li>客户端收到服务器的确认请求后，此时， <code>客户端就进入FIN-WAIT-2(终止等待2)状态</code> ，等待服务器发送链接释放报文 (在此之前还需要接受服务器发送的最后数据)</li><li><code>服务器将最后的数据发送完毕后,就向客户端发送连接释放报文</code> ，FIN=1,ack=u+1, 由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w, 此时， <code>服务器就进入了LAST-ACJ(最后确认状态)</code> , 等待客户端的确认.</li><li><code>客户端收到服务器的连接释放报文后,必须发出确认</code> ，ACK=1,ack=w+1, 而自己的序列号是 seq=u+1, 此时 <code>客户端进入了TIME-WAIT(时间等待状态)</code> . 注意此时连接还没有释放，必须经过 2**MSL (最长报文寿命) 时间后， <code>当客户端撤销对应的TCB后,才进入CLOSED状态</code> .</li><li>服务器只要收到了客户端发出的确认， <code>立即进入CLOSED状态</code> 。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到 <code>服务器结束TCP连接的时间要比客户端的早一些</code></li></ol><h4 id="3tcpip-如何保证数据包传输的有序可靠"><a class="anchor" href="#3tcpip-如何保证数据包传输的有序可靠">#</a> 3.TCP/IP 如何保证数据包传输的有序可靠</h4><blockquote><p>对字节流分段并进行编号，然后通过 <code>ACK回复</code> 和 <code>超时重发</code> 两个机制来保证</p></blockquote><ol><li>为了充分保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区</li><li>并且为每个已经发送的数据包启动一个超时定时器</li><li>如在定时器超时之前收到了对方发来的应答信息 (可能是对本包的应答，也可以是对本包后续包的应答), 则释放该数据包占用的缓冲区</li><li>否则，重传该数据包，直到收到应道或重传次数超过规定的最大次数为止</li><li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可放在数据包中携带过去</li></ol><h4 id="4tcp和udp的区别"><a class="anchor" href="#4tcp和udp的区别">#</a> 4.TCP 和 UDP 的区别</h4><ol><li>TCP 是面向 <code>链接</code> 的，而 UDP 是面向无连接的</li><li>TCP 仅支持 <code>单波传输</code> ，UDP 提供了单播，多播，广播的功能</li><li>TCP 的三次握手保证了链接的可靠性；UDP 是无连接的，不可靠的一种数据传输协议，首先体现在无连接上，通信都不需要建立链接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收</li><li>UDP 的 <code>头部开销</code> 比 TCP 更小，数据 <code>传输效率更高</code> ， <code>实时性更好</code></li></ol><h2 id="3http请求跨域问题"><a class="anchor" href="#3http请求跨域问题">#</a> 3.HTTP 请求跨域问题</h2><h4 id="1跨域的原理"><a class="anchor" href="#1跨域的原理">#</a> 1. 跨域的原理</h4><p>跨域：浏览器不能执行其他网站的脚本，由浏览器的同源策略造成</p><p>同源策略：浏览器对 JavaScript 实施的安全限制，只要 <code>协议,域名,端口</code> 有任何一个不同，都被当做是不同的域</p><p>跨域原理：通过各种方式，避开浏览器的安全限制</p><table><thead><tr><th>URL</th><th>说明</th><th style="text-align:center">是否允许通信</th></tr></thead><tbody><tr><td><code>http://www.a.com/a.js</code> &lt;br /&gt; <code>http://www.a.com/b.js</code></td><td>同一域名下</td><td style="text-align:center">允许</td></tr><tr><td><code>http://www.a.com/lab/a.js</code> &lt;br /&gt; <code>http://www.a.com/script/b.js</code></td><td>同一域名，不同文件夹</td><td style="text-align:center">允许</td></tr><tr><td><code>http://www.a.com:8000/a.js</code> &lt;br /&gt; <code>http://www.a.com/b.js</code></td><td>同一域名，不同端口</td><td style="text-align:center">不允许</td></tr><tr><td><code>http://www.a.com/a.js</code> &lt;br /&gt; <code>https://www.a.com/b.js</code></td><td>同一域名，不同协议</td><td style="text-align:center">不允许</td></tr><tr><td><code>http://www.a.com/a.js</code> &lt;br /&gt; <code>http://10.10.10.11/b.js</code></td><td>域名和域名对应 IP</td><td style="text-align:center">不允许</td></tr><tr><td><code>http://www.a.com/a.js</code> &lt;br /&gt; <code>http://script.a.com/b.js</code></td><td>主相同，子域不同</td><td style="text-align:center">不允许</td></tr><tr><td><code>http://www.a.com/a.js</code> &lt;br /&gt; <code>http://a.com/b.js</code></td><td>同一域名，不同二级域名 (同上)</td><td style="text-align:center">不允许 (cookie 也不允许访问)</td></tr><tr><td><code>http://www.cnblogs.com/a.js</code> &lt;br /&gt; <code>http://www.a.com/b.js</code></td><td>不同域名</td><td style="text-align:center">不允许</td></tr></tbody></table><h4 id="2解决方案"><a class="anchor" href="#2解决方案">#</a> 2. 解决方案</h4><ul><li><p><mark>JSONP:</mark></p><p>ajax 请求收同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，实现了跨域</p><p><mark>步骤:</mark></p><ol><li>创建一个 script 标签</li><li>script 的 src 属性设置接口地址</li><li>接口参数，必须要带一个自定义函数名，不然后台无法返回数据</li><li>通过定义函数名去接收返回的数据</li></ol><figure class="highlight javascript"><figcaption data-lang="javascript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 动态创建 script</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 设置回调函数</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 设置 script 的 src 属性，并设置请求地址</span></pre></td></tr><tr><td data-num="8"></td><td><pre>script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/?callback=getData'</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 激活 script</span></pre></td></tr><tr><td data-num="10"></td><td><pre>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span></pre></td></tr></table></figure><p><mark>JSONP 的缺点:</mark></p><p>JSON 只支持 get, 应为 script 标签只能使用 get 请求；JSONP 需要后端配合返回指定格式的数据</p></li><li><p><mark>document.domain</mark> 基础域名相同，子域名不同</p></li><li><p><mark><span class="exturl" data-url="aHR0cDovL3dpbmRvdy5uYW1l">window.name</span></mark> 利用在一个浏览器窗口内，<span class="exturl" data-url="aHR0cDovL3huLS13aW5kb3ctOW03aWdsMjNibzhwMWQ4MTZhaW1uMW05YXdsbXVqZDN5OWcxNjdldzdmLm5hbWU="> 载入的所有域名都是共享一个 window.name</span></p></li><li><p><mark>CORS</mark> CORS (Cross-origin resource sharing) 跨域资源共享 服务器设置对 CORS 的支持原理:</p><p>服务器设置 Access-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求</p></li><li><p><mark>proxy 代理</mark> 目前常用方式，通过服务器设置代理</p></li><li><p><mark>window.postMessage()</mark> 利用 h5 新特性 window.postMessage ()</p></li></ul><p>相关文章: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDAzMjMyNzY5MTgyNTQ3OTk4">跨域，基础概念</span></p><h2 id="4cookie-sessionstorage-localstorage的区别"><a class="anchor" href="#4cookie-sessionstorage-localstorage的区别">#</a> 4.Cookie, SessionStorage, localStorage 的区别</h2><p><mark>相同点:</mark></p><ul><li>存储在客户端</li></ul><p><mark>不同点:</mark></p><ul><li><p>cookie 数据大小不能超过 4K; sessionStorage 和 localStorage 的存储比 cookie 大得多，可达到 5M+</p></li><li><p>cookie 设置的过期时间之前一直有效；localStorage 永久存储，浏览器关闭后数据不丢失，除非主动删除数据；</p><p>SessionStorage 数据在当前浏览器窗口关闭后自动删除</p></li><li><p>cookie 的数据会自动的传递到服务器；SessionStorage 和 localStorage 数据保存在本地</p></li></ul><h2 id="5粘包问题分析与策略"><a class="anchor" href="#5粘包问题分析与策略">#</a> 5. 粘包问题分析与策略</h2><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾</p><p><mark>粘包出现的原因:</mark></p><p>在流传输中出现，UDP 不回出现粘包，因为它有 <code>消息边界</code></p><p>粘包情况有两种，一种是 <code>粘在一起的包都是完整的数据包</code> ，另外一种情况是 <code>粘在一起的包有不完整的包</code></p><p><mark>为了避免粘包现象，可采取以下几种措施:</mark></p><ol><li>对于发送方引起的粘包现象，用户可以通过编程设置来避免， <code>TCP提供了强制数据立即传送的操作指令PUSH</code> ,TCP 收到该操作指令后，就立即将本端数据发送出去，而不必等待发送缓冲区满</li><li>对于接收方引起的粘包，则可通过优化程序设计，精简接收进程工作量， <code>提高结束进程优先级等措施</code> ，使其及时接收数据，从而尽量避免出现粘包现象</li><li>由接收方控制，将一包数据按结构字段，认为控制分多次接收，然后合并，通过这种手段来避免粘包. <code>分包多发</code></li></ol><p><mark>三种错误的不足之处:</mark></p><ol><li>第一种编程设置方法虽然可以避免发送方引起的粘包，但是关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用</li><li>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网路突发可能使某个时间段数据包到达接收方比较快，接收方还是有可能来不及接收，从而导致粘包</li><li>第三种方法虽然避免了粘包，但应用程序的效率比较低，对实时应用的场景不合适</li></ol><blockquote><p>比较周全的对策：接收方创建 -- 预处理线程，对接收到的数据包进行预处理，将粘连的包分开.</p></blockquote><h2 id="6浏览器"><a class="anchor" href="#6浏览器">#</a> 6. 浏览器</h2><h4 id="1从输入url到页面加载的全过程"><a class="anchor" href="#1从输入url到页面加载的全过程">#</a> 1. 从输入 URL 到页面加载的全过程</h4><p><img data-src="https://i.bmp.ovh/imgs/2022/02/3b28334da6890ae1.png" alt="页面加载过程"></p><ol><li>浏览器中输入 URL</li><li>查找缓存：浏览器先查看 浏览器缓存 -- 系统缓存 -- 路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步.<ul><li>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求.</li><li>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使用系统调用操作系统，获取操作系统的记录 (保存最近的 DNS 查询缓存)</li><li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存</li><li>ISP 缓存：若上述均失败，继续向 ISP 搜索</li></ul></li><li>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址. <code>DNS服务器是基于UDP的,因此会用到UDP协议</code></li><li>建立 TCP 链接：解析出 IP 地址户，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接</li><li>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</li><li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 HTML 文件发送给浏览器</li><li>关闭 TCP 连接：通过四次挥手释放 TCP 连接</li><li>浏览器渲染：客户端 (浏览器) 解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为:<ul><li>构建 DOM 树：词法分析然后解析成 DOM 树 (dom tree), 是由 DOM 元素及属性节点组成，树的根是 document 对象</li><li>构建 CSS 规则数：生成 CSS 规则数 (CSS Rule Tree)</li><li>构建 render 树: Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树 (render tree)</li><li>布局 (Layout): 计算出每个节点在屏幕中的位置</li><li>绘制 (Painting): 即遍历 render 树，并使用 UI 后端层绘制每个节点</li></ul></li></ol><p><img data-src="https://i.bmp.ovh/imgs/2022/02/0a158bbd19ecc1c4.png" alt="浏览器渲染流程"></p><ol start="9"><li>JS 引擎解析过程：调用 JS 引擎执行 JS 代码 (JS 的解析阶段，预处理阶段，执行阶段生成执行上下文，VO, 作用域回收机制等)<ul><li><code>创建window对象</code> : window 对象也称全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 属性和方法，而 DOM Tree 也会映射在 window 的 document 对象上。当关闭网页或者浏览器时，全局执行环境会被销毁.</li><li><code>加载文件</code> ：完成 JS 引擎分析它的语法与词法是否合法，如果合法进入预编译</li><li><code>预编译</code> ：在预编译的过程中，浏览器会寻找全局变量声明，将它作为 window 的属性加入到 window 对象中，并给变量赋值为 <code>undefined</code> ; 寻找全局函数声明，把它作为 window 的方法加入到 window 对象中，并将函数体赋值给它 (匿名函数是不参与编译的，因为它是变量). 而变量提升作为不合理的地方在 ES6 中已解决，函数提升还存在.</li><li>解释执行：执行到变量就赋值，如果变量没有被定义，也没有被预编译直接赋值，在 ES5 非严格模式下这个变量会成为 window 的一个属性，也就是全局变量. string, int 这样的值就是直接将值放在变量的存储空间，Object 对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境.JS 作用域其实解释这样的执行流机制实现的</li></ul></li></ol><p>相关文案: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDA1NDY4NDkxMDY3MTYyNjU1">DNS 域名解析过程</span> =&gt; <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTkyNTk3NzYwOTM1NDYwOTAx">浏览器的工作原理</span></p><h4 id="2-浏览器重绘与重排的区别"><a class="anchor" href="#2-浏览器重绘与重排的区别">#</a> 2. 浏览器重绘与重排的区别</h4><ul><li><p><code>重排/回流(Reflow)</code> : 当 DOM 的变化影响了元素的集合信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程就叫做重排。表现为重新生成布局，重新排列元素.</p></li><li><p><code>重绘(Repaint)</code> : 当一个元素的外观发生改变，但是没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</p></li><li><p>仅改变元素的外观，肯定不会硬气网页重新生成布局，但当浏览器重排之后，将会重新绘制受到此次重排影响的部分</p></li><li><p>重排和重绘的代价高昂，会破坏用户体验，并且让 UI 展示非常迟缓，而相比之下重排的性能影响更大，两者无法避免时，一般选择代价更下的重绘</p></li></ul><blockquote><p>[重绘] 不一定会出现 [重排], [重排] 必然会出现 [重绘]</p></blockquote><h4 id="3如何触发重排和重绘"><a class="anchor" href="#3如何触发重排和重绘">#</a> 3. 如何触发重排和重绘</h4><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘:</p><ul><li>添加，删除，更新 DOM 节点</li><li>通过 display: none 隐藏一个 DOM 节点 -- 触发重排和重绘</li><li>通过 visibility: hidden 隐藏一个 DOM 节点 -- 只触发重绘，因为没有几何变化</li><li>移动或给页面中的 DOM 节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动</li></ul><h4 id="4-如何避免重绘或重排"><a class="anchor" href="#4-如何避免重绘或重排">#</a> 4. 如何避免重绘或重排</h4><ol><li><p><code>集中改变样式</code></p></li><li><p>不要把 DOM 节点属性值放在循环里当做循环变量使用</p></li><li><p>为动画的 HTML 元件使用 <code>fixed</code> 或 <code>absoult</code> 和 <code>position</code> , (此时修改 CSS 就不回触发 reflow)</p></li><li><p>不使用 table 布局，因为可能很小的一个改动会造成整个 Table 的重新布局</p></li><li><p>尽量只修改 <code>position: absoule</code> 或 <code>fixed</code> 元素，对其他元素影响不大</p></li><li><p>动画开始 CPU 加速，translate 使用 3D 变化</p></li><li><p>提升为合成层</p><p>将元素提升为合成层的优势</p><ul><li>合成层的位图，会交由 CPU 合成，比 CPU 处理快</li><li>当需要 repaint 时，只需要 repaint 本身，不回影响到其他的层</li><li>对于 transfrom 和 opacity 效果，不回触发 layout 和 paint</li></ul><p>提升合成层最好的方式是使用 CSS 的 will-change 属性:</p><figure class="highlight css"><figcaption data-lang="CSS"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token selector">#target</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><p>合成层详解: <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHAlM0ElMkYlMkZ0YW9iYW9mZWQub3JnJTJGYmxvZyUyRjIwMTYlMkYwNCUyRjI1JTJGcGVyZm9ybWFuY2UtY29tcG9zaXRlJTJG">无线性能优化</span></p><h4 id="5304过程"><a class="anchor" href="#5304过程">#</a> 5.304 过程</h4><ul><li>浏览器请求资源时首先命中资源的 Expires 和 Catch-Control, Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 Cache-control: max-age 指定最大生命周期，状态仍然返回 200, 但不会请求数据，在浏览器中能明显看到 from cache 字样</li><li>强缓存失效，进入协商阶段，首先验证 ETagETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器更具客户端上送的 if-None-Match 值来判断是否命中缓存.</li><li>协商缓存 Last-Modify/if-Modify-Since 阶段，客户端第一次请求资源时，服务返回的 header 中会加上 Last-Modify, Last-modify 是一个时间标识该资源的最后修改时间。再次请求该资源时，request 的请求头中会包含 if-Modify-Since, 该值为缓存之前返回的 Last-Modify. 服务器收到 if-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存</li></ul><h4 id="6浏览器的缓存机制-强制缓存-协商缓存"><a class="anchor" href="#6浏览器的缓存机制-强制缓存-协商缓存">#</a> 6. 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h4><ol><li>浏览器与服务器通信的方式为应答模式，浏览器发起 HTTP 请求 -- 服务器响应该请求.</li><li>浏览器第一次向服务器发起请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存表示，决定是否缓存结果</li><li>是则将请求结果和缓存标识缓存浏览器缓存，简单过程如下</li></ol><p><img data-src="https://i.bmp.ovh/imgs/2022/02/dbc576546603023a.png" alt="浏览器缓存机制"></p><p>由上图可知:</p><ul><li>浏览器每次发起请求，都会 <code>现在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到的返回的请求结果都会 <code>将该结果和缓存标识存入浏览器缓存中</code></li></ul><ol start="4"><li>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了.</li><li>根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是 <code>强制缓存</code> 和 <code>协商缓存</code></li></ol><p><mark>强制缓存:</mark></p><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code> , 其中 Cache-Control 优先级比 Expires 高.</p><p>墙纸缓存的情况只要有三种，如下:</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求 (跟第一次发起请求一致)</li><li>存在该缓存结果和缓存标识，但结果已失效，强制缓存失效，则使用协商缓存.</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回结果</li></ol><p><mark>协商缓存:</mark></p><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样协商缓存的表示也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有: <code>Last-Modified/ If-Modified-Since</code> 和 <code>Etag / IF-None-Match</code> , 其中 Etag / IF-None-Match 的优先级比 Last-Modified /If-Moified-Since 高。协商缓存主要有以下两种情况:</p><ul><li>协商缓存失效，返回 304</li><li>协商缓存失效，返回 200 和请求结果</li></ul><p>相关文章: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTkyODQzMTE3OTYzNTA5Nzkx">彻底理解浏览器的缓存机制</span></p><h4 id="7-进程线程和协程"><a class="anchor" href="#7-进程线程和协程">#</a> 7. 进程，线程和协程</h4><ol><li>进程 是一个具有一定独立功能的程序在一个数据集上的一次动态执行过程， <code>是操作系统进行资源分配和调度的一个独立单位</code> ，是应用程序运行的载体。进程是一种抽象的概念，没有统一的标准定义</li><li>线程 是程序执行中的一个单一的顺序控制流程，是 <code>程序执行流的最小单元</code> ，是处理器调度和分配的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间 (也就是所在进程的内存空间). 一个标准的线程由线程 ID,d 当前指令指针 (PC), 寄存器和堆栈组成。而进程由内存空间 (代码，数据，进程空间，打开的文件) 和一个或多个线程组成</li><li>协程，英文 Coroutinex, 是一种 <code>基于线程之上,但又比线程更加轻量级的存在</code> ，这种由程序员自己写程序管理的轻量级线程叫做 [用户空间线程], 具有对内核来说不可见的特性</li></ol><p><mark>进程和线程的区别与联系</mark></p><p>【区别】:</p><ul><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li><li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行；</li><li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有资源，但可以访问隶属于进程的资源</li><li>系统开销:<ul><li>在创建或撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大与创建或撤销线程时的开销.</li><li>进程由独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径.</li><li>线程由自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有线程死掉</li><li>所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源比较大，效率要差一些</li></ul></li></ul><p>【联系】:</p><ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源</li><li>处理机分给线程，即真正在处理机上运行的是线程</li><li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步</li></ul><p>相关文章: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDA1NDY1MzgxNzkxODc1MTA5">线程，进程，协程及 JS 协程的发展</span></p><div class="tags"><a href="/tags/Http%E5%8D%8F%E8%AE%AE/" rel="tag"><i class="ic i-tag"></i> Http协议</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/" rel="tag"><i class="ic i-tag"></i> 浏览器跨域</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-06-30 16:13:20" itemprop="dateModified" datetime="2022-06-30T16:13:20+08:00">2022-06-30</time> </span><span id="2022/06/29/NodeJs/FrontEnd/webKnowLedge/" class="item leancloud_visitors" data-flag-title="Http基础知识" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>MuBai <i class="ic i-at"><em>@</em></i>源夢</li><li class="link"><strong>本文链接：</strong> <a href="https://proudmubai.github.io/2022/06/29/NodeJs/FrontEnd/webKnowLedge/" title="Http基础知识">https://proudmubai.github.io/2022/06/29/NodeJs/FrontEnd/webKnowLedge/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/06/29/NodeJs/Node/NodeConfig/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclh0m9pdj20zk0m8hdt.jpg" title="NodeJS安装与配置"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> NodeJs</span><h3>NodeJS安装与配置</h3></a></div><div class="item right"><a href="/2022/06/29/Database/MySQL/NodeQuerySQL/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclwuom7cj20zk0m8dvn.jpg" title="Mysql非常用语法"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Mysql</span><h3>Mysql非常用语法</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#http%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">Http 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-http-%E5%92%8C-https"><span class="toc-number">1.1.</span> <span class="toc-text">1. HTTP 和 HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1http-%E5%92%8Chttps-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">1.http 和 https 的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">2.http 和 https 的区别及优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-https%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">3. https 协议的工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-tcp%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.</span> <span class="toc-text">2. TCP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">1.TCP 三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2tcp%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">2.TCP 四次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3tcpip-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%9D%A0"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">3.TCP&#x2F;IP 如何保证数据包传输的有序可靠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4tcp%E5%92%8Cudp%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">4.TCP 和 UDP 的区别</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#3http%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">3.HTTP 请求跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">1. 跨域的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">2. 解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4cookie-sessionstorage-localstorage%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">4.Cookie, SessionStorage, localStorage 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.</span> <span class="toc-text">5. 粘包问题分析与策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">6. 浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">1. 从输入 URL 到页面加载的全过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">2. 浏览器重绘与重排的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">3. 如何触发重排和重绘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E7%BB%98%E6%88%96%E9%87%8D%E6%8E%92"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">4. 如何避免重绘或重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5304%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.0.5.</span> <span class="toc-text">5.304 过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">1.6.0.6.</span> <span class="toc-text">6. 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.6.0.7.</span> <span class="toc-text">7. 进程，线程和协程</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/06/29/NodeJs/FrontEnd/webKnowLedge/" rel="bookmark" title="Http基础知识">Http基础知识</a></li><li><a href="/2022/06/29/NodeJs/Node/NodeConfig/" rel="bookmark" title="NodeJS安装与配置">NodeJS安装与配置</a></li><li><a href="/2022/06/29/NodeJs/React/React%E5%85%A5%E9%97%A8%E7%AF%87/" rel="bookmark" title="React入门学习">React入门学习</a></li><li><a href="/2022/06/29/NodeJs/Vue/Axios/" rel="bookmark" title="Axios 异步通讯">Axios 异步通讯</a></li><li><a href="/2022/06/29/NodeJs/Vue/vite/" rel="bookmark" title="Vite前端构建开发工具">Vite前端构建开发工具</a></li><li><a href="/2022/06/29/NodeJs/Vue/vue3%E6%9E%84%E5%BB%BA/" rel="bookmark" title="Vue3项目创建">Vue3项目创建</a></li><li><a href="/2022/06/29/NodeJs/Vue/vue3/" rel="bookmark" title="Vue3.0语法变化">Vue3.0语法变化</a></li><li><a href="/2022/06/29/NodeJs/Vue/%E5%89%8D%E7%AB%AF%E6%96%87%E6%A1%A3/" rel="bookmark" title="前端常用API">前端常用API</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="MuBai" data-src="/images/avatar.jpg"><p class="name" itemprop="name">MuBai</p><div class="description" itemprop="description">萌新小白 & 学习点滴</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">20</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Byb3VkTXVCYWk=" title="https:&#x2F;&#x2F;github.com&#x2F;ProudMuBai"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item telegram" data-url="aHR0cHM6Ly90Lm1lL011YmFpQ3M=" title="https:&#x2F;&#x2F;t.me&#x2F;MubaiCs"><i class="ic i-paper-plane"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>链环</a><ul class="submenu"><li class="item"><a href="/links/friends" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/links/tool/" rel="section"><i class="ic i-star"></i>网址</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/06/29/NodeJs/Node/NodeConfig/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/06/29/Database/MySQL/NodeQuerySQL/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/special/" title="Step.4 主题特殊功能">Step.4 主题特殊功能</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/display/" title="Step.3 界面显示">Step.3 界面显示</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/dependents/" title="Step.1 依赖插件">Step.1 依赖插件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/2022/06/29/NodeJs/Vue/%E5%89%8D%E7%AB%AF%E6%96%87%E6%A1%A3/" title="前端常用API">前端常用API</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/React/" title="分类于 React">React</a></div><span><a href="/2022/06/29/NodeJs/React/React%E5%85%A5%E9%97%A8%E7%AF%87/" title="React入门学习">React入门学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/Mysql/" title="分类于 Mysql">Mysql</a></div><span><a href="/2022/06/29/Database/MySQL/NodeQuerySQL/" title="Mysql非常用语法">Mysql非常用语法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/2022/06/29/NodeJs/Vue/vue3%E6%9E%84%E5%BB%BA/" title="Vue3项目创建">Vue3项目创建</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/NodeJs/" title="分类于 NodeJs">NodeJs</a></div><span><a href="/2022/06/29/NodeJs/Node/NodeConfig/" title="NodeJS安装与配置">NodeJS安装与配置</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E5%85%B7/" title="分类于 数据库工具">数据库工具</a></div><span><a href="/2022/06/29/Database/MySQL/Navicat/" title="Navicat">Navicat</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/2022/06/29/NodeJs/Vue/vue3/" title="Vue3.0语法变化">Vue3.0语法变化</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022.06.30 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">MuBai @ MuBai Boat</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">208k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:09</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/06/29/NodeJs/FrontEnd/webKnowLedge/",favicon:{show:"(*^▽^*) 源起, 寻心逐夢",hide:"(๑‾᷅^‾᷅๑) 终了, 无悔"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->