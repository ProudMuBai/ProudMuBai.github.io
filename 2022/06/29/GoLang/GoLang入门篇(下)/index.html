<!-- build time:Sat Jan 28 2023 20:03:34 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="源夢" href="https://proudmubai.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="源夢" href="https://proudmubai.github.io/atom.xml"><link rel="alternate" type="application/json" title="源夢" href="https://proudmubai.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="GoLang,Go标准库,goroutine,文件读写"><link rel="canonical" href="https://proudmubai.github.io/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8B)/"><title>GoLang协程与标准库 - 编程语言 - GoLang | MuBai Boat = 源夢 = 人生如逆旅, 我亦是行人</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="loader-container"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">GoLang协程与标准库</h1><div class="meta"><span class="item" title="创建时间：2022-06-29 18:26:39"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-29T18:26:39+08:00">2022-06-29</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>71k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:05</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">MuBai Boat</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipew8gmvyj20zk0m87wh.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipesx5fdwj20zk0m81kx.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/golang/" itemprop="item" rel="index" title="分类于 GoLang"><span itemprop="name">GoLang</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/golang/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="item" rel="index" title="分类于 编程语言"><span itemprop="name">编程语言</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://proudmubai.github.io/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8B)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="MuBai"><meta itemprop="description" content="人生如逆旅, 我亦是行人, 萌新小白 & 学习点滴"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="源夢"></span><div class="body md" itemprop="articleBody"><h1 id="golang学习笔记"><a class="anchor" href="#golang学习笔记">#</a> GoLang 学习笔记</h1><h3 id="1gopackage"><a class="anchor" href="#1gopackage">#</a> 1.Go(package)</h3><h4 id="1标准库概述"><a class="anchor" href="#1标准库概述">#</a> 1. 标准库概述</h4><ul><li><p>像 fmt, os 等具有常用功能的内置包被称为<mark>标准库</mark>，大部分内置于 Go 本身</p></li><li><p><code>unsafe</code> : 包含一些打破 GO 语言 &quot;类型安全&quot; 的命令，一般程序中不回使用，可用在 C/C++ 程序的调用中</p></li><li><p><code>syscall - os - os/exec :</code></p><ul><li><p><code>os</code> : 提供平台无关性的擦偶作系统功能接口，采用 Unix 设计，隐藏了不同操作系统间的差异，让不</p><p>同的文件系统和操作系统对象表现一致</p></li><li><p><code>os/exec</code> : 提供运行外部操作系统命令和程序的方式</p></li><li><p><code>syscall</code> : 底层的外部包，提供操作系统底层调用的基本接口</p></li></ul></li><li><p><code>archive/tar</code> 和 <code>/zip-commpress</code> : 压缩 (解压缩) 文件</p></li><li><p><code>fmt</code> - <code>io</code> - <code>bufio</code> - <code>path/filepath</code> - <code>flag</code> :</p><ul><li><code>fmt</code> : 提供格式化输入输出功能.</li><li><code>io</code> : 提供了基本输入输出功能，大多数是围绕系统功能的封装</li><li><code>bufio</code> : 缓冲输入输出功能的封装</li><li><code>path/filepath</code> : 用来操作当前系统中的目标文件名路径</li><li><code>flag</code> : 对命令行参数的操作</li></ul></li><li><p><code>strings - strconv - unicode - regexp - bytes</code> :</p><ul><li><code>strings</code> : 提供对字符串的操作</li><li><code>strconv</code> : 提供将字符串转为基础类型的功能</li><li><code>unicode</code> : 为 Unicode 类型的字符串提供特殊的功能</li><li><code>regexp</code> : 正则表达式功能</li><li><code>bytes</code> : 提供对字符串分片的操作</li><li><code>index/suffixarray</code> : 字符串快速查询</li></ul></li><li><p><code>math - math/cmath - math/big - math/rand - sort:</code></p><ul><li><code>math</code> : 基本数学函数</li><li><code>math/cmath</code> : 对复数的操作</li><li><code>math/rand</code> : 伪随机数生成</li><li><code>sort</code> : 数组，自定义集合排序</li><li><code>math/big</code> : 大数字的实现和计算</li></ul></li><li><p><code>container - /list-ring-heap</code> : 集合操作</p><ul><li><code>list</code> : 双链表</li><li><code>right</code> : 环形链表</li></ul></li><li><p><code>time</code> - <code>log</code></p><ul><li><code>time</code> : 日期和时间的基本操作.</li><li><code>log</code> : 记录程序运行时产生的日志</li></ul></li><li><p><code>encoding/json - encoding/xml - text/template</code> :</p><ul><li><code>encoding/json</code> : 读取并解码 写入并编码 JSON 数据</li><li><code>encoding/xml</code> : 简单的 XML1.0 解析器</li><li><code>text/template</code> : 生成像 HTML 一样的数据与文本混合的驱动模板</li></ul></li><li><p><code>net - net/http - html</code> :</p><ul><li><code>net</code> : 网络数据的基本操作</li><li><code>http</code> : 提供一个可拓展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复</li><li><code>html</code> : HTML5 解析器</li></ul></li><li><p><code>runtime</code> : Go 程序运行时的交互操作，例如垃圾回收和携程创建</p></li><li><p><code>reflect</code> : 实现通过程序运行时反射，让程序操作任意类型的变量</p></li><li><p><code>exp</code> : 包中有许多将被编译为新包的实验性包.</p></li></ul><h4 id="2regexp-包"><a class="anchor" href="#2regexp-包">#</a> 2.regexp 包</h4><ul><li><p>简单模式，使用 <code>Match</code> 方法，变量 ok 将返回 true 或者 false</p><p><code>ok, _ := regexp.Match(pat,[]byte(searchIn))</code></p></li><li><p>使用 <code>MatchString</code> , 直接传入字符串</p><p><code>ok, _ := regexp.MatchString(pat, searchIn)</code></p></li><li><p><code>Compile</code> 函数肯返回一个错误，一般使用时忽略对错误的判断，</p></li><li><p><code>NustCompile</code> 一样可以检验正则的有效性，当正则不合法时，程序将 <code>panic</code></p></li></ul><h4 id="3锁和-sync包"><a class="anchor" href="#3锁和-sync包">#</a> 3. 锁和 sync 包</h4><ul><li><p>复杂程序中，通常通过<mark>不同线程</mark>执行不同应用来实现程序的并发，导致不同线程对同一变量</p><p>使用的竞争 (通常被称为资源竞争)</p></li><li><p>map 类型<mark>不存在锁机制</mark>来实现安全访问的效果 (出于对性能的考虑),map 类型是非线程安全的，</p><p>并行访问共享的 map 类型数据时，map 数据将会出错</p></li><li><p>Go 语言的锁机制时通过<mark> sync</mark> 包中的<mark> Mutex</mark> 来实现的，sync 来源于 synchronize, 表示线程</p><p>将有序的对同一变量进行访问</p></li><li><p><code>sync.Mutex</code> 是一个互斥锁，其作用是守护领截取入口，确保同一时间只能有一个线程进入</p><p>临界区</p></li><li><p>sync 包中还有 <code>RWMutex</code> 锁：通过 <code>RLock()</code> 允许同一时间多个线程对变量进行读操作，但只能</p><p>一个线程进行写操作，如果使用 <code>Lock()</code> 将和普通的 <code>Mutex</code> 作用相同，<span class="exturl" data-url="aHR0cDovL3huLS1vbmNlLXpmNWZwMHgzejFiNGgyZS5Ebw=="> 包中还有 once.Do</span>(call)</p><p>这个方法确保被调用函数只能被调用一次</p></li><li><p>sync 可以解决同一时间只能一个线程访问 map 类型数据的问题，但会导致程序明显变慢或引起其他</p><p>问题，go 提倡使用 <code>goroutines</code> 和 <code>channels</code> 来解决问题</p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token string">"sync"</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> Infostruct<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    mu sync<span class="token punctuation">.</span>Mutex</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">//···other fields,s1.s2.: Str string</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">Update</span><span class="token punctuation">(</span>info <span class="token operator">*</span>Info<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    info<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    info<span class="token punctuation">.</span>Str <span class="token operator">=</span> <span class="token comment">//new value</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    info<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="4精密计算和big包"><a class="anchor" href="#4精密计算和big包">#</a> 4. 精密计算和 big 包</h4><ul><li><p>go 语言中的 <code>float64</code> 类型进行浮点运算，返回结果精确到 15 位，但对超出 <code>int64</code> 或 <code>uint64</code> 类型的</p><p>大数字进行计算时对精度要求严格，就无法使用浮点数，在内存中只能近似的表示</p></li><li><p>对于整数的高精度计算 GO 语言提供了 <code>big</code> 包，包含在 <code>math</code> 包下，有用来表示大有理数的 <code>big.Rat</code> 类型</p><p>和表示大整数的 <code>big.Int</code> 类型，可以实现任意类型的数字，但<mark>内存消耗更大</mark>，处理起来也<mark>比内置的数字类型</mark></p><p><mark>慢很多</mark></p></li><li><p>大整型数字是通过 <code>big.NewInt(n)</code> 来构造的，n 为 <code>int64</code> 类型整数.</p></li><li><p>大有理数通过 <code>big.NewRat(n,d)</code> 构造， <code>n(分子) d(分母)</code> 都是 <code>int64</code> 类型整数</p></li><li><p>大数字类型计算，Add (),Sub (),Mul (),Div () &lt; 加，减，乘，除 &gt;, 计算结果返回后可链式调用，无需中</p><p>间变量保存，节省内存</p></li></ul><h4 id="5自定义包和可见性"><a class="anchor" href="#5自定义包和可见性">#</a> 5. 自定义包和可见性</h4><ul><li><p>包时 Go 语言中代码组织和代码编译的主要方式.</p></li><li><p>自定义包命名要使用短小且不含有 _(下划线) 的小写单词来为文件命名</p></li><li><p><code>import alias &quot;./pack&quot;</code> 导入 <code>pack</code> 包，并取别名 <code>alias</code> , 通过 <code>alias</code> 进行调用</p></li><li><p><code>import . &quot;./pack&quot;</code> 使用 <code>.</code> 作为包的别名时，可以不通过包名来使用其中的项目</p><p>例如: <code>test := ReturnStr()</code></p></li><li><p><code>import _ &quot;./pack1/pack1&quot;</code> , 只导入其副作用，只执行它的 init 函数并初始化其中的全局变量</p></li><li><p>导入外部安装包 <code>go install</code></p></li><li><p><code>go mod</code> 使用时包引用需要以项目根路径开始</p></li></ul><h3 id="2结构体struct"><a class="anchor" href="#2结构体struct">#</a> 2. 结构体 (struct)</h3><ul><li>Go 通过<mark>类型别名 (alias types)</mark> 和 结构体的形式支持用户自定义类型，一个带属性的结构体试图表示显示世界中的实体。结构体是<mark>复合类型 (composite types)</mark>, 当需要定义一个类型，由一系列属性组成，就应该使用结构体，结构体将数据聚集在一起进行访问，就像是一个独立实体的一部分，结构体也是值类型，因此<mark>可以通过 new 函数来创建</mark>.</li><li>组成结构体类型的数据被称为字段，每个字段都有一个类型和名字，在结构体中，<mark> 字段名字必须是唯一的</mark></li><li>结构体在软件工程上旧的术语是 ADT (抽象数据类型 Abstract Data Type), 在一些老的编程语言中称为<strong>记录 (Record)</strong>, 在 c 家族中也存在，并且也是 struct, 在面向对象的变成语言中，类似于无方法的轻量级类，但 Go 语言没有类的概念，因此，Go 中结构体有着更为重要的地位.</li><li>结构体是值类型数据</li></ul><h4 id="1结构体定义"><a class="anchor" href="#1结构体定义">#</a> 1. 结构体定义</h4><ul><li>结构体定义的一般方式</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> identifier <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    field1 type1</pre></td></tr><tr><td data-num="3"></td><td><pre>    field2 type2</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 定义简单的结构体</span></pre></td></tr><tr><td data-num="7"></td><td><pre>typr T <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">,</span>b <span class="token builtin">int</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>结构体的字段都有名字，如果字段在代码中从来不会被使用，那么也可以命名为 _(下划线).</li><li>结构体的字段可以是任何类型，甚至可以是结构体本身，也可以是函数或结构</li><li>数组可以看作是一种结构体类型，不过其使用的是下标不是具名的字段</li><li>new 函数给一个新的结构体分配内存，返回指向已分配内存的指针: <code>var t *T = new(T)</code> , 如果需要可以将语句放在不同的行 (例如：定义是包范围的，但是却没必要立刻分配)</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> t <span class="token operator">*</span>T</pre></td></tr><tr><td data-num="2"></td><td><pre>t <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 惯用语法，变量 t 是指向 T 的指针，此时结构体字段值为所属类型的零值</span></pre></td></tr><tr><td data-num="4"></td><td><pre>t <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="6"></td><td><pre>* 声明 t 也会给 t 分配内存，并零值化内存，但此时 t 是类型 T,</pre></td></tr><tr><td data-num="7"></td><td><pre>* 在这两种方式中 t 被称为 类型 T 的 一个实例 (instance) 或 对象 (object)</pre></td></tr><tr><td data-num="8"></td><td><pre>*/</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">var</span> t T</pre></td></tr></table></figure><ul><li><p>使用 <code>fmt.Println</code> 打印一个结构体的默认输出可以很好的显示其内容，类似使用 % v 选项</p></li><li><p>像面向对象的语言那样，结构体也可以使用点号符给字段赋值: <code>structname.fieldname = value</code></p></li><li><p>使用点号符可以获取结构体的字段值: structname.filedname , 在 Go 语言中这叫做 ** 选择器 (selector)** 无论是 结构体类型 还是结构体类型指针，都使用同样的 ** 选择器符 (selector-notation)** 来引用结构体的字段</p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>typr myStruct <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>i <span class="token builtin">int</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> v myStruct <span class="token comment">//v 是结构体类型变量</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">var</span> p <span class="token operator">*</span>myStruct <span class="token comment">//p 是指向一个结构体类型变量的指针</span></pre></td></tr><tr><td data-num="4"></td><td><pre>v<span class="token punctuation">.</span>i</pre></td></tr><tr><td data-num="5"></td><td><pre>p<span class="token punctuation">.</span>i</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 初始化结构体实例的 更简短和惯用的方式如下:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>ms <span class="token operator">:=</span> <span class="token operator">&amp;</span>struct1<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15.6</span><span class="token punctuation">,</span> <span class="token string">"Chris"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 混合字面量语法 (composite literal syntax) &amp;struct &#123;a, b, c&#125; 是一种简写，底层仍会调用 new ()</span></pre></td></tr></table></figure><ul><li><p>初始化结构体实例的 更简短和惯用的方式如下: <code>ms := &amp;struct1&#123;10, 15.6, &quot;Chris&quot;&#125;</code></p></li><li><p>混合字面量语法 (composite literal syntax) <code>&amp;struct&#123;a, b, c&#125;</code> 是一种简写，</p><p>底层仍会调用 <code>new()</code> , 这里的值必须按照字段顺序来写，表达式 <code>new(Type)</code> 和 <code>&amp;Type&#123;&#125;</code> 是等价的</p></li><li><p>结构体的初始化方式</p></li><li><p>(A): 必须以字段在结构体定义时的顺序赋值，&amp; 不是必须的</p></li><li><p>(B): fieldname (字段名) : val (值), 这种形式顺序不必一直</p></li><li><p>(C): fieldname : val 形式赋值可以进行部分赋值</p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>typr Interval <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    start <span class="token builtin">int</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    end <span class="token builtin">int</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 初始化方式</span></pre></td></tr><tr><td data-num="6"></td><td><pre>方式<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>	intr <span class="token operator">:=</span> Interval<span class="token punctuation">&#123;</span><span class="token number">0</span> <span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>方式<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>	intr <span class="token operator">:=</span> Interval<span class="token punctuation">&#123;</span>end<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>start<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>方式<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>	intr <span class="token operator">:=</span> Interval<span class="token punctuation">&#123;</span>end<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>结构体初始化</mark></p><ul><li>结构体声明时，其值类型字段默认为相关类型的空值</li><li>其引用数据类型默认为 nil, 使用 slice, map 等引用类型时，需要先 make 再使用</li><li>不同结构体字段时独立的，互不影响</li></ul><p><mark>使用 new 初始化</mark></p><p><img data-src="https://s4.ax1x.com/2021/12/18/TEIIDe.png" alt="image 20211215165904477"></p><p><mark>作为结构体字面量初始化</mark></p><p><img data-src="https://s4.ax1x.com/2021/12/18/TEIb4I.png" alt="image 20211215170017894"></p><p><mark>struct 初始化及调用的不同方式</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Personstruct <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    firstName <span class="token builtin">string</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    lastName <span class="token builtin">string</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token function">upPerson</span><span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    p<span class="token punctuation">.</span>firstName <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    p<span class="token punctuation">.</span>lastName <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>lastName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 1-struct as a value type:</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">var</span> pers1 Person</pre></td></tr><tr><td data-num="12"></td><td><pre>    pers1<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">"Chris"</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    Pers1<span class="token punctuation">.</span>lastName <span class="token operator">=</span> <span class="token string">"Woodward"</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">upPerson</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pers1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The name of the person is %s %s\n"</span><span class="token punctuation">,</span>pers1<span class="token punctuation">.</span>firstName<span class="token punctuation">,</span>pers1<span class="token punctuation">.</span>lastName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// 2-struct as a pointer</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    pers2 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   	<span class="token comment">/**</span></pre></td></tr><tr><td data-num="20"></td><td><pre>   	* 通过 new 出来的指针，也可以直接使用 </pre></td></tr><tr><td data-num="21"></td><td><pre>   	* . 点语法进行字段赋值</pre></td></tr><tr><td data-num="22"></td><td><pre>   	* GO 语言会自动进行转换</pre></td></tr><tr><td data-num="23"></td><td><pre>   	*/</pre></td></tr><tr><td data-num="24"></td><td><pre>    pers2<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">"Chris"</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    pers2<span class="token punctuation">.</span>lastName <span class="token operator">=</span> <span class="token string">"Woodward"</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment">// 通过解指针的方式来设置值</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">(</span><span class="token operator">*</span>pers2<span class="token punctuation">)</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> <span class="token string">"Woodward"</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token function">upPerson</span><span class="token punctuation">(</span>pers2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The name of the person is %s %s\n"</span><span class="token punctuation">,</span>pers1<span class="token punctuation">.</span>firstName<span class="token punctuation">,</span>pers1<span class="token punctuation">.</span>lastName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">// 3-struct as a literal:</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    pers3 <span class="token operator">:=</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Chris"</span><span class="token punctuation">,</span><span class="token string">"Woodward"</span><span class="token punctuation">&#125;</span>    </pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token function">upPerson</span><span class="token punctuation">(</span>per3<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The name of the person is %s %s\n"</span><span class="token punctuation">,</span>pers1<span class="token punctuation">.</span>firstName<span class="token punctuation">,</span>pers1<span class="token punctuation">.</span>lastName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token comment">// 4-struct as a literal:</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    pers3 <span class="token operator">:=</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">&#123;</span>firstName<span class="token punctuation">:</span> <span class="token string">"Chris"</span><span class="token punctuation">,</span>lastName<span class="token punctuation">:</span> <span class="token string">"Woodward"</span><span class="token punctuation">&#125;</span>    </pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token function">upPerson</span><span class="token punctuation">(</span>per3<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The name of the person is %s %s\n"</span><span class="token punctuation">,</span>pers1<span class="token punctuation">.</span>firstName<span class="token punctuation">,</span>pers1<span class="token punctuation">.</span>lastName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>结构体的内存布局</mark></p><p>Go 语言中，结构体和其所包含的数据类型在内存中是<mark>以连续块的形式存在</mark>的，(即使结构体中嵌套有其他的结构体)</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Rect1struct<span class="token punctuation">&#123;</span>Min<span class="token punctuation">,</span>MaxPoint<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> Rect2struct<span class="token punctuation">&#123;</span>Min<span class="token punctuation">,</span>Max<span class="token operator">*</span>Point<span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://s4.ax1x.com/2021/12/18/TEIHUA.png" alt="image 20211215172835844"></p><p><mark>递归结构体：链表</mark></p><p><img data-src="https://s4.ax1x.com/2021/12/18/TEIoHH.png" alt="image 20211215173041761"></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* 链表的第一个元素为 head, 其指向第二个元素，</pre></td></tr><tr><td data-num="3"></td><td><pre>* 最后一个元素 tail 没有后继元素，所以 su 为 nil</pre></td></tr><tr><td data-num="4"></td><td><pre>* 链表存在很多数据节点，且可以动态增长或收缩</pre></td></tr><tr><td data-num="5"></td><td><pre>*/</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">type</span> Nodestruct<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    data    <span class="token builtin">float64</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    su      <span class="token operator">*</span>Node</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 双向链表，由前趋节点 pr 和 后继节点 su :</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">type</span> Nodestruct<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    pr      <span class="token operator">*</span>Node</pre></td></tr><tr><td data-num="13"></td><td><pre>    data    <span class="token builtin">float64</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    su      <span class="token operator">*</span>Node</pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>递归结构体：二叉树</mark></p><p><img data-src="https://s4.ax1x.com/2021/12/18/TEI7Ed.png" alt="image 20211215173748029"></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* 二叉树每个节点 至多链接至两个节点: </pre></td></tr><tr><td data-num="3"></td><td><pre>* 左节点 (le) 右节点 (ri)</pre></td></tr><tr><td data-num="4"></td><td><pre>* 左右节点本身也可以有左右节点</pre></td></tr><tr><td data-num="5"></td><td><pre>* 树的顶层节点：根节点 (root)		</pre></td></tr><tr><td data-num="6"></td><td><pre>* 叶子节点 (leaves), 叶子节点的 le 和 ri 指针为 nil</pre></td></tr><tr><td data-num="7"></td><td><pre>*/</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">type</span> Treestruct <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	le <span class="token operator">*</span>Tree</pre></td></tr><tr><td data-num="10"></td><td><pre>    data <span class="token builtin">float64</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    ri <span class="token operator">*</span>Tree</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>结构体转换</mark></p><p>Go 类型转换遵循严格的规则，当结构体定义了一个 alias (别名) 类型时，结构体 和 其 alias 类型都<mark>有相同的底层类型</mark>，两者可以互相转换，但须注意其中非法复制或转换引起的编译错误</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> number <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    f <span class="token builtin">float32</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">type</span> nr number	<span class="token comment">//alias type</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    a <span class="token operator">:=</span> number<span class="token punctuation">&#123;</span><span class="token number">5.0</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    b <span class="token operator">:=</span> nr<span class="token punctuation">&#123;</span><span class="token number">5.0</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// var i float32 = b   </span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// compile-error: cannot use b (type nr) as type float32 in assignment</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token comment">// var i = float32(b)  </span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// compile-error: cannot convert b (type nr) to type float32</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token comment">// var c number = b    </span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// compile-error: cannot use b (type nr) as type number in assignment</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">// needs a conversion:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">number</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="2结构体工厂"><a class="anchor" href="#2结构体工厂">#</a> 2. 结构体工厂</h4><ul><li>Go 语言不支持面向对象编程语言中的构造方法，但可以很容易的在 Go 中实现 ==&quot;构造工厂&quot;== 方法.</li></ul><p>​	通常会为类型定义一个工厂，工厂名字以 new 或 New 开头</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> File <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    fd <span class="token builtin">int</span>	<span class="token comment">// 文件描述符</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    name <span class="token builtin">string</span>	<span class="token comment">// 文件名</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 结构体类型对应的工厂方法，返回一个指向结构体实例的指针</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">NewFile</span><span class="token punctuation">(</span>fd <span class="token builtin">int</span><span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>File <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">nil</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>File<span class="token punctuation">&#123;</span>fd<span class="token punctuation">,</span> name<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 调用工厂方法，返回实例化对象</span></pre></td></tr><tr><td data-num="13"></td><td><pre>f <span class="token operator">:=</span> <span class="token function">NewFile</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">"./test.txt"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>结构体类型 初始化表达式 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的</li><li>获取 结构体类型 T 的一个实例占用内存，size := unsafe.Sizeof (T {})</li><li>强制使用工厂方法：结构体名称首字母小写变为私有</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> matrix <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token function">NewMatrix</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token operator">*</span>matrix <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    m <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>matrix<span class="token punctuation">)</span> <span class="token comment">// 初始化 m</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> m</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 在其他包中使用工厂</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">import</span> <span class="token string">"matrix"</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token operator">...</span></pre></td></tr><tr><td data-num="12"></td><td><pre>wrong <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>matrix<span class="token punctuation">)</span>     <span class="token comment">// 编译失败（matrix 是私有的）</span></pre></td></tr><tr><td data-num="13"></td><td><pre>right <span class="token operator">:=</span> matrix<span class="token punctuation">.</span><span class="token function">NewMatrix</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>  <span class="token comment">// 实例化 matrix 的唯一方式</span></pre></td></tr></table></figure><ul><li><p><mark>map 和 struct vs new () 和 make ()</mark></p></li><li><p>能够使用 <code>make()</code> 的三种类型 : slice\maps\channels</p></li><li><p><code>make()</code> 一个结构体变量，会 <code>引发编译错误</code></p></li><li><p><code>new()</code> 一个 map 向其填充数据会 <code>引发运行时错误</code> ， <code>new(slice)</code> 返回的是 <code>指向nil的指针</code></p><p>其尚未被分配内存，所以在使用 map 是需要谨慎</p></li></ul><h4 id="3使用自定义包的结构体"><a class="anchor" href="#3使用自定义包的结构体">#</a> 3. 使用自定义包的结构体</h4><p>在 main.go 中使用来自 struct_pack 下的包 structPack</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// structPack.go</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">package</span> structPack</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">type</span> ExpStruct <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    Mi1	<span class="token builtin">int</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    Mf1	<span class="token builtin">int</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// main.go</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token string">"fmt"</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token string">"./struct/pack/structpack"</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">struct</span> <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>structPack<span class="token punctuation">.</span>ExpStruct<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">struct</span><span class="token punctuation">.</span>Mi1 <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">struct</span><span class="token punctuation">.</span>Mf1 <span class="token operator">=</span> <span class="token number">16</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    </pre></td></tr><tr><td data-num="18"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Mi1 = %d\n"</span><span class="token punctuation">,</span> struct1<span class="token punctuation">.</span>Mi1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Mf1 = %f\n"</span><span class="token punctuation">,</span> struct1<span class="token punctuation">.</span>Mf1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// 输出</span></pre></td></tr><tr><td data-num="22"></td><td><pre>Mi1 <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="23"></td><td><pre>Mf1 <span class="token operator">=</span> <span class="token number">16.000000</span></pre></td></tr></table></figure><h4 id="4带标签的结构体"><a class="anchor" href="#4带标签的结构体">#</a> 4. 带标签的结构体</h4><ul><li><p>结构体中的字段除了有名字和类型外，还有一个可选的 <code>标签(tag)</code> : 是一个附属于字段的字符串，可以是文档或其他的重要标记，标记内容不可以在一般的变成中使用，只有 包 <code>reflect</code> 能获取</p></li><li><p><code>reflect</code> 可以在 运行时自省类型，屬性和方法，使用 <code>reflect.TypeOf(variable)</code> 获取变量的正确类型， <code>reflect.TypeOf(struct)</code> 可以通过返回值的 <code>Field</code> 来索引结构体的字段，然后使用其 Tag 属性</p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token string">"fmt"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">"reflect"</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">type</span> TagType <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token comment">// tags</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">//json db 格式化使用形式 `json:"name"db:"name"`</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    field1 <span class="token builtin">bool</span>   <span class="token string">"An important answer"</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    field2 <span class="token builtin">string</span> <span class="token string">"The name of the thing"</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    field3 <span class="token builtin">int</span>    <span class="token string">"How much there are"</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">//json 序列化时使用 tag</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">type</span> TagType <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token comment">// tags</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    field1 <span class="token builtin">bool</span>   <span class="token string">"An important answer"</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    field2 <span class="token builtin">string</span> <span class="token string">"The name of the thing"</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    field3 <span class="token builtin">int</span>    <span class="token string">"How much there are"</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    tt <span class="token operator">:=</span> TagType<span class="token punctuation">&#123;</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"Barak Obama"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token function">refTag</span><span class="token punctuation">(</span>tt<span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">func</span> <span class="token function">refTag</span><span class="token punctuation">(</span>tt TagType<span class="token punctuation">,</span> ix <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    ttType <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>tt<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    ixField <span class="token operator">:=</span> ttType<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>ix<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> ixField<span class="token punctuation">.</span>Tag<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">// 输出</span></pre></td></tr><tr><td data-num="32"></td><td><pre>An important answer</pre></td></tr><tr><td data-num="33"></td><td><pre>The name of the thing</pre></td></tr><tr><td data-num="34"></td><td><pre>How much there are</pre></td></tr></table></figure><h4 id="5匿名字段和内嵌结构"><a class="anchor" href="#5匿名字段和内嵌结构">#</a> 5. 匿名字段和内嵌结构</h4><ul><li>结构体可以包含一个或多个<mark>匿名 (或内嵌字段)</mark>, 即字段没有显示的名字，只有字段类型是必须的，此时<mark>类型就是字段的名字</mark>。匿名字段本身可以是一个结构体类型，即 <mark>结构体可以包含内嵌结构体</mark></li><li>Go 语言中 通过内嵌或组合实现 模拟类的继承行为，Go 语言中，相比较继承，组合更受青睐</li><li>通过类型 <code>outer.int</code> 的名字来获取存储在匿名字段中的数据，因此 (<mark>在一个结构体中每一种数据类型只能有一个匿名字段</mark>)</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> innerS <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    in1 <span class="token builtin">int</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    in2 <span class="token builtin">int</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">type</span> outerS <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    b    <span class="token builtin">int</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    c    <span class="token builtin">float32</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token builtin">int</span>  <span class="token comment">// anonymous field</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    innerS <span class="token comment">//anonymous field</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    outer <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>outerS<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    outer<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">6</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    outer<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">7.5</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    outer<span class="token punctuation">.</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">60</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    outer<span class="token punctuation">.</span>in1 <span class="token operator">=</span> <span class="token number">5</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    outer<span class="token punctuation">.</span>in2 <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"outer.b is: %d\n"</span><span class="token punctuation">,</span> outer<span class="token punctuation">.</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"outer.c is: %f\n"</span><span class="token punctuation">,</span> outer<span class="token punctuation">.</span>c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"outer.int is: %d\n"</span><span class="token punctuation">,</span> outer<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"outer.in1 is: %d\n"</span><span class="token punctuation">,</span> outer<span class="token punctuation">.</span>in1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"outer.in2 is: %d\n"</span><span class="token punctuation">,</span> outer<span class="token punctuation">.</span>in2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// 使用结构体字面量</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    outer2 <span class="token operator">:=</span> outerS<span class="token punctuation">&#123;</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7.5</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> innerS<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"outer2 is:"</span><span class="token punctuation">,</span> outer2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>内嵌结构体</mark></p><ul><li>结构体也是一种数据类型，因此也可以做为一个匿名字段来使用，外层结构体通过 <code>outer.struct.File</code> 直接进入内层结构体的字段，内层结构体甚至可以来自其他包，内层结构体被简单的插入或者内嵌进外层结构体，这种 简单继承机制提供了一种方式，使得可以从另一个或者一些类型继承部分或全部实现</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token string">"fmt"</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">type</span> A <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    ax<span class="token punctuation">,</span> ay <span class="token builtin">int</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">type</span> B <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    A</pre></td></tr><tr><td data-num="9"></td><td><pre>    bx<span class="token punctuation">,</span> by <span class="token builtin">float32</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    b <span class="token operator">:=</span> B<span class="token punctuation">&#123;</span> A<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>ax<span class="token punctuation">,</span> b<span class="token punctuation">.</span>ay<span class="token punctuation">,</span> b<span class="token punctuation">.</span>bx<span class="token punctuation">,</span> b<span class="token punctuation">.</span>by<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>A<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// 输出</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> </pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>命名冲突 当两个字段拥有相同的名字 (可能是继承来的名字)</mark></p><ol><li>外层名字会覆盖内层名字 (但是两者的内存空间都保留), 这提供了一种重载字段或方法的方式；</li><li>如果<mark>相同的名字在同一级别出现两次</mark>，且这个名字被程序使用了，将会应发一个错误 (不使用则不影响), 没有办法解决这种问题引起的二义性</li><li>类型别名：处理 JSON 相关操作 type <code>strMap2Any = map[string]interface &#123;&#125;</code></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* 规则 2: 使用 c.a 是错误的，无法确定是 c.A.a 还是 c.B.a , 会导致编译器错误:</pre></td></tr><tr><td data-num="3"></td><td><pre>* ambiguous DOT reference c.a disambiguate with either c.A.a or c.B.a。</pre></td></tr><tr><td data-num="4"></td><td><pre>*/</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">type</span> A <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>a <span class="token builtin">int</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">type</span> B <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">type</span> c <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>A<span class="token punctuation">;</span> B<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">func</span> main <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">var</span> c C</pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token comment">//c.a = 11   ambiguous selector c.a 模棱两可的选择器</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	c<span class="token punctuation">.</span>A<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	c<span class="token punctuation">.</span>B<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">50</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	c<span class="token punctuation">.</span>B<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">30</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>输出 <span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>A<span class="token punctuation">:</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">&#125;</span> B<span class="token punctuation">:</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">:</span><span class="token number">50</span> b<span class="token punctuation">:</span><span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="19"></td><td><pre>* 规则 1: 使用 d.b 是没问题的：获取的是 float32, 而不是 B 的 b</pre></td></tr><tr><td data-num="20"></td><td><pre>* 想要内层的 b 可以通过 d.B.b 得到</pre></td></tr><tr><td data-num="21"></td><td><pre>*/</pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">type</span> D <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>B<span class="token punctuation">;</span> b <span class="token builtin">float32</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="6结构体方法"><a class="anchor" href="#6结构体方法">#</a> 6. 结构体方法</h4><ol><li>在 Go 语言中，结构体就像是类的一种简化形式，Go 方法是作用在接受者 (receiver) 上的一个函数，接收者是某种类型的变量。因此方法是一种<mark>特殊类型的函数</mark>.</li><li>接收者类型 <mark>(几乎) 是任何类型</mark>，任何类型都可以有方法，甚至是函数类型，可以是 int、bool、string 或数组的别名类型，但 <mark>接收者不能是一个接口类型</mark>，因为接口是一个抽象定义，但是方法是具体实现.</li><li>接收者不能是一个指针类型，但是可以是任何其他允许类型的指针</li><li>Go 语言中，类型的代码和绑定的方法可以 在<mark>不同源文件</mark>，但是<mark>必须是同一个包</mark>.</li><li>因为方法是函数，所以不允许方法重载，即 对于一个类型只能有一个给定名称的方法，但基于接收者类型，是有重载的：具有相同名字的方法可以再两个或者多个不通风的接收者类型上存在</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 别名类型 没有原始类型上已经定义过的方法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>denseMatrix<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>b Matrix<span class="token punctuation">)</span> Matrix</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>sparseMatrix<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>b Matrix<span class="token punctuation">)</span> Matrix</pre></td></tr></table></figure><h6 id="1定义方法的一般格式"><a class="anchor" href="#1定义方法的一般格式">#</a> 1. 定义方法的一般格式 :</h6><ul><li><code>recv</code> 就像是面向对象语言中的 <code>this</code> 或 <code>self</code> , Go 中并没有这两个关键字，可以使用 <code>this</code> 或 <code>self</code> 作为 <code>receiver</code> 的名字</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 在方法名之前，func 关键字之后的括号中指定 receiver</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>recv receiver_type<span class="token punctuation">)</span> <span class="token function">methodName</span><span class="token punctuation">(</span>parameter_list<span class="token punctuation">)</span> <span class="token punctuation">(</span>return_value_list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 如果方法不需要使用 recv 的值，可以用 _替换</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token boolean">_</span> recevier_type<span class="token punctuation">)</span> <span class="token function">methodName</span><span class="token punctuation">(</span>parameter_lsit<span class="token punctuation">)</span> <span class="token punctuation">(</span>return_value_list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="7"></td><td><pre>* 如果 `recv` 是 `receiver` 的实例，`Method` 是方法名</pre></td></tr><tr><td data-num="8"></td><td><pre>* 那么方法调用遵循传统的 `object.name` 选择器符号:</pre></td></tr><tr><td data-num="9"></td><td><pre>*/</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">type</span> Recevier <span class="token keyword">struct</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>r recevier<span class="token punctuation">)</span> <span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">var</span> recv Recevier</pre></td></tr><tr><td data-num="17"></td><td><pre>recv<span class="token punctuation">.</span><span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h6 id="2类型和对应方法的定义域"><a class="anchor" href="#2类型和对应方法的定义域">#</a> 2. 类型和对应方法的定义域</h6><ol><li>类型和作用在其上的方法必须在同一个包定义，类型在其他 或 非本地的包中定义方法都会报错</li><li>通过 定义类型的别名类型，然后再为别名类型定义方法。或将其 作为匿名类型嵌入在新的结构体中 (方法只在别名类型上有效)</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 别名类型定义方法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> myTime time<span class="token punctuation">.</span>Time</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>t myTime<span class="token punctuation">)</span> <span class="token function">cropTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">LocalTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 匿名嵌入结构体中</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">type</span> myTime struict <span class="token punctuation">&#123;</span> time<span class="token punctuation">.</span>TIme <span class="token comment">/* 匿名字段 */</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>t myTime<span class="token punctuation">)</span> <span class="token function">cropTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">LocalTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h6 id="3函数和方法的区别"><a class="anchor" href="#3函数和方法的区别">#</a> 3. 函数和方法的区别</h6><ol><li>函数将变量作为参数: <code>Function (recv)</code></li><li>方法在变量上被调用: <code>recv.Method()</code></li><li>在接受者是指针时，方法可以改变接收者的值 (或状态), 函数将参数作为指针传递也可以做到</li><li>接收者必须有一个 显示的名字，这个名字必须在方法中被使用</li><li><code>receiver_type</code> <strong>叫做 (接收者) 基本类型</strong>，这个类型必须在和方法同样的包中被声明</li><li>Go 中 (接收者) 类型关联的方法不必写在类型结构体中，耦合更加宽松；类型和方法之间的关联由接收者建立</li><li>方法 没有和 数据定义 (结构体) 混合在一起：两者是正交的类型；表示 ==(数据)== 和<mark>行为 (方法) 是独立的</mark></li></ol><h6 id="4指针或值作为接收者"><a class="anchor" href="#4指针或值作为接收者">#</a> 4. 指针或值作为接收者</h6><ol><li>鉴于性能原因， <code>recv</code> 最常见的是一个指向 <code>receiver_type</code> 的指针</li><li>想要方法改变接收者的数据，就在接收者类型的指针上定义该方法，否则就在普通的值类型上定义方法</li><li>Go 为我们做了探测工作，我们无需指出是否在指针上调用方法</li><li><strong>指针方法和值方法都可以在指针或非指针上被调用</strong></li></ol><h6 id="5方法和未导出字段"><a class="anchor" href="#5方法和未导出字段">#</a> 5. 方法和未导出字段</h6><ol><li><code>getter</code> 和 <code>setter</code> , 对 导出类型 <code>Person</code> 的<mark>未导出字段</mark>进行赋值和获取</li><li>对象的字段 (属性) 不应该由 2 个或 2 个以上的线程在同一时间改变，如果程序发生这种情况，为了安全并发访问，可以使用包 <code>sync</code> 中的方法</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> person</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    field1 <span class="token builtin">string</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    field2  <span class="token builtin">string</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">Field1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> p<span class="token punctuation">.</span>field1</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">SetField1</span><span class="token punctuation">(</span>newName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    p<span class="token punctuation">.</span>firstName <span class="token operator">=</span> field1</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h6 id="6内嵌类型的方法和继承"><a class="anchor" href="#6内嵌类型的方法和继承">#</a> 6. 内嵌类型的方法和继承</h6><ol><li>当一个<mark>匿名类型</mark>被 <mark>内嵌在结构体中</mark> 时，匿名类型 的可见方法 也同样被内嵌，效果等同于 <strong>继承</strong> 了这些相关方法: <strong>将父类型放在子类型中来实现亚型</strong>。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果</li><li>内嵌将已经存在类型的字段和方法注入到 另一个类型中：匿名字段上 的 方法 &quot;晋升&quot; 为外层类型的方法，类型也可以有只作用于本身实例而不作用于内嵌 &quot;父类型&quot; 的方法</li><li>覆写方法 (像字段一样) : 和内嵌方法具有相同名字的外层类型的方法会覆写内嵌类型对应的方法</li><li>因为一个结构体<mark>可以嵌入多个匿名类型</mark>，所以可以实现简单版本的 <mark>多重继承</mark>.</li><li>结构体内嵌 同包结构体时，可以彼此访问对方所有的字段和方法</li></ol><h6 id="7在类型中嵌入功能"><a class="anchor" href="#7在类型中嵌入功能">#</a> 7. 在类型中嵌入功能</h6><ol><li><mark>聚合</mark> (或组合): 包含一个所需功能类型的具名字段 (需要使用 field.func () 调用对应的聚合方法)</li><li><mark>内嵌</mark>：内嵌 (匿名的) 所需功能类型 (可以直接使用匿名字段方法)</li><li>内嵌类型嵌入其他类型时，那些类型的方法也可以直接在外层类型中使用</li></ol><h6 id="8多重继承"><a class="anchor" href="#8多重继承">#</a> 8. 多重继承</h6><ol><li>多重继承：类型获得多个父类型行为的能力，Go 语言中，通过在类型中嵌入所必要的父类型，可以简单的实现多继承.</li><li>多重继承结构体使用 <code>&amp;struct&#123; field: &quot;&quot; &#125;</code> 进行赋值时要么 全省略字段值，要么全使用字段值</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Base <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	id <span class="token builtin">string</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Base<span class="token punctuation">)</span> <span class="token function">Id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">return</span> b<span class="token punctuation">.</span>id</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Base<span class="token punctuation">)</span> <span class="token function">SetId</span><span class="token punctuation">(</span>id <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	b<span class="token punctuation">.</span>id <span class="token operator">=</span> id</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	Base</pre></td></tr><tr><td data-num="12"></td><td><pre>	firstName <span class="token builtin">string</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	lastName <span class="token builtin">string</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">type</span> Employee <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	Person</pre></td></tr><tr><td data-num="17"></td><td><pre>	salary <span class="token builtin">float32</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">func</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token comment">// 全使用字段名进行对应赋值</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    emp <span class="token operator">:=</span> <span class="token operator">&amp;</span>Employee<span class="token punctuation">&#123;</span>Person<span class="token punctuation">:</span> Person<span class="token punctuation">&#123;</span>Base<span class="token punctuation">:</span> Base<span class="token punctuation">&#123;</span>id<span class="token punctuation">:</span><span class="token string">"101010"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>firstName<span class="token punctuation">:</span> <span class="token string">"black"</span><span class="token punctuation">,</span>lastName<span class="token punctuation">:</span><span class="token string">"cat"</span><span class="token punctuation">&#125;</span> <span class="token punctuation">,</span>salary<span class="token punctuation">:</span> <span class="token number">36.5</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 全省略字段名进行赋值</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	emp <span class="token operator">:=</span> <span class="token operator">&amp;</span>Employee<span class="token punctuation">&#123;</span>Person<span class="token punctuation">&#123;</span>Base<span class="token punctuation">&#123;</span><span class="token string">"1001101"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token string">"white"</span><span class="token punctuation">,</span><span class="token string">"cat"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">6600.5</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span>emp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span>emp<span class="token punctuation">.</span>id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h6 id="9通用方法和方法命名"><a class="anchor" href="#9通用方法和方法命名">#</a> 9. 通用方法和方法命名</h6><ol><li>在编程中 一些基本操作会一遍遍重复出现，例如 == 打开（Open）、关闭（Close）、读（Read）、写（Write）、排序（Sort）== 等等，并且都有一个大致的意思。具体的实现可能前差万别，但是基本的概念是一致的.</li><li>Go 语言中通过使用接口，标准库广泛的应用了这些规则，在标准库中这些方法都有一致的名字，如 <mark>Open(),Read(),write()</mark> 等.</li><li>书写规范的 Go 程序，就应该遵守这些约定，get 方法合适的名字和签名</li></ol><h6 id="10-go语言的方法和其他面向对象语言比较"><a class="anchor" href="#10-go语言的方法和其他面向对象语言比较">#</a> 10. Go 语言的方法和其他面向对象语言比较</h6><ol><li>Go 语言中，类似其他语言的继承层次完全没必要，如果方法在此类型定义了，就可以调用，和其他类型上是否存在这个方法没有关系，因此 Go 在这方面具有更强大的灵活性</li><li>Go 不需要一个显示的类定义，&quot;类&quot; 是通过提供一组作用于一个共同类型的方法集来隐式定义。类型可以是 结构体 或 任何用户自定义类型</li><li>在 Go 中，类型就是类 (数据和关联的方法). Go 没有类似面向对象语言的类继承概念，继承的两个好处：代码重复 和 多态.</li><li>在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时候也称为 <strong>组件编程 (Component Programming)</strong></li><li>相比于类继承，Go 的接口提供了更强大，更简单的多态行为</li><li><code>goop</code> 包，给 Go 提供了 JavaScript 风格的对象 (基于原型的对象), 并且支持多重继承和类型独立分派</li></ol><h4 id="7类型的string方法和格式化描述符"><a class="anchor" href="#7类型的string方法和格式化描述符">#</a> 7. 类型的 String 方法和格式化描述符</h4><ol><li>当定义了一个有很多方法的类型时，大概率会使用 <code>String()</code> 方法来定制类型的字符串形式的输出 (一种可阅读性和打印性的输出).</li><li><code>String()</code> 方法会被用在 <code>fmt.Printf()</code> 中生成默认的输出，等同于使用格式化描述符 % v 产生的输出， <code>fmt.Print()</code> 和 <code>fmt.Println()</code> 也会自动使用 <code>String()</code> 方法</li><li>在 <code>String()</code> 方法中调用涉及 <code>String()</code> 方法的方法会导致无限递归，并很快导致内存溢出，例如 (在 <code>T.String()</code> 中调用 <code>fmt.Sprintf()</code> , 但 <code>fmt.Printf()</code> 又会反过来调用 <code>T.String()</code> ...)</li></ol><h4 id="8垃圾回收和setfinalizer"><a class="anchor" href="#8垃圾回收和setfinalizer">#</a> 8. 垃圾回收和 SetFinalizer</h4><ol><li>Go 开发者不需要写代码来释放程序中不再使用的变量和结构占用的内存</li><li>Go 运行时有一个独立的进程，即垃圾收集器 (GC), 会处理，GC 进程搜索不在使用的变量然后释放其内存，可以通过 <code>runtime</code> 包访问 GC 进程</li><li>通过调用 <code>runtime.GC()</code> 函数可以显示的触发 GC, 但这些之爱子某些罕见的场景下才有用，比如 当内存资源不足时调用 <code>runtime.GC()</code> , 它会在此函数执行的点上立即释放一大片内存，此时程序可能会短暂的性能下降 (因为 GC 进程在执行)</li></ol><p><mark>获取当前的内存状态</mark></p><p>输出当前已分配内存的总量，单位是 KB</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// fmt.Printf("%d\n", runtime.MemStats.Alloc/1024)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 此处代码在 Go 1.5.1 下不再有效，更正为</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">var</span> m runtime<span class="token punctuation">.</span>MemStats</pre></td></tr><tr><td data-num="4"></td><td><pre>runtime<span class="token punctuation">.</span><span class="token function">ReadMemStats</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d Kb\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>Alloc <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h3 id="3接口interface与反射reflection"><a class="anchor" href="#3接口interface与反射reflection">#</a> 3. 接口 (Interface) 与反射 (Reflection)</h3><h4 id="1接口的定义"><a class="anchor" href="#1接口的定义">#</a> 1. 接口的定义</h4><ol><li>Go 语言没有，类和继承的概念，但是有非常灵活的接口概念，通过接口可以实现很多面向对象的特性.</li><li>接口提供了一种方式来说明 对象的行为</li><li>接口的名字通常 由方法名加 <code>[e]r</code> 后缀组成，例如: Printer,Reader,Writer; 当后缀 er 不合适时，如 <code>Recoverable</code> , 接口以 able 结尾，或以 <code>I</code> 开头</li></ol><p><mark>接口定义:</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Namer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">Method1</span><span class="token punctuation">(</span>param_list<span class="token punctuation">)</span> return_type</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">Method2</span><span class="token punctuation">(</span>param_list<span class="token punctuation">)</span> return_type</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>Go 语言中接口可以有值，一个接口类型的变量 或 一个接口值: <code>var ai Namer</code> , <code>ai</code> 是一个多字 (multiword) 数据结构，它的值时 <code>nil</code> . 其本质上是一个指针，虽然不尽相同，<mark>指向接口的指针是非法的</mark>，没有任何作用，还会导致代码错误</li></ul><p><img data-src="https://s3.bmp.ovh/imgs/2021/12/6a6e14e1450de322.png" alt=""></p><ol><li>类型 (比如结构体) 可以实现某个接口的方法集；这个实现可以描述为，该类型的变量上的每一个具体方法所组成的集合，包含了该接口的方法集.</li><li>实现了 <code>Namer</code> 接口的类型变量可以赋值给 <code>ai</code> (即 receiver 的值), 方法表指针 (method table ptr) 就指向了当前的方法实现。当另一个实现了 <code>Namer</code> 接口类型的变量被赋给 <code>ai</code> , <code>receiver</code> 的值和方法表指针也会相应改变</li><li>类型不需要显示声明它实现了某个接口: <mark>接口被隐式的实现</mark>，多个类型可以实现同一个接口</li><li>实现某个接口的类型 (除了实现接口方法外) 可以有其他的方法</li><li><mark>一个类型可以实现多个接口</mark></li><li>接口类型可以包含一个实例的引用，该实例的类型实现了此接口 (<mark>接口是动态类型</mark>).</li></ol><ul><li>结构体 <code>Square</code> 实现了接口 <code>Shaper</code> , 所以可以将一个 <code>Square类型</code> 的变量赋值给 一个接口类型变量: <code>areaIntf = sql</code></li><li>接口变量包含一个指向 <code>Square</code> 变量的引用，通过它可以调用 <code>Square</code> 上的 <code>Area()</code> 方法</li><li><mark>接口变量</mark> 里包含了 <mark>接收者实例的值</mark> 和 <mark>指向对应方法表的指针</mark></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Shaper <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float32</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">type</span> Square <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    side <span class="token builtin">float32</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>sq <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float32</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> sq<span class="token punctuation">.</span>side <span class="token operator">*</span> sq<span class="token punctuation">.</span>side</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    sq1 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Square<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    sq1<span class="token punctuation">.</span>side <span class="token operator">=</span> <span class="token number">5</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">var</span> areaIntf Shaper</pre></td></tr><tr><td data-num="14"></td><td><pre>    areaIntf <span class="token operator">=</span> sq1</pre></td></tr><tr><td data-num="15"></td><td><pre>    </pre></td></tr><tr><td data-num="16"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The square has area: %f\n"</span><span class="token punctuation">,</span> areaIntf<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="2接口嵌套接口"><a class="anchor" href="#2接口嵌套接口">#</a> 2. 接口嵌套接口</h4><ul><li>一个接口可以包含一个或多个其他的接口，相当于将内嵌接口的方法列举在外层接口中一样</li><li>例如 <code>File</code> 包含了 <code>ReadWrite</code> 和 <code>Lock</code> 的所有方法，还额外有一个 <code>Close()</code> 方法</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> ReadWrite <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">Read</span><span class="token punctuation">(</span>b Buffer<span class="token punctuation">)</span> <span class="token builtin">bool</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">Write</span><span class="token punctuation">(</span>b Buffer<span class="token punctuation">)</span> <span class="token builtin">bool</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">type</span> Lock <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">type</span> File <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    ReadWrite</pre></td></tr><tr><td data-num="11"></td><td><pre>    Lock</pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="3类型断言"><a class="anchor" href="#3类型断言">#</a> 3. 类型断言</h4><p><mark>检测和转换接口变量的类型</mark></p><ol><li>一个接口类型的变量 varI 可以包含任何类型的值，必须有一种方式来检测它的 <mark>动态</mark> 类型，运行时在变量中存储的值的实际类型</li><li>在执行过程中动态类型可能会有所不同，但总是可以分配给接口变量本身的类型。通常使用 <mark>类型断言</mark> 来测试，某个时刻 <code>varI</code> 是否包含类型 <code>T</code> 的值.</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>v <span class="token operator">:=</span> varI<span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>		<span class="token comment">//unchecked type assertion</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//var 必须是一个接口变量，否则编译器会报错 :</span></pre></td></tr><tr><td data-num="3"></td><td><pre>invalid <span class="token keyword">type</span> assertion<span class="token punctuation">:</span> varI<span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">(</span>non<span class="token operator">-</span><span class="token keyword">interface</span> <span class="token keyword">type</span> <span class="token punctuation">(</span><span class="token keyword">type</span> of varI<span class="token punctuation">)</span> on left<span class="token punctuation">)</span></pre></td></tr></table></figure><ol start="3"><li>类型断言可能是无效的，编译器会尽力检查转换是否有效，但是不可能遇见所有的可能性.</li><li>转换在程序运行时失败会导致错误法发生，更安全的方式是使用以下形式来进行断言</li></ol><ul><li>转换合法: <code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值， <code>ok</code> 是 <code>true</code></li><li>转换失败: <code>v</code> 是类型 <code>T</code> 的零值， <code>ok</code> 是 <code>false</code> , 也没有运行时错误</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> varI<span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span> <span class="token comment">// checked type assertion</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">Process</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 只测试是否能够成功转换</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> varI<span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    ···</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="4-类型判断"><a class="anchor" href="#4-类型判断">#</a> 4. 类型判断</h4><ol><li>接口变量的类型也是可以使用一种特殊形式的 switch 来检测 : <code>type-switch</code></li></ol><ul><li>t 得到了 <code>areaIntf</code> 的值和类型，所有 <code>case</code> 语句中列举的类型 ( <code>nil</code> 除外) 都必须实现对应的接口</li><li>如果被检测类型没有在 <code>case</code> 列举的类型中，就会执行 <code>default</code> 语句</li><li><code>type-switch</code> 进行运行时类型分析， <code>case</code> 分支中不允许有 <code>fallthrough</code></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">switch</span> t <span class="token operator">:=</span> areaIntf<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">case</span> <span class="token operator">*</span>Square<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Type Square %T with value %v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">case</span> <span class="token operator">*</span>Circle<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Type Circle %T with value %v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"nil value: nothing to check?\n"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">default</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Unexpected type %T\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">/* 输出 */</span> <span class="token punctuation">:</span>  Type Square <span class="token operator">*</span>main<span class="token punctuation">.</span>Square with value <span class="token operator">&amp;</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="2"><li><code>type-switch</code> 处理来自外部的，类型未知的数据时，例如 解析注入 JSON 或 XML 编码的数据，类型测试和转换会非常有用</li><li>如下展示了一个类型分类函数，其拥有一个可变长度参数，可以是任意类型的数组，会根据数组元素的实际类型执行不同的动作:</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">classifier</span><span class="token punctuation">(</span>items <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> x <span class="token operator">:=</span> <span class="token keyword">range</span> items <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">switch</span> x<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">case</span> <span class="token builtin">bool</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Param #%d is a bool\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">case</span> <span class="token builtin">float64</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Param #%d is a float64\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int64</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Param #%d is a int\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Param #%d is a nil\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">case</span> <span class="token builtin">string</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Param #%d is a string\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">default</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Param #%d is unknown\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="5测试一个值是否实现了某个接口"><a class="anchor" href="#5测试一个值是否实现了某个接口">#</a> 5. 测试一个值是否实现了某个接口</h4><ol><li>接口是一种契约，实现类型必须满足它</li><li>编写参数是接口变量的函数，使其更具有一般性</li><li>接口让代码更具有普适性</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 判断 v 是否实现了 Stringer 接口</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> Stringer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span> sv<span class="token punctuation">,</span> ok <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span>Stringer<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"v implements String(): %s\n"</span><span class="token punctuation">,</span>sv<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>	</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="6-方法集与接口"><a class="anchor" href="#6-方法集与接口">#</a> 6. 方法集与接口</h4><ol><li>作用于变量上的方法不区分变量是 指针还是值，但碰到接口类型值时，情况会变得复杂</li><li>接口变量中存储的具体值是不可寻址的，但不使用不当时编译器会给出错误</li><li>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 <code>P</code> 直接辨识的:</li></ol><ul><li>指针方法可以通过指针调用</li><li>指针方法可以通过值使用</li><li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul><ol start="4"><li>Go 语言规范定义了接口方法集的调用规则:</li></ol><ul><li>类型 T 的可调用方法集合包含接受者为 *T 或 T 的所有方法集</li><li>类型 T 的可调用方法集包含接收者为 T 的所有方法</li><li>类型 *T 的可调用方法集不包含接收者为 T 的方法</li></ul><h4 id="7使用-sorter接口排序"><a class="anchor" href="#7使用-sorter接口排序">#</a> 7. 使用 Sorter 接口排序</h4><ol><li>要对一组数字或字符串排序，只需要实现三个方法:</li></ol><ul><li>反映元素个数的 <code>Len()</code></li><li>比较第 <code>i</code> 和 <code>j</code> 个元素的 <code>Less(i,j)</code></li><li>交换第 <code>i</code> 和 <code>j</code> 个元素的 <code>Swap(i,j)</code></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Sort 函数接收一个接口类型的参数: Sorter</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> Sorter <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="2"><li>冒泡排序 <code>Sorter</code> 实现</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">Sort</span><span class="token punctuation">(</span>data Sorter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> pass <span class="token operator">:=</span><span class="token number">1</span><span class="token punctuation">;</span> pass <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pass<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> data<span class="token punctuation">.</span><span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            data<span class="token punctuation">.</span><span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>多种数据类型 基于 Sorter 接口的冒泡排序</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> sort</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> Sorter <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">func</span> <span class="token function">Sort</span><span class="token punctuation">(</span>data Sorter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> pass <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> pass <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pass<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>pass<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> data<span class="token punctuation">.</span><span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                data<span class="token punctuation">.</span><span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">func</span> <span class="token function">IsSorted</span><span class="token punctuation">(</span>data Sorter<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    n <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span> data<span class="token punctuation">.</span><span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">// Convenience types for common cases</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">type</span> IntArray <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p IntArray<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>           <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p IntArray<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p IntArray<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">type</span> StringArray <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p StringArray<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>           <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p StringArray<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p StringArray<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token comment">// Convenience wrappers for common cases</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token keyword">func</span> <span class="token function">SortInts</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>       <span class="token punctuation">&#123;</span> <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token function">IntArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token keyword">func</span> <span class="token function">SortStrings</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">Sort</span><span class="token punctuation">(</span><span class="token function">StringArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token keyword">func</span> <span class="token function">IntsAreSorted</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>       <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">IsSorted</span><span class="token punctuation">(</span><span class="token function">IntArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token keyword">func</span> <span class="token function">StringsAreSorted</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">IsSorted</span><span class="token punctuation">(</span><span class="token function">StringArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="8读和写"><a class="anchor" href="#8读和写">#</a> 8. 读和写</h4><ol><li>读和写是软件中普遍的行为，一般用于 读写文件，缓存 (比如字节或字符串切片), 标准输入输出，标准错误以及网络连接，管道等等，或者 自定义类型。为了让代码尽可能通用，GO 采取了一致的方式来读写数据.</li><li><code>io</code> 包提供了用于读和写的接口 <code>io.Reader</code> 和 <code>io.Writer</code> :</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">type</span> Writer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>只要类型实现了读写接口，提供 <code>Read()</code> 和 <code>Write</code> 方法，就可以从中 读取或写入数据.</li><li>一个<mark>对象是可读的</mark>，必须实现 <code>io.Reader</code> 接口，</li></ol><ul><li>这个接口只有一个签名是 <code>Read(p []byte) (n int,err error)</code> 的方法，</li><li>它从调用它的对象读取数据，并把读取到的数据放入参数的字节切片中，返回读取字节数和一个 <code>error</code> 对象，如果没有发生错误返回 <code>nil</code></li><li>如果已经达到输入的尾端，会返回 <code>io.EOF(&quot;EOF&quot;)</code> , 如果读取过程中发送了错误，就会返回具体的错误信息</li></ul><ol start="5"><li>一个<mark>对象是可写的</mark>，其必须实现 <code>io.worter</code> 接口</li></ol><ul><li>这个接口也只有一个签名是 <code>Write(p []byte) (n int,err error)</code> 的方法</li><li>该方法将指定字节切片中的数据写入调用它的对象中，然后返回实际写入的字节数和一个 <code>error</code> 对象 (如果没有发生错误就是 <code>nil</code> ).</li></ul><ol start="6"><li>io 包中的 Readers 和 Writers 都是不带缓冲的，bufio 包提供了对应的带缓冲的操作，在读写 UTF-8 编码的文本时尤其有用.</li></ol><h4 id="9空接口"><a class="anchor" href="#9空接口">#</a> 9. 空接口</h4><blockquote><p>概念：空接口或者最小接口不包含任何方法，它对实现比作任何要求</p></blockquote><ul><li><p>任何其他类型都实现了空接口，(它不仅仅像 <code>Java/C#</code> 中的 <code>Object</code> 引用类型)</p></li><li><p><code>any</code> 或 <code>Any</code> 是空接口一个很好的别名 或 缩写</p></li><li><p>空接口类似 Java/C# 中所有类的基类: Object 类，二者目标也很接近.</p></li><li><p>可以给一个空接口类型的变量 <code>var val interface &#123;&#125;</code> 赋任何类型的值.</p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Any <span class="token keyword">interface</span><span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><code>val</code> 可依次被赋予一个 <code>int</code> , <code>string</code> 和 <code>Person</code> 实例的值，然后使用 <code>type-switch</code> 来测试它的实际类型。每个 <code>interface&#123;&#125;</code></li><li>变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的 数据或指向数据的指针</li></ul><h6 id="1构建通用类型或者包含不同类型变量的数组"><a class="anchor" href="#1构建通用类型或者包含不同类型变量的数组">#</a> 1. 构建通用类型或者包含不同类型变量的数组</h6><ul><li>给空接口定义一个别名类型 <code>Element</code> :</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Element <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>定义一个容器类型的结构体 <code>Vector</code> , 包含一个 <code>Element</code> 类型元素的切片:</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Vector <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    a <span class="token punctuation">[</span><span class="token punctuation">]</span>Element</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><code>Vector</code> 能放置任何类型的变量，应为任何类型都实现了空接口，实际上 <code>Vector</code> 里放的每个元素都可以是不同类型的变量。为其定义一个 <code>At()</code> 方法用于返回第 <code>i</code> 个元素 :</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Vector<span class="token punctuation">)</span> <span class="token function">At</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> Element <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> p<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>定义一个 <code>Set()</code> 方法用于设置第 <code>i</code> 个元素的值:</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Vector<span class="token punctuation">)</span> <span class="token function">set</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span>e Element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    p<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><code>Vector</code> 中存储的所有元素都是 <code>Element</code> 类型，要得到它们的原始类型 ( <code>unboxing</code> : 拆箱) 需要用到类型断言</li><li>类型断言总是在运行时才执行，因此它会产生运行时错误: <code>The Compiler rejects assertions guaranteed to fail</code></li></ul><h6 id="2复制数据切片至空接口切片"><a class="anchor" href="#2复制数据切片至空接口切片">#</a> 2. 复制数据切片至空接口切片</h6><ul><li>Go 中 无法将 <code>myType</code> 类型的数据切片直接复制到一个 <mark>空接口切片</mark> 中</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* 使用这种方式赋值会引起编译时报错 </pre></td></tr><tr><td data-num="3"></td><td><pre>* cannot use dataSlice (type [] myType) as type [] interface &#123;&#125; in assignment	</pre></td></tr><tr><td data-num="4"></td><td><pre>*/</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">var</span> dataSlice <span class="token punctuation">[</span><span class="token punctuation">]</span>myType <span class="token operator">=</span> <span class="token function">FuncReturnSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">var</span> interfaceSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> dataSlice</pre></td></tr></table></figure><ul><li>空接口切片和 <code>myType</code> 类型的切片在内存中的布局是不一样的，必须使用 <code>for-range</code> 语句来一个个显示赋值</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> dataSlice <span class="token punctuation">[</span><span class="token punctuation">]</span>myType <span class="token operator">=</span> <span class="token function">FuncReturnSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> interfaceSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>dataSlice<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span> i<span class="token punctuation">,</span> d <span class="token operator">:=</span> <span class="token keyword">range</span> dataSlice <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    interfaceSlice<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h6 id="3-反射包"><a class="anchor" href="#3-反射包">#</a> 3. 反射包</h6><ol><li>方法和类型的反射</li></ol><ul><li>通过反射可以分析一个结构体，反射是用程序检查其所拥有的结构，尤其是类型的一种能力；是元编程的一种形式</li><li>反射可以在<mark>运行时检查类型和变量</mark>，例如: <strong>变量的大小，方法 和 动态的调用这些方法</strong></li><li>对于没有源码的包，反射尤其有用，反射是一个强大的工具，除非真得有必要，否则应当避免使用</li><li>变量的最基本信息就是类型和值：反射包的 Type 用来表示一个 Go 类型，反射包的 value 为 Go 值提供了反射接口</li><li><code>reflect.TypeOf</code> 和 <code>reflect.ValueIf</code> , 返回被检查对象的类型和值.</li><li><code>i</code> 的值包含一个 <code>type</code> 和 <code>value</code> , 反射可以从接口值反射到对象，也可以从对象反射回接口值</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* 反射实际上是通过检查一个接口的值，变量首先被转换成空接口</pre></td></tr><tr><td data-num="3"></td><td><pre>*/</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token function">TypeOf</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> Type</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token function">ValueOf</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> Value</pre></td></tr></table></figure><p><mark>reflect 常用方法 :</mark></p><table><thead><tr><th style="text-align:center">方法签名</th><th style="text-align:center">返回值</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">reflect.TypeOf(i interface{}) Type</td><td style="text-align:center">i Type</td><td style="text-align:center">返回被检查对象的类型</td></tr><tr><td style="text-align:center">reflect.ValueOf(i interface{}) Value</td><td style="text-align:center">i Value</td><td style="text-align:center">返回被检查对象的值</td></tr><tr><td style="text-align:center">v:= reflect.ValueOf(x) v.Kind()</td><td style="text-align:center">v type</td><td style="text-align:center">Kind 总是返回底层类型</td></tr><tr><td style="text-align:center">v.Interface()</td><td style="text-align:center">val value</td><td style="text-align:center">(还原) 得到接口的值</td></tr></tbody></table><h6 id="4通过反射修改设置值"><a class="anchor" href="#4通过反射修改设置值">#</a> 4. 通过反射修改 (设置) 值</h6><table><thead><tr><th style="text-align:center">方法签名</th><th style="text-align:center">返回值</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">v.Canset()</td><td style="text-align:center">bool</td><td style="text-align:center">测试 value 是否可设置</td></tr><tr><td style="text-align:center">v := reflect.ValueOf(x)</td><td style="text-align:center">value</td><td style="text-align:center">传递 x 的拷贝创建 v,v 的改变无法影响原始的 x</td></tr><tr><td style="text-align:center">v := reflect.ValueOf(&amp;x)</td><td style="text-align:center">value</td><td style="text-align:center">传递 x 的地址，v 的改变可影响 x</td></tr><tr><td style="text-align:center">func (v Value) Elem() Value</td><td style="text-align:center">value</td><td style="text-align:center">返回 v 持有的接口保管的值的 Value 封装</td></tr><tr><td style="text-align:center">func (v Value) setString(s string)</td><td style="text-align:center">\</td><td style="text-align:center">设置 v 持有值</td></tr></tbody></table><h6 id="5反射结构"><a class="anchor" href="#5反射结构">#</a> 5. 反射结构</h6><ol><li>有些时候需要反射一个结构类型. <code>NumField()</code> 方法返回结构内的字段数量；通过一个 <code>for</code> 循环用索引取得<mark>每个字段的值</mark> <code>Field(i)</code></li><li>通过索引 <code>n</code> 来调用签名在结构体上的方法: <code>Method(n).Call(nil)</code></li><li>如果尝试<mark>修改</mark>结构体中的 <mark>不可导出字段 (首字母小写)</mark>, 会得到一个<mark>错误</mark></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin">panic</span><span class="token punctuation">:</span> reflect<span class="token punctuation">.</span>Value<span class="token punctuation">.</span>SetStringusing value obtained using unexported field</pre></td></tr></table></figure><ol start="4"><li>结构体中<mark>只有被导出字段</mark> (首字母大写)<mark> 才是可设置的</mark>， <code>type.Field(i).Name</code> (得到结构体中第 i 个字段名)</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> T <span class="token keyword">struct</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    A <span class="token builtin">int</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    B <span class="token builtin">string</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    t <span class="token operator">:=</span> T<span class="token punctuation">&#123;</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token string">"skidoo"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    s <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    typeOfT <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">for</span> i <span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        f <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d: %s %s = %v\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            typeOfT<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">,</span> f<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    s<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetInt</span><span class="token punctuation">(</span><span class="token number">77</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    s<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetString</span><span class="token punctuation">(</span><span class="token string">"Sunset Strip"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"t is now"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>输出<span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token number">0</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token number">1</span></pre></td></tr><tr><td data-num="22"></td><td><pre>t is now <span class="token punctuation">&#123;</span><span class="token number">77</span><span class="token punctuation">,</span> SunsetStrip<span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="10printf和反射"><a class="anchor" href="#10printf和反射">#</a> 10.Printf 和反射</h4><p>GO 语言标准库中，反射的功能被大量的使用.fmt 包中的 printf (以及其他格式化输出函数) 都会使用反射来分析它的 ... 参数</p><p><mark>Printf 的函数声明为:</mark></p><ul><li>Printf 中的 ... 参数为空接口类型，</li><li>Printf 使用反射包来解析这个参数列表。所以，Printf 能够知道每个参数的类型</li><li>使用 type-switch 来推导参数类型，并根据类型输出每个参数的值.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">Printf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span>args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="11接口与动态类型"><a class="anchor" href="#11接口与动态类型">#</a> 11. 接口与动态类型</h4><blockquote><p>Go 的动态类型</p></blockquote><ol><li>经典面向对象语言 (c++,Java 和 c#) 中数据和方法被封装为类的概念：类包含两者且不能剥离</li><li>Go 没有类：数据 (结构体或更一般的类型) 和 方法是一种松耦合的正交关系</li><li>Go 中的接口跟 Java/C# 类似：都必须提供一个指定方法集的实现。但更加灵活通用：任何提供了接口方法实现代码的类型都隐式实现了该接口，而不用显示的声明</li><li>Go 是唯一结合了接口值，静态类型检查 (该类型是否实现某个接口), 运行时动态转换的语言，并且不需要显示的声明类型是否满足某个接口.</li><li>接收一个 (或多个) 接口类型作为参数的函数，其实参可以是任何实现了该接口的类型变量。实现了某个接口的类型可以被传递给任何以此接口为参数的函数</li></ol><blockquote><p>动态方法调用</p></blockquote><ol><li>Python,Ruby 这类语言，动态类型是延迟绑定的 (在运行时进行): 方法只是用参数和变量简单的调用，然后运行时才解析 (会产生更大的编码量和更多的测试工作)</li><li>Go 的实现与此相反，通常需要编译器静态检查的支持：当变量被赋值给一个接口类型的变量时，编译器会检查其是否实现了改接口的所有函数.</li><li>如果方法调用作用于像 interface {} 的 &quot;泛型&quot; 上，可以通过类型断言来检查变量是否实现了相应接口</li><li>Go 提供了动态语言的优点，却没有其他语言在运行时可能发送错误的缺点 (可以减少单元测试)</li><li>Go 的接口提高了代码的分离度，改善了代码的复用性，使代码开发中的设计模式更容易实现.Go 接口还能实现<mark>依赖注入模式</mark></li></ol><blockquote><p>接口的提取</p></blockquote><ol><li><mark>提取接口</mark> 是非常有用的设计模式，可以减少需要的类型和方法数量，且不需要像传统的基于类的面向对象语言那样维护整个类的层次结构</li><li>Go 可以让开发者找出自己写的程序中的类型。如果有一些拥有共同行为的对象，并且开发者想要抽象出这些行为，就可以创建一个接口来使用.</li><li>类型想要实现某个接口，本身无需改变，只需要在这个类型上实现新的方法；不用提前设计出所有的接口，<mark> 整个设计可以持续演进，而不用废弃之前的决定</mark>.</li></ol><blockquote><p>显式地指明类型实现了某个接口</p></blockquote><ul><li>希望某个接口的类型显式的声明它们实现了这个接口，可以向方法集中添加一个具有描述性名字的方法.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Fooer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">ImplementsFooer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>类型 <code>Bar</code> 必须实现 <code>ImplementsFooter</code> 方法来满足 <code>Fooer()</code> 接口，以清楚记录这个事实</li><li>大部分代码并不使用这样的约束，因为限制了接口的实用性</li><li>有些时候，这样的约束在大量相似的接口中被用来解决歧义.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Bar <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>b Bar<span class="token punctuation">)</span> <span class="token function">ImplementsFooer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>b Bar<span class="token punctuation">)</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>空接口和函数重载</p></blockquote><ul><li>Go 语言中函数重载可以用可变参数 ...T 作为函数最后一个参数来实现。如果将 T 换为空接口，那么任何变量都是满足 T (空接口) 类型的，这样就允许传递任何数量任何类型的参数给函数，即重载的实际含义</li><li>函数 <code>fmt.Printf</code> 通过枚举 <code>slice</code> 类型的实参动态确定所有参数的类型。并查看每个类型是否实现了 <code>String()</code> 方法</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 函数 fmt.Printf 就是这样实现的</span></pre></td></tr><tr><td data-num="2"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span>a <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span>errno <span class="token builtin">error</span><span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>接口的继承</p></blockquote><ul><li>当一个类型包含 (内嵌) 另一个类型 (实现了一个或多个接口) 的指针时，这个类型就可以使用 (另一个类型) 所有与的接口方法.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Task <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    Command <span class="token builtin">string</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><code>task</code> 的工厂方法</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">NewTask</span><span class="token punctuation">(</span>command <span class="token builtin">string</span><span class="token punctuation">,</span>logger <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger<span class="token punctuation">)</span> <span class="token operator">*</span>Task <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>Task<span class="token punctuation">&#123;</span>command<span class="token punctuation">,</span> logger<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>当 log.Logger 实现了 Log () 方法后，Task 的实例 task 就可以调用该方法:</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>task<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>类型可以通过继承多个接口来提供像 <code>多继承</code> 一样的特性:</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> ReaderWriter <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">*</span>io<span class="token punctuation">.</span>Reader</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token operator">*</span>io<span class="token punctuation">.</span>Writer</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>以上原理被应用于整个 Go 包，多态用得越多，代码就相对越少。这被认为是 Go 编程中的重要的最佳实践</li><li>有用的接口可以在开发的过程中被归纳出来。添加新接口非常容易，因为已有的类型不用变动 (仅仅需要实现新接口的方法).</li><li>已有的函数可以拓展为使用接口类型的约束性参数：通常只有函数签名需要改变。对比于基类的 oo 类型的语言在这种情况下则需要适用整个类型层次结构的变化</li></ul><h4 id="12go中的面向对象"><a class="anchor" href="#12go中的面向对象">#</a> 12.Go 中的面向对象</h4><p><mark>Go 没有类，而是松耦合的类型，方法对接口的实现.</mark></p><ol><li>封装 (数据隐藏): Go 将其他 oo 语言的多个访问层次简化为 2 层:</li></ol><ul><li>包的范围：通过表示符首字母小写，对象 <mark>只在自己所在的包内可见</mark></li><li>可导出的：通过标识符首字母大写，对象 <mark>对所在包以外的也可见</mark></li></ul><ol start="2"><li>继承：用组合实现：内嵌一个 (或多个) 包含想要的行为 (字段和方法) 的类型；多重继承可通过内嵌多个类型实现</li><li>多态：用接口实现：某个类型的实例可以赋给其所实现的任意接口类型的变量。类和接口是松耦合的，并且多继承可以通过实现多个接口实现.</li><li>GO 接口间是不相关的，且是大规模变成和可适应的演进类型设计的关键.</li></ol><h3 id="4读写数据"><a class="anchor" href="#4读写数据">#</a> 4. 读写数据</h3><h4 id="1读取用户的输入"><a class="anchor" href="#1读取用户的输入">#</a> 1. 读取用户的输入</h4><p>Go 语言获取用户的键盘 (控制台) 输入，从键盘和标准输入 <code>os.Stdin</code> 读取输入，最简单的办法是使用 fmt 包提供的 <code>Scan</code> 和 <code>Sscan</code> 开头的函数.</p><ol><li>fmt 包下的 scan 系列方法，扫描来自标准输入的文本或字符，将空格分隔的值依次存放到后续的参数内.(<mark>传递参数地址接收</mark>)</li></ol><table><thead><tr><th style="text-align:left">方法签名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">func <code>Scanf</code> (format string,a ...interface{}) (n int,err error)</td><td style="text-align:left">根据 format 将读取值赋予函数参数</td></tr><tr><td style="text-align:left">func <code>Fscanf</code> (r io.Reader,format string.a ...interface{}) (n int,err error)</td><td style="text-align:left">从 r 扫描文本，根据 format 格式化值赋予参数</td></tr><tr><td style="text-align:left">func <code>Sscanf</code> (str string, format string, a ...interface{}) (n int, err error)</td><td style="text-align:left">扫描 str 根据 format 格式化值赋予参数</td></tr><tr><td style="text-align:left">func <code>Scan</code> (a ...interface{}) (n int,err error)</td><td style="text-align:left">扫描标准输入文本，读取以空格分隔的值赋予参数</td></tr><tr><td style="text-align:left">func <code>Fscan</code> (r io.Reader,a ...interface{}) (n int,err error)</td><td style="text-align:left">扫描 str 将成功读取的空白分隔值保存至参数。读取值少于参数值，则返回错误</td></tr><tr><td style="text-align:left">func <code>Sscan</code> (str string,a ...interface{}) (n int,err error)</td><td style="text-align:left">扫描 str, 读取空白分隔值保存到参数，换行视为空白，读取值少于参数报错</td></tr><tr><td style="text-align:left">func <code>Sscanln</code> (a ...interface{}) (n int,err error)</td><td style="text-align:left">类似 scan, 遇到换行才会停止，最后条目必须有换行或者达到结束位置</td></tr><tr><td style="text-align:left">func <code>Fscanln</code> (r io.Reader,a ...interface{}) (n int,err error)</td><td style="text-align:left">类似 Fscan, 遇到换行停止扫描，终止位置必须有换行或者到达结束位置</td></tr><tr><td style="text-align:left">func <code>Sscanln</code> (str string,a ...interface{}) (n int,err error)</td><td style="text-align:left">类似 Sscan, 换行时才停止扫描，终止位置必须有换行或者到达结束位置</td></tr></tbody></table><ol start="2"><li><code>bufio</code> 包提供缓冲读取 (buffered reader) 来读取数据</li></ol><ul><li><p><code>inputReader</code> 是一个指向 <code>bufio.Reader</code> 的指针. <code>inputReader := bufo.NewReader(os.Stdin)</code> 会创建一个读取器，并将其与标准输入绑定.</p></li><li><p><code>bufio.NewReader()</code> 构造函数的签名为: <code>func NewReader(rd io.Reader) *Reader</code></p><ul><li>函数的实参可以是满足 <code>io.Reader</code> 接口的任意对象 (任意包含有适当的 <code>Read()</code> 方法的对象)</li><li>函数返回一个新的带缓冲的 <code>io.Reader</code> 对象，将从指定读取机器 (例如 <code>os.Stdin</code> ) 读取内容</li><li>返回的读取器对象提供一个方法 <code>ReadString(delim byte)</code> , 该方法从输入中读取内容，直到碰到 delim 指定的字符，然后将读取到的内容连同 <code>delim</code> 字符一起放到缓冲区</li></ul></li><li><p><code>ReadString</code> 返回读取到的字符串，如果碰到错误则返回 <code>nil</code> , 如果一直读取到文件结束，则返回读取到的字符串和 <code>io.EOF</code> 如果读取过程中没有遇到 <code>delim</code> 字符，将返回错误 <code>err != nil</code></p></li><li><p>屏幕是标准输出 <code>os.Stdout</code> , <code>os.Stderr</code> 用于显示错误信息，大多数情况下等同于 <code>os.Stdout</code></p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>inputReader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>input<span class="token punctuation">,</span> err <span class="token operator">:=</span> inputReader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p><mark>缓冲读取:</mark></p><table><thead><tr><th>函数签名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>func <code>NewReader</code> (rd io.Reader) *Reader</td><td style="text-align:center">创建默认大小缓冲，从 r 读取的 * Reader</td></tr><tr><td>func <code>NewReaderSize</code> (rd io.Reader,size int) *Reader</td><td style="text-align:center">创建 size 尺寸的缓冲，从 r 读取 * Reader</td></tr><tr><td>func (b *Reader) <code>Reset</code> (r io.Reader)</td><td style="text-align:center">丢弃缓冲中的数据，清除错误，将 b 设为下层，从 r 读取数据</td></tr><tr><td>func (b *Reader) <code>Buffered</code> () int</td><td style="text-align:center">返回缓冲中现有的可读取的字节数</td></tr><tr><td>func (b *Reader) <code>Peek</code> (n int) ([]byte, error)</td><td style="text-align:center">返回下 n 个字节，不会移动位置</td></tr><tr><td>func (b *Reader) <code>Read</code> (p []byte) (n int,err error)</td><td style="text-align:center">返回写入 p 的字节数。读取到结尾时 n=0,err=io.EOF</td></tr><tr><td>func (b *Reader) <code>ReadByte</code> (c byte,err error)</td><td style="text-align:center">读取并返回一个字节，没有可用数据返回错误</td></tr><tr><td>func (b *Reader) <code>UnreadByte</code> () error</td><td style="text-align:center">吐出读取的最后一个字节.(多次调用会报错)</td></tr><tr><td>func (b *Reader) <code>ReadRune</code> () (r rune,size int,err error)</td><td style="text-align:center">读取一个 unicode 码，返回码值，长度</td></tr><tr><td>func (b *Reader) <code>UnreadRune</code> () error</td><td style="text-align:center">吐出最近一次 ReadRune 读取的 Unicode 码值</td></tr><tr><td>func (b *Reader) <code>ReadLine</code> (line []byte,isPrefix bool,err error)</td><td style="text-align:center">返回一行数据，不包括行尾标志的字节</td></tr><tr><td>func (b *Reader) <code>ReadSlice</code> (delim byte) (line []byte,err error)</td><td style="text-align:center">读取直到第一次遇到 delim 字节，返回已读取的字节切片</td></tr><tr><td>func (b *Reader) <code>ReadBytes</code> (delim byte) (line []byte,err error)</td><td style="text-align:center">读取直到第一次遇到 delim 字节，返回已读取的字节切片</td></tr><tr><td>func (b *Reader) <code>ReadString</code> (delim byte) (line string,err error)</td><td style="text-align:center">读取直到第一次遇到 delim 字节，返回已读取的字节的字符串</td></tr><tr><td>func (b *Reader) <code>WriteTo</code> (w io.Writer) (n int64,err error)</td><td style="text-align:center">实现了 io.Writer 接口</td></tr></tbody></table><h4 id="2文件读写"><a class="anchor" href="#2文件读写">#</a> 2. 文件读写</h4><h6 id="1-读文件"><a class="anchor" href="#1-读文件">#</a> 1. 读文件</h6><ol><li>Go 语言中，文件使用指向 os.File 类型的指针来表示，也叫做文件句柄，标准输入 <code>os.Stdin</code> 和 标注输出 <code>os.Stdout</code> 的类型都是 <code>*os.File</code></li></ol><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">os.Stdin</td><td style="text-align:center">指向标准输入</td></tr><tr><td style="text-align:center">os.Stdout</td><td style="text-align:center">指向标准输出</td></tr><tr><td style="text-align:center">os.Stderr</td><td style="text-align:center">指向标准错误</td></tr></tbody></table><ol start="2"><li><p>变量 <code>inputFile</code> 是 <code>*os.File</code> 类型的。该类型是一个结构，表示一个打开文件的描述符 (文件句柄). 使用 <code>os</code> 包中的 <code>Open</code> 函数来打开文件，函数的参数是文件名，类型为 <code>string</code> . 下面程序中是以只读模式打开 <code>input.dat</code> 文件.</p><ul><li><p>文件不存在，或者程序没有足够的权限打开文件，Open 函数会返回一个错误: <code>inputFile, inputError = os.Open(&quot;input.dat&quot;)</code></p></li><li><p>文件正常打开，使用 <code>defer inputFile.Close()</code> 语句确保在程序退出前关闭该文件。使用 <code>bufio.NewReader</code> 获取读取器变量.</p></li><li><p>通过使用 <code>bufio</code> 包提供的读取器 (写入器类似), 可以方便的操作相对高层的 <code>string</code> 对象，避免操作者底层的字节</p></li><li><p>在无限循环中使用 <code>ReadString('\n')</code> 或 <code>ReadBytes('\n')</code> 将文件内容逐行读取出来</p></li><li><p><code>Unix</code> 和 <code>Linux</code> 的行结束符是 <code>\n</code> , 而 <code>Windows</code> 的行结束符是 <code>\r\n</code> . 在使用 <code>ReadString</code> 和 <code>ReadBytes</code> 方法的时候，无需关心操作系统的类型，直接使用 <code>\n</code> 即可，亦可使用 <code>ReadLine()</code> 方法来实现相同的功能</p></li><li><p>读取到文件末尾，变量 readerError 的值将变成非空 (其值常量为 <code>io.EOF</code> ) 就会执行 return 语句退出循环</p></li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    inputFile<span class="token punctuation">,</span> inputError <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"input.dat"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> inputError <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"An error occurred on opening the inputfile\n"</span> <span class="token operator">+</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token string">"Does the file exist?\n"</span> <span class="token operator">+</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token string">"Have you got acces to it?\n"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token comment">// exit the function on error</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">defer</span> inputFile<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    inputReader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        inputString<span class="token punctuation">,</span> readerError <span class="token operator">:=</span> inputReader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The input was: %s"</span><span class="token punctuation">,</span> inputString<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> readerError <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">return</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span>      </pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>将整个文件的内容读取到一个字符串里 :<ul><li><code>io/ioutil</code> 包里的 <code>ioutil.ReadFile()</code> 方法，</li><li>该方法第一个返回值的类型是 <code>[]byte</code> , 里面存放读取到的内容，</li><li>第二个返回值是错误，如果没有错误发生，第二个值为 <code>nil</code> . 函数 <code>WriteFile()</code> 可以将 <code>[]byte</code> 值写入文件</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    inputFile <span class="token operator">:=</span> <span class="token string">"products.txt"</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    outputFile <span class="token operator">:=</span> <span class="token string">"products_copy.txt"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    buf<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>inputFile<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"File Error: %s\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// panic(err.Error())</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    err <span class="token operator">=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span> <span class="token comment">// oct, not hex</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="4"><li>带缓冲的读取<ul><li>多数情况下，文件的内容是不按行划分的，或者是一个二进制文件. ReadString () 就无法使用了，可以使用 bufio.Reader 的 Read (), 只接收一个参数:</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//n 表示读取到的字节数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> inputReader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="5"><li><p>按列读取文件的数据</p><ul><li>如果文件是按列并用空格分割的，可以使用 fmt 包提供的以 FScan 开头的一系列函数来读取.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"products2.txt"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">var</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> col3 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">var</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3 <span class="token builtin">string</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Fscanln</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v3<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// scans until newline</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">break</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        col1 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>col1<span class="token punctuation">,</span> v1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        col2 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>col2<span class="token punctuation">,</span> v2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        col3 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>col3<span class="token punctuation">,</span> v3<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>col1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>col2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>col3<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><code>path</code> 包中包含一个子包 <code>filepath</code> , 这个子包提供了跨平台的函数，用于处理文件名和路径.</li><li>例如: <code>Base()</code> 函数用于获取路径中的最后一个元素 (不包含后面的分隔符)</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token string">"path/filepath"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>filename <span class="token operator">:=</span> filepath<span class="token punctuation">.</span><span class="token function">Base</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p><code>compress</code> 包提供了，读取压缩文件的功能，支持的压缩文件格式为: bzip, flate, gzip, lzw 和 zlib.</p></li></ol><h6 id="2-写文件"><a class="anchor" href="#2-写文件">#</a> 2. 写文件</h6><ol><li><p>除了文件句柄，还需要 <code>bufio</code> 的 <code>writer</code> .</p><ul><li>以只读模式打开文件 <code>output.dat</code> , 文件不存在则自动创建</li><li><code>OpenFile</code> 函数有三个参数：文件名，一个或多个标志 (使用逻辑运算符 &quot;|&quot; 连接), 使用的文件权限</li><li><code>os.O_RDONLY</code> : 只读</li><li><code>os.O_WRONLY</code> : 只写</li><li><code>os.O_CREATE</code> : 创建，如果指定文件不存在，就创建该文件.</li><li><code>os.O_TRUNC</code> : 截断，如果指定文件已存在，就该文件长度截为 0</li><li>读文件时，文件的权限是被忽略的，所以使用 <code>OpenFile</code> 时传入的第三个参数可以用 0.</li><li>写文件时，不论是 <code>Unix</code> 还是 <code>Windowx</code> 都需要使用 0666</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>outputFile<span class="token punctuation">,</span> outputError <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"output.dat"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_WRONLY<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 创建一个写入器 (缓冲区) 对象 </span></pre></td></tr><tr><td data-num="3"></td><td><pre>outputWriter <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 将字符写入缓冲区</span></pre></td></tr><tr><td data-num="5"></td><td><pre>outputWriter<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>outputString<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 缓冲区的内容完全写入文件</span></pre></td></tr><tr><td data-num="7"></td><td><pre>outputWriter<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="9"></td><td><pre>* 写入简单内容时，使用 fmt.Fprintf 直接将内容写入文件</pre></td></tr><tr><td data-num="10"></td><td><pre>* fmt 包中 F 开头的 Print 函数可以直接写入任何 io.Writer, 包括文件</pre></td></tr><tr><td data-num="11"></td><td><pre>*/</pre></td></tr><tr><td data-num="12"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>outputFile<span class="token punctuation">,</span> <span class="token string">"Some test data.\n"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li><code>os.Stdout.WriteString(&quot;hello, world\n&quot;)</code> 输出内容到屏幕</li><li><code>f, _ := os.OpenFile(&quot;test&quot;,os.O_CREATE|os.O_WRONLY,0666)</code> 以只写模式创建或打开文件</li><li><code>f.WriteString()</code> 不使用缓冲区，直接将内容写入文件</li></ul></li><li><p>文件拷贝</p></li></ol><ul><li>拷贝一个文件到另一个文件，最简单的方式就是使用 io 包</li><li>defer , 当打开文件时发送错误， <code>defer</code> 仍然能够确保 <code>src.Close()</code> 执行，如果不关闭 src 文件会一直保持打开占用资源</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token function">CopyFile</span><span class="token punctuation">(</span><span class="token string">"copy"</span><span class="token punctuation">,</span><span class="token string">"17.jpg"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Copy done!"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">CopyFile</span><span class="token punctuation">(</span>dstName<span class="token punctuation">,</span> srcName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	src<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>srcName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>		<span class="token keyword">return</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">defer</span> src<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>	dst<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>dstName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		<span class="token keyword">return</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token keyword">defer</span> dst<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">return</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span>src<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="3从命令行读取参数"><a class="anchor" href="#3从命令行读取参数">#</a> 3. 从命令行读取参数</h4><ol><li>os 包中有一个 string 类型的切片变量 <code>os.Args</code> , 用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数<ul><li>命令行参数会放置在切片 os.Args [] 中 (以空格分隔), 从索引 1 开始 ( <code>os.Args[0]</code> 放的是程序本身的名字)</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	who <span class="token operator">:=</span> <span class="token string">"Alice "</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>		who <span class="token operator">+=</span> strings<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">" "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Good Morning"</span><span class="token punctuation">,</span>who<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="2"><li>flag 包中有一个扩展功能来解析命令行选项，但是通常被用来替换基本常量，例如，某些情况下给常量一些不一样的值</li></ol><p><code>flag</code> 包中有一个 <code>Flag</code> 被定义成含有如下字段的结构体:</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>typr Flag <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    Name 	<span class="token builtin">string</span>			<span class="token comment">// name as it appears on command line</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Usage	<span class="token builtin">string</span>			<span class="token comment">// help message</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    Value	Value			<span class="token comment">// value as set</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    DefValue	<span class="token builtin">string</span>		<span class="token comment">// default value (as text); for usage message</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>模拟 <code>Unix</code> 的 <code>echo</code> 功能</p><ul><li><code>flag.Parse()</code> 扫描参数列表 并设置 <code>flag</code> ,</li><li><code>flag.Arg(i)</code> , 表示第 i 个参数. <code>Parse()</code> 之后 <code>flag.Arg(i)</code> 全部可用， <code>flag.Arg(0)</code> 就是第一个真实的 <code>flag</code></li><li><code>flag.Narg()</code> 返回参数的数量。解析后 flag 或常量就可以使用</li><li><code>flag.PrintDefaults()</code> 打印 flag 的使用帮助信息</li><li><code>flag.VisitAll(fn func(*Flag))</code> : 按照字典顺序遍历 <code>flag</code> , 并对每个标签调用 <code>fn</code></li><li><code>flag</code> 定义类型 : <code>flag.Bool()</code> , <code>flag.Int()</code> , <code>flag.Float64</code> , <code>flag.String()</code></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> NewLine <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">Bool</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"print newline"</span><span class="token punctuation">)</span> <span class="token comment">// echo -n flag, of type *bool</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Space   <span class="token operator">=</span> <span class="token string">" "</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    Newline <span class="token operator">=</span> <span class="token string">"\n"</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    flag<span class="token punctuation">.</span><span class="token function">PrintDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Scans the arg list and sets up flags</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">var</span> s <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">""</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            s <span class="token operator">+=</span> <span class="token string">" "</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token operator">*</span>NewLine <span class="token punctuation">&#123;</span> <span class="token comment">// -n is parsed, flag becomes true</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                s <span class="token operator">+=</span> Newline</pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        s <span class="token operator">+=</span> flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    os<span class="token punctuation">.</span>Stdout<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="4-buffer-读取文件"><a class="anchor" href="#4-buffer-读取文件">#</a> 4. buffer 读取文件</h4><p>结合使用缓冲读取文件和命令行 flag 解析，输出内容</p><ul><li>不添加参数时，cmd 输入什么就输出什么</li><li>参数是文件名时，如果文件存在就打印文件内容到屏幕，</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">cat</span><span class="token punctuation">(</span>r <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        buf<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">break</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">func</span> <span class="token function">bufRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">cat</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"%s:error reading from %s: %s\n"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">continue</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token function">cat</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="5-切片读写文件"><a class="anchor" href="#5-切片读写文件">#</a> 5. 切片读写文件</h4><p>切片提供了 Go 中处理 I/O 缓冲的标准方式，</p><p>如下 cat 函数中，在一个切片缓冲内使用无限 for 循环 (直到文件尾部 EOF) 读取文件，并写入到标准输出 ( <code>os.Stdout</code> )</p><figure class="highlight go"><figcaption data-lang="go"><span>o</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">cat</span><span class="token punctuation">(</span>f <span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">const</span> NBUF <span class="token operator">=</span> <span class="token number">512</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">var</span> buf <span class="token punctuation">[</span>NBUF<span class="token punctuation">]</span><span class="token builtin">byte</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">switch</span> nr<span class="token punctuation">,</span>err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">case</span> nr <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>            	fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span><span class="token string">"cat: error reading: %s\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            	os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">case</span> nr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment">//EOF</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            	<span class="token keyword">return</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">case</span> nr <span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> nw<span class="token punctuation">,</span> ew <span class="token operator">:=</span> os<span class="token punctuation">.</span>Stdout<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>nr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> nw <span class="token operator">!=</span> nr <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span><span class="token string">"cat: error writing: %s\n"</span><span class="token punctuation">,</span>ew<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="6-defer-关闭文件"><a class="anchor" href="#6-defer-关闭文件">#</a> 6. defer 关闭文件</h4><p><code>defer</code> 关键字，对于函数结束时关闭打开的文件非常有用 :</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 在函数 return 后执行 f.Close () 关闭打开的文件</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">data</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_RDONLY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//return 后关闭文件</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    centos<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>contents<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="7-接口使用实际案例-fmtfprintf"><a class="anchor" href="#7-接口使用实际案例-fmtfprintf">#</a> 7. 接口使用实际案例: fmt.Fprintf</h4><p>程序 io_interfaces.go 阐述了 io 包的接口概念</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// unbuffered</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token string">"hello world! - unbuffered"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// buffered: os.Stdout implements io.Writer</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    buf <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// and now so does buf.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token string">"hello world! - buffered"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    buf<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//Flush 方法将缓冲中的数据写入下层的 io.Writer 接口。</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>fmt.Fprintf()</code> 函数的实际签名 :</p><ul><li><code>fmt.Fprintf()</code> 依据指定的格式向第一个参数内写入字符串，参数一必须实现了 <code>io.Writer</code> 接口</li><li><code>Fprintf()</code> 能够写入任何类型，只要其实现了 <code>write</code> 方法，包括 <code>os.Stdout</code> , 文件 (如: os.File), 管道，网络，连接，通道等等.</li><li>同样也可以使用 <code>bufio</code> 包中缓冲写入. <code>bufio</code> 包中定义了 <code>type Writer struct&#123;...&#125;</code></li><li>工厂函数 <code>func NewWriter(wr io.Writer) (b *Writer)</code> : 传递一个 <code>io.Writer</code> 类型参数，返回一个带缓冲的</li><li>其适合任何形式的缓冲读写，缓冲读写最后要使用 <code>Flush()</code> , 否则最后的输出不会被写入</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">Fprintf</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> format <span class="token builtin">string</span><span class="token punctuation">,</span> a <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 其参数不是写入一个文件，而是写入一个 io.Writer 接口类型的变量</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">type</span> Writer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">//bufio.Writer 实现了 Write 方法:</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Writer<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nn <span class="token builtin">int</span><span class="token punctuation">,</span>err <span class="token builtin">error</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="8-json数据格式"><a class="anchor" href="#8-json数据格式">#</a> 8. JSON 数据格式</h4><ol><li><p>数据结构要在网络中传输或保存到文件，就必须对其编码和解码；目前存在多种编码格式: JSON,XML,gob,Goole 缓冲协议，等等.Go 语言支持这些所有的编码格式</p></li><li><p>结构可能包含二进制数据，如果将其作为文本打印，可读性很差，结构内部可能包含匿名字段，而不清楚数据的用意.</p></li><li><p>通过把数据转换成纯文本，使用命名的字段来标注，让其具有可读性。这样的数据可以通过网络传输，而且与平台无关，任何类型的应用都能够读取和输出，不与操作系统和编程语言的类型相关.</p></li><li><p>序列化是在内存中把数据转换成指定格式 (data -&gt; string), 反之亦然 (string -&gt; data structure)</p></li><li><p>编码是输出一个数据流 (实现了 <code>io.Writer</code> 接口); 解码是从一个数据流 (实现了 io.Reader) 输出到一个数据结构.</p><ul><li>数据结构 --&gt; 指定格式 = <code>序列化</code> 或 <code>编码</code> (传输之前)</li><li>指定格式 --&gt; 数据格式 = <code>反序列化</code> 或 <code>解码</code> (传输之后)</li></ul></li><li><p>XML 被广泛的应用，但是 JSON 更加简洁、轻量 (占用更少的内存、磁盘及网络带宽) 和更好的可读性</p></li></ol><p><mark>encoding/json</mark></p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:left">func <code>NewEncoder</code> (w io.Writer) *Encoder</td><td style="text-align:center">创建一个将数据写入 w 的 * Encoder</td></tr><tr><td style="text-align:left">func <code>Marshal</code> (v interface{}) ([]byte, error)</td><td style="text-align:center">返回 v 的 json 编码</td></tr></tbody></table><ol start="6"><li><p>JSON 与 Go 类型对应如下:</p><ul><li>bool 对应 Json 的 boolean</li><li>float64 对应 JSON 的 Number</li><li>string 对应 JSON 的 string</li><li>nil 对应 JSON 的 null</li></ul></li><li><p>不是所有的数据都可以编码为 JSON 类型，只有验证通过的数据结构才能被编码:</p><ul><li>JSON 对象只支持字符串类型的 Key; 编码 Go map 类型，map 必须是 map [string] T (T 是 json 包中支持的任何类型)</li><li>Channel, 复杂类型和函数类型不能被编码</li><li>不支持循环数据结构；会引起序列化进入一个无限循环</li><li>指针可以被编码，实际上是对指针指向的值进行编码 (或者指针是 nil)</li></ul></li><li><p>反序列化</p><ul><li><p><code>func Unmarshal(data []byte,v interface&#123;&#125;) error</code> 把 <code>JSON</code> 解码为数据结构</p></li><li><p>对 <code>JSON</code> 数据进行解码时，首先创建结构体用来保存解码的数据:</p><p><code>var v struct 并调用 json.Unmarshal(jsonData,&amp;v)</code></p></li><li><p>解析 <code>[]byte</code> 中的 <code>JSON</code> 数据并将结果存入指针 &amp;v 指向的地址</p></li><li><p>虽然反射能够让 JSON 字段尝试匹配目标结构字段；但是只有真正匹配上次啊会填充数据，没有匹配到直接忽略</p></li></ul></li><li><p>解码任意数据</p><ul><li><code>json</code> 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface</code> 存储任意的 <code>JSON</code> 对象和数组；其可以被反序列化为任何的 <code>JSON blob</code> 存储到接口值中</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 将 JSON 数据存储在变量 b 中</span></pre></td></tr><tr><td data-num="2"></td><td><pre>b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">`&#123;"Name": "Wednesday", "Age": 6, "Parents": ["Gomez", "Morticia"]&#125;`</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 无需了解这个数据结构，可以直接使用 Unmarshal 将数据保存在接口值中</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">var</span> f <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>err <span class="token operator">:=</span> json<span class="token punctuation">.</span>Unmarshal<span class="token punctuation">&#123;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>f<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">//f 指向的是一个 map,key 是一个字符串，value 是自身存储作为空接口类型的值</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token string">"Name"</span><span class="token punctuation">:</span> <span class="token string">"Wednesday"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token string">"Age"</span><span class="token punctuation">:</span>  <span class="token number">6</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token string">"Parents"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token string">"Gomez"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token string">"Morticia"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 访问这个数据可以使用类型断言</span></pre></td></tr><tr><td data-num="16"></td><td><pre>m <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="18"></td><td><pre>* 通过 for range 语法和 typeswitch 来访问其实际类型</pre></td></tr><tr><td data-num="19"></td><td><pre>* 通过这种方式，可以处理位置的 JOSN 数据，同时确保类型安全</pre></td></tr><tr><td data-num="20"></td><td><pre>*/ </pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">switch</span> vv <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">case</span> <span class="token builtin">string</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token string">"is string"</span><span class="token punctuation">,</span> vv<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token string">"is int"</span><span class="token punctuation">,</span> vv<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">case</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token string">"is an array:"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> u <span class="token operator">:=</span> <span class="token keyword">range</span> vv <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> u<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">default</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token string">"is of a type I don’t know how to handle"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>如果事先已知 JSON 数据类型，可以定义一个适当的结构并对 JSON 数据反序列化.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义接收数据的结构体</span></pre></td></tr><tr><td data-num="2"></td><td><pre>typr FamilyMember <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Name <span class="token builtin">string</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    Age <span class="token builtin">int</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    Parents <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 反序列化 JSON 数据</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">var</span> m FamilyMember</pre></td></tr><tr><td data-num="9"></td><td><pre>err <span class="token operator">:=</span> josn<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span></pre></td></tr></table></figure></li><li><p>编码和解码流</p></li></ol><ul><li><code>json</code> 包提供 <code>Decoder</code> 和 <code>Encoder</code> 类型来支持常用 JSON 数据流读写. <code>NewDecoder</code> 和 <code>NewEncoder</code> 函数分别封装了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">NewDecoder</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token operator">*</span>Decoder</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">NewEncoder</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token operator">*</span>Encoder</pre></td></tr></table></figure><ul><li>将 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件 (或者任何实现 io.Writer 的类型), 并调用 Encode (); 与之相应的是使用 json.NewDecoder 和 Decode () 函数</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">NewDecoder</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token operator">*</span>Decoder</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>dec <span class="token operator">*</span>Decoder<span class="token punctuation">)</span> <span class="token function">Decode</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="9xml数据格式"><a class="anchor" href="#9xml数据格式">#</a> 9.XML 数据格式</h4><ul><li>如同 JSON 包一样，XML 也有 <code>Marshal()</code> 和 <code>UnMarshal()</code> 从 XML 中编码和解码数据；但其可以从文件中读取和写入</li><li>同 JSON 的方式一样，XML 数据也可以序列化为结构，或者从结构反序列化为 XML 数据</li><li>xml 包定义了若干 XML 标签类型: StartElement, Chardata (从开始标签到结束标签之间的文本),EndElement, Comment, Directive 或 Proclnst</li><li>xml 包中同样定义了一个结构解析器: <code>NewParser</code> 方法持有一个 <code>io.Reader</code> 并生成一个解析器对象，还有一个 <code>Token()</code> 方法返回输入流的下一个 <code>XML token</code> . 在输入流结尾处会返回 <code>(nil, io.EOF)</code></li><li>XML 文本被循环处理直到 <code>Token()</code> 返回一个错误，因为到达文件尾部，通过 <code>type-switch</code> 可以根据 XML 标签进一步处理. <code>Chardata</code> 中的内容是一个 <code>[]byte</code> , 通过字符串转换让其可读性变得更强</li></ul><h4 id="10gob传输数据"><a class="anchor" href="#10gob传输数据">#</a> 10.Gob 传输数据</h4><ul><li>Gob 是 Go 以二进制形式序列化和反序列化程序数据的格式</li><li>Gob 特定地用于纯 Go 的环境中，两个用 GO 写的服务器之间通信更加高效和优化</li><li>Gob 只有可导出的字段会被编码，零值会被忽略。在解码结构体是，只有同时匹配名称和可兼容型的字段才会被解码</li></ul><h4 id="11go-数据加密"><a class="anchor" href="#11go-数据加密">#</a> 11.Go 数据加密</h4><ul><li>网络传输的数据必须加密，防止被 hacker (黑客) 读取或篡改，并且保证发出的数据和接收到的数据校验和一致.</li><li><code>has</code> 包：实现了 <code>adler32</code> , <code>crc32</code> , <code>crc64</code> 和 <code>fnv</code> 校验；</li><li><code>crypto</code> 包：实现了其它 <code>hash</code> 算法，例如 <code>md4</code> , <code>md5</code> , <code>sha1</code> 等。以及完整实现 <code>aes</code> , <code>blowfish</code> , <code>rc4</code> , <code>rsa</code> , <code>xtea</code> 等加密算法.</li><li>通过调用 <code>sha1.New()</code> 创建了一个新的 <code>hash.Hash对象</code> ，用来计算 <code>SHA1</code> 校验值. <code>Hash</code> 类型实际上是实现了 <code>io.Writer</code> 的接口</li><li>通过 <code>io.WriteString</code> 或 hasher.Write 将给定的 <code>[]byte</code> 附加到当前的 <code>hash.Hash</code> 对象中</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    hasher <span class="token operator">:=</span> sha1<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    io<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>hasher<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Result: %x\n"</span><span class="token punctuation">,</span> hasher<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Result: %d\n"</span><span class="token punctuation">,</span> hasher<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">//</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    hasher<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    data <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"We shall overcome!"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> hasher<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> n<span class="token operator">!=</span><span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">||</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Hash write error: %v / %v"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    checksum <span class="token operator">:=</span> hasher<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Result: %x\n"</span><span class="token punctuation">,</span> checksum<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="5-错误处理与测试"><a class="anchor" href="#5-错误处理与测试">#</a> 5. 错误处理与测试</h3><ol><li><p>Go 没有像 <code>java</code> 和 <code>.NET</code> 中的 <code>try/catch</code> 异常机制：不能执行抛出异常操作。但是有一套 <code>defer-panic-and-recover</code> 机制</p></li><li><p>Go 设计者认为 try/catch 机制的使用太泛滥，而且底层向更高级的层级抛异常太耗费资源. Go 设计的机制也可以 &quot;捕捉&quot; 异常，但是更轻量，且只应该作为 (处理错误的) 最后手段.</p></li><li><p>Go 处理普通错误时，通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值 -- 如果返回 nil, 则没有错误发生 -- 并且主调 (calling) 函数总是应该检查收到的错误.</p></li><li><p><mark>永远不要忽略错误，否则可能会导致程序崩溃！！</mark></p></li><li><p><code>panic and recover</code> 是用来处理真正的异常，(无法预测的错误) 而不是普通的错误.</p></li><li><p>库函数通常必须返回某种错误提示给主调 (calling) 函数</p></li><li><p>Go 检查和报告错误条件的惯有方式:</p><ul><li>产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 <code>nil</code> 则是成功，非 <code>nil</code> 就是发生了错误</li><li>为了防止发生错误时正在执行的函数 (如果有必要甚至会是整个程序) 被终止，在调用函数后必须检查错误</li></ul></li><li><p>为了更清晰的代码，一个总是使用包含错误值变量的 if 符合语句，显示错误信息可以使用 <code>fmt.Printf</code> 或者是 <code>log</code> 中对应的方法，如果程序终止也没关系的话升至可以使用 <code>panic</code></p></li></ol><h4 id="1错误处理"><a class="anchor" href="#1错误处理">#</a> 1. 错误处理</h4><ol><li>Go 有一个预先定义的 <code>error</code> 接口类型:<ul><li>错误值用来表示异常状态；errors 包中有一个 errorString 结构体实现了 error 接口.</li><li>程序出错时可以使用 os.Exit (1) 来终止运行</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>typr <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="2"><li>定义错误<ul><li>定义一个型的错误类型，可以用 <code>errors</code> 包中的 <code>errors.New</code> 函数接收合适的错误信息来创建</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>err <span class="token operator">:=</span> <span class="token builtin">error</span><span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"math - square root of negative number"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ol start="3"><li><p>由于 <code>fmt.Printf</code> 会自动调用 <code>string()</code> 方法，所以错误信息 &quot;Error: error message&quot; 会打印出来。通常 (错误信息) 都会有像 &quot;Error:&quot; 这样的前缀，所以错误信息不要以大写字母开头</p></li><li><p>大部分情况下自定义错误结构类型很有意义，可以包含除了 (低层级的) 错误信息之外的信息。例如，正在进行的操作 (打开文件等), 全路径或名字.</p></li><li><p>如果有不同错误条件可能发生，对实际的错误使用类型断言或者类型判断 (type-switch) 是很有用的，可以根据错误场景做一些补救和恢复操作</p></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// err != nil</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> e<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>os<span class="token punctuation">.</span>PathError<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// remedy situation</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 错误类型断言</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">switch</span> err <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">case</span> ParseError<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    	<span class="token function">PrintParseError</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">case</span> PathError<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    	<span class="token function">PrintPathError</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    defalut<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Not a special error,just %s\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="6"><li>错误类型命名都遵循同一种命名规范：错误类型以 &quot;Error&quot; 结尾，错误变量以 &quot;err&quot; 或 &quot;Err&quot; 开头</li><li><code>syscall</code> 是低阶外部包，用来提供基本调用的原始接口。返回封装整数类型错误码的 <code>syscall.Errno</code> ; 类型 syscall.Errno 实现了 <code>Error</code> 接口</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 大部分 syscall 函数都返回一个结果和可能的错误</span></pre></td></tr><tr><td data-num="2"></td><td><pre>r<span class="token punctuation">,</span> err <span class="token operator">:=</span> syscall<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> perm<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="8"><li><p>fmt 创建错误对象</p><ul><li>返回包含错误参数的更有信息量的字符串，可以用 <code>fmt.Errorf()</code> 来实现。和 <code>fmt.Printf()</code> 完全一样，接收一个或多个格式化占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 生成并返回一个错误对象</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> f <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"math: "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 从命令行读取输入是，加入 help 标志，可以用有用的错误信息产生一个错误</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"-h"</span> <span class="token operator">||</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"--help"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    err <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"usage: %s infile.txt outfile.txt"</span><span class="token punctuation">,</span> filepath<span class="token punctuation">.</span><span class="token function">Base</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li></ol><h4 id="2-运行时异常和panic"><a class="anchor" href="#2-运行时异常和panic">#</a> 2. 运行时异常和 panic</h4><ol><li>当发生数组下标越界或类型断言失败这样的运行时错误时，Go 运行时会触发运行时 <code>panic</code> , 伴随着程序的崩溃抛出一个 <code>runtime.Error</code> 接口类型的值。这个错误值有个 <code>RuntimeError()</code> 方法用于区别普通错误.</li><li><code>panic</code> 可以直接从 <code>diamante</code> 初始化：当错误条件很严苛且不可恢复，程序不能运行时，可以使用 <code>panic</code> 函数产生一个终止程序的运行时错误， <code>panic</code> 接收一个任意类型的参数，通常是字符串，在程序死亡时被发硬出来。负责程序终止并给出调试信息.</li><li>当发生错误必须终止程序时， <code>panic</code> 可以用于错误处理模式:</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"ERROR occurred:"</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="4"><li>多层嵌套的函数中调用 <code>panic</code> , 可以马上终止当前函数的执行，所有的 <code>defer</code> 语句都会保证执行并把控制权交还给接收到 <code>panic</code> 的函数调用者。并向上冒泡直到最顶层，并执行 (每层的) <code>defer</code> , 在栈顶处程序崩溃，并在命令中用传给 panic 的值报告错误情况。此终止过程就是 <mark>panicking</mark></li><li>标准库中有许多包含 <code>Must</code> 前缀的函数，像 <code>regexp.MustComplie</code> 和 <code>template.Must</code> ; 当正则表达式或模板中转入的转换字符导致错误时，这些函数会 <code>panic</code></li></ol><h4 id="3-从panic-中恢复-recover"><a class="anchor" href="#3-从panic-中恢复-recover">#</a> 3. 从 panic 中恢复 (Recover)</h4><ol><li><code>recover</code> 内建函数被用于从 <code>panic</code> 或 错误场景中回复：让程序可以从 <code>panicking</code> 重新获得控制权，停止终止过程进而回复正常执行.</li><li><code>recover</code> 只能在 <code>defer</code> 修饰的函数中使用；用于取得 <code>panic</code> 调用中传递过来的错误值，如果正常执行，调用 <code>recover</code> 会返回 <code>nil</code> , 且没有其它效果</li><li><code>panic</code> 会导致栈被展开直到 <code>defer</code> 修饰的 <code>recover()</code> 被调用或程序中止<ul><li>案例: <code>protect</code> 函数调用函数参数 g 来保护调用者防止从 g 中抛出的运行时 <code>panic</code> , 并展示 <code>panic</code> 信息</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 类似于 Java 和 .NET 语言中的 catch 块</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">protect</span><span class="token punctuation">(</span>g <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// println executes normally even if there is a panic</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"run time panic: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// possible runtime-error</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="4"><li><code>log</code> 包实现了简单的日志功能：默认的 <code>log</code> 对象向标准错误输出中写入并打印日志信息的日期和时间。除了 <code>Println</code> 和 <code>printf</code> 函数，其它致命性函数都会在写完日志信息后调用 <code>os.Exit(1)</code> , 退出函数也是如此。而 <code>panic</code> 效果的函数也会在写完日志信息后调用 <code>panic</code> ; 可以在程序必须终止 或 发生临界错误时使用.<ul><li>展示<mark> panic, defer 和 recover 结合使用</mark>的完整案例</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">badCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"bad end"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> e <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"panicing %s \r\n"</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">badCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"After bad call\r\n"</span><span class="token punctuation">)</span> <span class="token comment">// &lt;-- wordt niet bereikt</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Calling test\r\n"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Test completed\r\n"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 输出结果</span></pre></td></tr><tr><td data-num="19"></td><td><pre>Calling test</pre></td></tr><tr><td data-num="20"></td><td><pre>Panicing bad end</pre></td></tr><tr><td data-num="21"></td><td><pre>Test completed</pre></td></tr></table></figure><ol start="5"><li><code>defer-panic-recover</code> 在某种意义上也是一种像 <code>if</code> , <code>for</code> 的控制流机制.</li><li>Go 标准库中许多地方都使用了这种机制，例如 <code>json</code> 包中的解码和 <code>regexp</code> 包中的 <code>Compile</code> 函数.</li><li>Go 库的原则是及时在包内部使用了 <code>panic</code> , 在它的对外接口 (API) 中也必须使用 <code>recover</code> 处理成返回显示的错误.</li></ol><h4 id="4-自定义包中的错误处理和-panicking"><a class="anchor" href="#4-自定义包中的错误处理和-panicking">#</a> 4. 自定义包中的错误处理和 panicking</h4><ol><li><p>自定义包实现规范:</p><ul><li>在包内部，总是应该从 <code>panic</code> 中 <code>recover</code> : 不允许显示的超出包范围的 <code>panic()</code></li><li>向包的调用者返回错误值 (而不是 panic)</li></ul></li><li><p>在包内部，特别是非导出函数中有很深层次的嵌套调用时，将 panic 转换成 error 来提示调用者，提高可读性.</p></li></ol><h4 id="4-闭包处理错误的模式"><a class="anchor" href="#4-闭包处理错误的模式">#</a> 4. 闭包处理错误的模式</h4><ol><li>每当函数返回时，我们应该检查是否有错误发生：但是这会导致重复乏味的代码.</li><li>基于 <code>defer/panic/recover</code> 机制和闭包，得到一个更加优雅的模式。但此模式只有当所有函数都是同一种签名时可用.</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 拥有同样签名的 web 应用处理函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">handler1</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 假设函数签名相同</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>a type1<span class="token punctuation">,</span> b type2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 给函数类型一个别名</span></pre></td></tr><tr><td data-num="6"></td><td><pre>fType1 <span class="token operator">=</span> <span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>a type1<span class="token punctuation">,</span> b type2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="8"></td><td><pre> * 此模式中使用两个帮助函数</pre></td></tr><tr><td data-num="9"></td><td><pre> * 1) check: 检查是否有错误和 panic 发生的函数</pre></td></tr><tr><td data-num="10"></td><td><pre> * 2) errorhandler: 包装函数，接收 fTYpe1 类型函数 fn 返回调用 fn 的函数</pre></td></tr><tr><td data-num="11"></td><td><pre> */</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">func</span> <span class="token function">check</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> err<span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">func</span> <span class="token function">errorHandler</span><span class="token punctuation">(</span>fn fType1<span class="token punctuation">)</span> fType1 <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>a type1<span class="token punctuation">,</span> b type2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> err<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"run time panic: %v"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span>     </pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>错误发生时会 <code>recover</code> 并打印在日志中；除了简单打印，应用也可以用 <code>template</code> 包为用户生成自定义输出， <code>check()</code> 函数会在所有的被调用函数中调用</li><li>通过此机制，所有的错误都会被 recover, 并且调用函数后的错误检查代码也被简化为调用 check (err).</li><li>此模式下，不同的错误处理必须对应不同的函数类型；(错误处理) 可能被隐藏在错误处理包内部。可选择更加通用的方式：用一个空接口类型的切片作为参数和返回值.</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">f1</span><span class="token punctuation">(</span>a typr1<span class="token punctuation">,</span> b type2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    f<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token comment">//call function/method</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">check</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   	t<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token comment">//call function/method</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">check</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token comment">//call function/method</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">check</span><span class="token punctuation">(</span>err2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="5-启动外部命令和程序"><a class="anchor" href="#5-启动外部命令和程序">#</a> 5. 启动外部命令和程序</h4><ol><li>os 包的 StartProcess 函数可以调用或启动外部系统命令和二进制可执行文件；</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * name: 执行的进程名 argv: 传递参数或选项  attr 含有系统环境基本信息的结构体  </pre></td></tr><tr><td data-num="3"></td><td><pre> * 返回值：被启动进程的 Id (Pid)</pre></td></tr><tr><td data-num="4"></td><td><pre> */</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token function">StartProcess</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> argv <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> attr <span class="token operator">*</span>ProcAttr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Process<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ol start="2"><li><code>exec</code> 包有同样功能的更简单的结构体和函数；主要是 <code>exec.Command(name String, arg ...string)</code> 和 <code>Run()</code><ul><li>首先需要用系统命令或可执行文件的名字创建一个 <code>Command</code> 对象</li><li>然后使用 Command 对象作为接收者调用 <code>Run()</code></li></ul></li></ol><h4 id="6-go中的单元测试和基准测试"><a class="anchor" href="#6-go中的单元测试和基准测试">#</a> 6. Go 中的单元测试和基准测试</h4><ol><li>所有的包都应该有一定的必要文档，然后同样重要的是对包的测试</li><li>Go 中有名为 <code>testing</code> 的包被专门用来进行自动化测试，日志和错误报告。并且还包含一些基准测试函数的功能.</li><li><code>gotest</code> 是 <code>Unix bash</code> 脚本，在 <code>Windows</code> 下需要配置 <code>MINGW</code> 环境；在 <code>Windows</code> 环境下把所有的 <code>pkg/linux_admin64</code> 替换成 <code>pkg/windows</code> .</li><li>对一个包 (单元) 测试，需要写一些可以频繁 (每次更新后) 执行的小块测试单元来检查代码的正确性。所以必须写一些 Go 源文件来测试代码。测试程序必须属于被测试的包，并且文件名满足 <code>*_test.go</code> 的格式，所以测试代码和包中的业务代码是分开的.</li><li><code>_test</code> 程序不会被普通的 Go 编译器编译，所以当放应用部署到生产环境时它们不回被部署；只有 <code>gotest</code> 会编译所有的程序：普通程序和测试程序.</li><li>测试文件中必须导入 <code>&quot;testing&quot;</code> 包，且包含一些名称以 <code>TestXxx</code> 开头的全局函数，例如: TestFmtInterface.</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 测试函数必须有这种形式的头部:</pre></td></tr><tr><td data-num="3"></td><td><pre> * T 是传给测试函数的结构类型，用来管理测试状态，支持格式化测试日志 如: t.Log,t.Error</pre></td></tr><tr><td data-num="4"></td><td><pre> * 在函数结尾把输出和想要的结果对比，如果不等就打印一个 UC 哦呜。成功则直接返回</pre></td></tr><tr><td data-num="5"></td><td><pre> */</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">TestFunc</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span></pre></td></tr></table></figure><p><mark>通知测试失败的函数</mark></p><table><thead><tr><th>方法签名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>func (t *T) Fail()</td><td style="text-align:center">标记测试函数失败，继续执行剩下测试</td></tr><tr><td>func (t *T) FailNow()</td><td style="text-align:center">标记测试函数失败，终止运行，同文件其他测试略过，执行下个文件</td></tr><tr><td>func (t *T) Log(args ...interface{})</td><td style="text-align:center">args 被默认的格式格式化并打印到错误日志中</td></tr><tr><td>func (t *T) Fatal(args ...interface{})</td><td style="text-align:center">先执行 Log 再执行 Fatal 的效果</td></tr></tbody></table><ol start="7"><li><code>testing</code> 包中有一些类型和函数可以用来做加单的基准测试；<ul><li>测试代码中必须包含以 <code>BenchmarkZzz</code> 打头的函数，并接收一个 <code>*testing.B</code> 类型的函数</li><li>命令 go test -test.beanch=.* 会运行所有的基准测试函数；</li><li>代码中的函数会被调用 N 次，并展示 N 的值和函数执行的平均时间，单位 <code>ns(纳秒)</code> .</li><li>如果使用 testing.Benchmark 调用，直接运行程序即可</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">BeanchmarkReverse</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="7-性能调试-分析并优化go程序"><a class="anchor" href="#7-性能调试-分析并优化go程序">#</a> 7. 性能调试 (分析并优化 Go 程序)</h4><ol><li>时间和内存消耗<ul><li>在 Unix 命令中使用 <code>xtime goprogexe</code> , 此处的 progexec 是一个 Go 可执行程序，</li><li>输出类似 56.63u 0.26s 56.92r 1642640kB progexec, 分别对应 用户时间，系统时间，实际时间和最大内存占用</li></ul></li></ol><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">## 使用便捷脚本 xtime 来测量</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">#!/bin/sh</span></pre></td></tr><tr><td data-num="3"></td><td><pre>/usr/bin/time -f <span class="token string">'%Uu %Ss %er %MKB %C'</span> <span class="token string">"<span class="token variable">$@</span>"</span></pre></td></tr></table></figure><ol start="2"><li>go test 调试<ul><li>如果代码使用了 Go 中 <code>testing</code> 包的基准测试功能，可以用 <code>gotest</code> 标准的 <code>-cpuprofile</code> 和 <code>-memprofile</code> 标志向指定文件写入 CPU 或 内存使用情况报告.</li><li>使用方式: <code>go test -x -v -cpuprofile=prof.out -file x-test.go</code></li><li>编译执行 <code>x_test.go</code> 中的测试，并向 <code>prof.out</code> 文件中写入 cpu 性能分析信息.</li></ul></li><li>pprof 调试<ul><li>可以在单机程序 <code>progexec</code> 中引入 <code>runtime/pprof</code> 包；</li><li><code>pprof</code> 包 以可视化工具需要的格式写入运行时的报告数据.</li><li>Go flag 库用来解析命令行，如果命令行设置 cpuprofile flag, 则开始 CPU 性能分析并把结果重定向到对应文件</li><li>分析程序在程序退出之前调用 <code>StopCPUProfile</code> 来刷新挂起的写操作到文件中；用 <code>defer</code> 保证 <code>main</code> 返回时触发</li><li>使用 flag 运行程序: <code>progexec -cpuprofile=progexec.prof</code></li><li>然后使用 <code>gopprof progexec progexec.prof</code></li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> cpuprofile <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token string">"cpuprofile"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"write cpu profile to file"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token operator">*</span>cpuprofile <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">*</span>cpuprofile<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        pprof<span class="token punctuation">.</span><span class="token function">StartCPUProfile</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">defer</span> pprof<span class="token punctuation">.</span><span class="token function">StopCPUProfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="4"><li>gopprof 命令<ul><li>程序是 Google pprofC++ 分析器的轻微变种</li><li>开启 CPU 性能分析，GO 程序会以约每秒 100 次的频率阻塞并记录当前执行的 <code>goroutine栈</code> 上的程序计数器样本.</li></ul></li></ol><p>1)、 <code>topN</code></p><ul><li>用来展示分析结果中最前面的 N 份样本，例如: top5 会展示在程序运行期间调用最频繁的 5 个函数</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 输出结果第五列表示函数的调用频度</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Total<span class="token punctuation">:</span> <span class="token number">3099</span> samples</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">626</span> <span class="token number">20.2</span><span class="token operator">%</span> <span class="token number">20.2</span><span class="token operator">%</span> <span class="token number">626</span> <span class="token number">20.2</span><span class="token operator">%</span> scanblock</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">309</span> <span class="token number">10.0</span><span class="token operator">%</span> <span class="token number">30.2</span><span class="token operator">%</span> <span class="token number">2839</span> <span class="token number">91.6</span><span class="token operator">%</span> main<span class="token punctuation">.</span>FindLoops</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">...</span></pre></td></tr></table></figure><p>2)、 <code>web</code> 或 <code>web函数名</code></p><ul><li>该命令生成一份 <code>SVG</code> 格式的分析数据图标，并在浏览器中打开</li><li>还有一个 gv 命令可以生成 <code>PostScript</code> 格式的数据，并在 <code>GhostView</code> 中打开，此命令需要安装 <code>graphviz</code></li><li>函数被表示成不同的矩形 (被调用越多，矩形越大), 箭头表示函数调用链.</li></ul><p>3）、 <code>list</code> 函数名 或 <code>weblist</code> 函数名</p><ul><li>展示对应函数名的代码行列表，第二列表示当前执行消耗的时间，可以很好地展示出运行中消耗最大的代码</li><li>如果发现函数 runtime.mallocgc (分配内存并执行周期性的垃圾回收) 调用频繁，就应该进行内存分析，找出垃圾回收频繁执行的原因和内存大量分配的根源<ul><li>用 <code>-memprofile flag</code> 运行这个程序: <mark>progexec -memprofile=progexec.mprof</mark></li><li>然后可以再次使用 gopprof 工具: <mark>gopprof progexec progexec.mprof</mark></li><li><code>top5</code> , <code>list</code> 函数名 等命令同样适用，只不过变成以 MB 为单位测量内存分配的情况.</li></ul></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 为了达到上述效果需要上合适的地方添加如下代码</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> memprofile <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token string">"memprofile"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"write memory profile to this file"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">...</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">CallToFunctionWhichAllocatesLotsOfMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">if</span> <span class="token operator">*</span>memprofile <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">*</span>memprofile<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    pprof<span class="token punctuation">.</span><span class="token function">WriteHeapProfile</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// TOP 5</span></pre></td></tr><tr><td data-num="15"></td><td><pre>Total<span class="token punctuation">:</span> <span class="token number">118.3</span> MB</pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token number">66.1</span> <span class="token number">55.8</span><span class="token operator">%</span> <span class="token number">55.8</span><span class="token operator">%</span> <span class="token number">103.7</span> <span class="token number">87.7</span><span class="token operator">%</span> main<span class="token punctuation">.</span>FindLoops</pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token number">30.5</span> <span class="token number">25.8</span><span class="token operator">%</span> <span class="token number">81.6</span><span class="token operator">%</span> <span class="token number">30.5</span> <span class="token number">25.8</span><span class="token operator">%</span> main<span class="token punctuation">.</span><span class="token operator">*</span>LSG·NewLoop</pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token operator">...</span></pre></td></tr></table></figure><ul><li>报告内存分配计数的有趣工具:</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>gopprof <span class="token operator">--</span>inuse_objects progexec progexec<span class="token punctuation">.</span>mprof</pre></td></tr></table></figure><ul><li>web 应用有标准的 HTTP 接口可以分析数据。在 HTTP 服务中添加 <code>import _ &quot;http/pprof&quot;</code></li><li>为 /debug/pprof/ 下的一些 URL 安装处理器。然后用一个唯一的参数 -- 服务中的数据分析的 URL 来执行 <code>gopprof</code> 命令</li></ul><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">import</span> _ <span class="token string">"http/pprof"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>gopprof http://localhost:6060/debug/pporf/profile 	<span class="token comment"># 30-second CPU profile</span></pre></td></tr><tr><td data-num="3"></td><td><pre>gopprof http://localhost:6060/debug/pporf/heap		<span class="token comment"># heap profile</span></pre></td></tr></table></figure><h3 id="6-协程与通道"><a class="anchor" href="#6-协程与通道">#</a> 6. 协程与通道</h3><blockquote><p>协程 (goroutine) 与 通道 (channel)</p></blockquote><ul><li><p>Go 作为 21 世纪语言，Go 原生支持应用之间的同学 (网络，客户端和服务端，分布式计算) 和程序的并发.</p></li><li><p>程序可以在不同的处理器和计算机上同时执行不同的代码段.</p></li><li><p>Go 语言为构建并发程序的基本代码块是 协程 (goroutine) 与 通道 (channel).</p></li><li><p>需要语言，编译器和 runtime 的支持，Co 语言提供的垃圾回收器对并发变成只管重要</p></li><li><p><strong>不要通过共享内存来通信，而通过通信来共享内存</strong> 通信强制协作</p></li></ul><h4 id="1-并发并行和协程"><a class="anchor" href="#1-并发并行和协程">#</a> 1. 并发，并行和协程</h4><blockquote><p>协程的定义</p></blockquote><ol><li>一个应用程序是运行在机器上的一个进程；进程是一个运行在自己内存地址空间的独立执行体。一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体.</li><li>几乎所有 ' 正式 ' 的程序都是多线程的，已便让用户或计算机不必等待，或者能够同时服务多个请求 (如 web 服务器), 或增加性能和吞吐量 (通过对不同的数据集并行执行代码)</li><li>一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但只有同一个程序在某个时间点同时运行在多个或者多处理器上才是真正的并行.</li><li>并行是一种通过使用多处理器以提高速度的能力。所以并发程序可以是并行也可以不是.</li><li>公认多线程的应用难以做到转却，最主要的问题是内存中的数据共享，数据会被多线程以无法预知的方式进行操作，导致一些无法重现或随机的结果 (竞态)<mark><strong> 不要使用全局变量或共享内存，它们会使代码在并发运算的时候产生危险</strong></mark></li><li>并发解决之道在于同步不同的线程，对数据加锁就可以保证同时只有一个线程可以变更数据。加锁会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个方法不再适合现代多核心 / 多处理器编程: <code>thread-per-connection</code> 模型不够有效</li><li>Go 的标准库 <code>sync</code> 中有一些工具用来在低级别代码中实现加锁；</li><li>Go 更倾向于其他的方式，诸多合适的范式中:<ul><li><code>Communicating Sequential Processes (顺序通信处理)</code> (CSP, C.Hoare 发明)</li><li><code>message passing-model (消息传递)</code> (已经运用在其它语言中，如 Erlang)</li></ul></li><li>Go 中的应用程序并发处理的部分被称作 <code>grouting (协程)</code> , 可以更有效的并发运算.<ul><li>在协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射 (多路复用) 在其之上</li><li>协程调度器在 Go 运行时很好的完成了这个工作.</li><li>协程工作在相同的地址空间中，所以共享内存的方式一定是同步的；可以使用 <code>sync</code> 包实现，但不建议，Go 使用 <code>channel1</code> 来同步协程</li><li>当系统调用 (如：等待 I/O) 阻塞协程时，其它协程会继续在其它线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作.</li><li>协程是轻量的，比线程更轻.(使用少量的内存和资源): 使用 4K 的栈内存就可以在堆中创建.</li><li>协程创建非常廉价，必要的时候可以轻松创建并运行大量协程，并且协程对栈进行了分割，从而动态的增加 (或缩减) 内存的使用；栈的管理是自动的，但不是由垃圾回收器管理，而是在协程退出后自动释放</li><li>协程可以运行在多个操作系统之间，也可以运行在线程之类，以很小的占用就可以处理大量任务。操作系统线程上的协程时间片，可以使用少量的操作系统线程就能拥有任意多个提供服务的线程，且 Go 运行时可以自主意识到哪些协程被阻塞，暂时搁置它们并处理其他线程</li><li>两种并发方式：确定性的 (明确定义排序) 和 非确定性的 (加锁 / 互斥从而未定义排序).Go 的协程和通道支持确定的并发方式 (通道具有 <code>sender</code> 和 <code>receiver</code> )</li><li>协程是通过使用关键字 go 调用 (执行) 一个函数或方法来实现的 (也可以是匿名或 <code>lambda</code> 函数). 这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中且分配了独立的栈，例如: <code>go sum(bigArray)</code> , 在后台计算总和.</li><li>协程的栈会根据需要进行伸缩，不出现栈溢出；开发者不需要关系栈的大小。当协程结束的时候，它会静默退出：用来启动这个程序的函数不会得到任何返回值.</li><li>任何 Go 程序都必须有的 <code>main()函数</code> 也可以看做一个协程，尽管它没有通过 <code>go</code> 来启动。协程可以在程序初始化的过程中运行 (在 <code>init()</code> 函数中).</li><li>在一个协程中，如果需要进行非常密集的运算，可以在运算循环中周期的使用 <code>runtime.Gosched()</code> : 让出处理器，允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。使用 <code>Gosched()</code> 可以使计算均匀分布</li></ul></li></ol><blockquote><p>并发和并行的差异</p></blockquote><ol><li>Go 的并发原语提供了良好的并发设计基础：表达程序结构以便表示独立地执行的动作</li><li>Go 的重点不在于并行的首要位置：并发程序可能是并行的，也可能不是。并行是一种通过使用多处理器以提高速度的能力。一个设计良好的并发程序在并行方面的表现也非常出色.</li><li>Go 默认没有并行指令，只有一个独立的核心或处理器被专门用于 Go 程序，不论它启动了多少个协程；所以这些协程是并发运行的，但是不是并行运行的：同一时间只有一个协程会处在运行状态</li><li>使用 <code>GOMAXPROCS</code> 变量，使程序可以使用多个核心运行，此时协程就是真正的并行运行</li><li>只有 gc 编译器真正实现了协程，适当的吧协程映射到操作系统线程。使用 <code>gccgo编译器</code> ，为每一个协程创建操作系统线程</li></ol><blockquote><p>GOMAXPROCS 启动多核执行</p></blockquote><ol><li>在 gc 编译器下必须设置 <code>GOMAXPROCS</code> 为一个大于默认值 1 的数值来允许运行时支持使用多于 1 个的操作系统线程，所有的协程都会共享同一个线程，除非将 <code>GOMAXPROCS</code> 设置为一个大于 1 的数。当 <code>GOMAXPROCS</code> 大于 1 时，会有一个线程池管理许多的线程。通过 <code>gccgo 编译器</code> <code>GOMAXPROCS</code> 有效的与运行中的协程数量相等.</li><li>如果环境变量 <mark>GOMAXPROCS&gt;= n 机器核心数量</mark>，或执行 <code>runtime.COMAXPROCS(n)</code> , 协程会被分散到 n 个处理器上。更多的处理器并不意味着性能的线性提升。通常 n 个核心的情况下设置 <code>GOMAXPROCS 为 n-1</code> 获得最佳性能，但同样需要遵守 <mark>协程数量 &gt; 1 + GOMAXPROCS &gt;1</mark></li><li>某一时间只有一个协程在执行，不要设置 <code>GOMAXPROCS</code></li><li>GOMAXPROCS 等同于 (并发的) 线程数量，在一台核心数大于 1 的机器上，会竟可能有等同于核心数的线程在并行运行</li></ol><blockquote><p>用命令指定使用的核心数量</p></blockquote><ul><li>使用 <code>flags</code> 包</li><li>协程可以通过调用 <code>runtime.Goexit()</code> 来停止</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> numCores <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"number of CPU cores to use"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 在 main 中调用</span></pre></td></tr><tr><td data-num="3"></td><td><pre>flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token operator">*</span>numCores<span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li><code>main()</code> 函数返回时，程序退出：不会等待任何非 main () 协程的结束.</li><li>服务器程序中，每个请求都会启动一个协程来处理， <code>server()</code> 函数必须保持运行状态。通常使用无限循环.</li><li>协程是独立的处理单元，一旦陆续启动一些协程，无法确定其真正开始执行时间，所以代码逻辑必须独立于协程的调用顺序</li><li>协程案例：在一个非常长的数组中查找一个元素。将数组分割为若干个不重复的切片，启用多个并行的协程进行查找</li></ul><blockquote><p>Go 协程 (goroutines) 和协程 (coroutines)</p></blockquote><ol><li>其他语言中的协程概念与 Go 语言有些相似，但是不同</li><li>Go 协程意味着并行 (或者可以以并行的方式部署), 协程一般不是如此</li><li>Go 协程通过通道来通信；协程通过让出和恢复操作来通信</li><li>Go 协程比协程更强大，也更容易从协程的逻辑复用到 Go 协程.</li></ol><h4 id="2-协程间的信道"><a class="anchor" href="#2-协程间的信道">#</a> 2. 协程间的信道</h4><blockquote><p>概念</p></blockquote><ul><li>协程必须通信才会变得更有用：彼此之间发送和接收信息必须协调 / 同步它们的工作.</li><li>协程可以使用共享变量来通信，但是很不提倡，因为这种方式给所有的共享内存的多线程都带来了困难</li><li>Go 有一种特殊的类型，通道 (channel), 就像一个可以用于发送类型化数据的管道，由其负责协程之间通信，从而避开所有共享内存导致的陷阱</li><li>Go 通过过道进行通信保证了同步性。数据在通道中进行传递:<ul><li>在任何给定时间，一个数据被设计为只有一个协程可对其访问，所以不会发生数据竞争.</li><li>数据的所有权 (可以读写数据的能力) 也因此被传递.</li></ul></li><li>通道服务与通信的两个：值的交换，同步的保证了两个计算 (协程) 任何时候都是可知状态.</li></ul><p><img data-src="https://s3.bmp.ovh/imgs/2022/01/5fad3ba466dab15c.png" alt="channel"></p><ul><li>通道声明: <code>var identifier chan datatype</code> , 未初始化的通道值是 nil.</li><li>通道只能传输一种类型的数据：例如: <code>chan int</code> 或者 <code>chan string</code> , 所有类型都可以用于通道，空接口 <code>interface&#123;&#125;</code> 也可以。甚至可以创建通道的通道.</li><li>通道实际上是类型化消息的队列：使数据得以传输。是先进先出 (FIFO) 的结构，所以可以保证发送元素的顺序.</li><li>通道可以比作 Unix shells 中的双向管道 (two-way pipe), 通道也是引用类型，使用 <code>make()</code> 函数分配内存.</li><li>通道是第一类对象：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送自身.</li><li>通道是类型化的，允许类型检查，比如尝试使用整数通道发送一个指针.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> ch1 <span class="token keyword">chan</span> <span class="token builtin">string</span></pre></td></tr><tr><td data-num="2"></td><td><pre>ch1 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 简短赋值</span></pre></td></tr><tr><td data-num="4"></td><td><pre>ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>chanOfChans <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>	<span class="token comment">//int 通道的通道</span></pre></td></tr><tr><td data-num="6"></td><td><pre>funcChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>	<span class="token comment">// 函数通道</span></pre></td></tr></table></figure><blockquote><p>通信操作符 &lt;-</p></blockquote><ul><li>&lt;- 操作符直观的标示了数据的传输：信息按照箭头的方向流动.<ul><li><code>ch &lt;- int1</code> 表示：用通道 ch 发送变量 int1 (双目运算符，中缀 = 发送)</li></ul></li><li>从通道流出 (接收), 三种方式:<ul><li><code>int2 = &lt;- ch</code> 表示：变量 int2 从通道 ch (一元运算符的前缀操作符，前缀 = 接收) 接收数据，int2 没有被声明可写成: <code>int2 := &lt;-ch</code></li><li><code>&lt;- ch</code> 可以单独调用获取通道的 (下一个) 值，当前值会被丢弃，但是可以用来验证</li></ul></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token operator">&lt;-</span> ch <span class="token operator">!=</span> <span class="token number">1000</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>同一个操作符 &lt;- 既用于发送也用于接收，但 Go 会根据操作对象自主区分。虽然非强制要求，但是为了可读性通道的命令通常以 <code>ch</code> 开头或者包含 <code>chan</code> . 通道的发送和接收都是原子操作：彼此总是互不干扰的.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">sendData</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">getData</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1e9</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">func</span> <span class="token function">sendData</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    ch <span class="token operator">&lt;-</span> <span class="token string">"Washington"</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    ch <span class="token operator">&lt;-</span> <span class="token string">"Tripoli"</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    ch <span class="token operator">&lt;-</span> <span class="token string">"London"</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    ch <span class="token operator">&lt;-</span> <span class="token string">"Beijing"</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    ch <span class="token operator">&lt;-</span> <span class="token string">"Tokyo"</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">func</span> <span class="token function">getData</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">var</span> input <span class="token builtin">string</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// time.Sleep(2e9)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        input <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch</pre></td></tr><tr><td data-num="19"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s "</span><span class="token punctuation">,</span> input<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><code>main()</code> 函数中启动了两个协程: <code>sendData()</code> 通过通道 ch 发送了 5 个字符串， <code>getData()</code> 按顺序接收并打印</li><li>如果两个协程需要通信，必须给定同一个通道作为参数才行.</li><li>运行时 (runtime) 会检查所有的协程是否在等待 (可从某个通道读取或写入某个通道), 意味着程序将无法继续执行，这是死锁 (deadlock) 的一种形式，运行时 (runtime) 可以检测这种情况</li><li>注意事项：不要使用打印状态来表明通道的发送和接收顺序：打印状态和通道实际发生读写的时间延迟会导致和真实顺序不同</li></ul><blockquote><p>通道阻塞</p></blockquote><ul><li>默认情况下，通信是同步且无缓冲的:</li><li>在有接收者接收数据之前，发送不会结束.</li><li>一个无缓冲的通道在没有空间来保存数据的时候:<ul><li>必须有一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者.</li></ul></li><li>所有通道的发送 / 接收操作在对方准备好之前是阻塞的:</li></ul><ol><li>对于同一个通道，发送操作 (协程或函数中), 在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：通道值被接收时 (可以传入变量)</li><li>对于同一个通道，接收操作是阻塞的 (协程或函数中), 直到发送者可用：如果通道中没有数据，接收者就阻塞了.<ul><li>一个协程在无限循环中给通道发送整数数据。但因为没有接收者，只输出了一个数字 0</li><li><code>pump()</code> 函数为通道提供数值，也被称为生产者</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">pump</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span>		<span class="token comment">//pump hangs</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ch1<span class="token punctuation">)</span>	<span class="token comment">// prints only 0</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">pump</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        ch <span class="token operator">&lt;-</span>i</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>输出<span class="token punctuation">:</span> <span class="token number">0</span></pre></td></tr></table></figure><blockquote><p>通过一个 (或多个) 通道交换数据进行协程同步</p></blockquote><ol><li>通信是一种同步形式：通过通道，两个协程在 通信 (协程会和) 中某刻同步交换数据。无缓冲工具成为了多个协程同步的完美工具.</li><li>甚至可以在通道两端互相阻塞对方，形成死锁状态.Go 运行时会检查并 <code>panic</code> , 停止程序.</li><li>无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道.</li></ol><blockquote><p>同步通道 -- 使用带缓冲的通道</p></blockquote><ol><li>一个无缓冲通道只能包含一个元素，有时显得很局限。可以在扩展 <code>make</code> 命令中设置其容量</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//buf 是通道可以同时容纳的元素 (此处是 string) 个数</span></pre></td></tr><tr><td data-num="2"></td><td><pre>buf <span class="token operator">:=</span> <span class="token number">100</span></pre></td></tr><tr><td data-num="3"></td><td><pre>ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span></pre></td></tr></table></figure><ol start="2"><li>在缓冲满载 (缓冲被全部使用) 之前，给一个带缓冲的通道发送 或 读取数据不会被阻塞，直到缓冲满载.</li><li>缓冲容量和类型无关，可以给通道设置不同的容量，只要拥有相同元素类型。内置 <code>cap</code> 函数可以返回缓冲区的容量</li><li>如果容量大于 0, 通道就是异步的：缓冲满载 (发送) 或变空 (接收) 之前通信不回阻塞，元素会按照发送顺序被接收.</li><li>如果容量为 0 或未设置，通信仅在收发双方准备好的情况下才可以成功.</li><li>使用通道的缓冲，程序会在 &quot;请求&quot; 激增的时候表现更好：更具弹性，专业术语：更具伸缩弹性</li><li>在设计算法时首先考虑无缓冲通道，只有在不确定的情况下使用缓冲.</li></ol><p><mark>同步: ch :=make (chan typr,value)</mark></p><ul><li><code>value == 0 -&gt; synchronous, unbuffered</code> (阻塞)</li><li><code>value &gt; 0 -&gt; asynchronous, buffered</code> (非阻塞) 取决于 value 元素</li></ul><blockquote><p>协程中用通道输出结果</p></blockquote><ol><li>为了知晓计算何时完成，可以通道通信回报。在例子 <code>go sum(bigArray)</code> 中</li><li>也可以使用通道来达到同步目的，此方法被称为 信号量 (semaphore). &lt; 通道通过发送信号告知处理完成 &gt;</li><li>在其他协程运行时让<mark> main 程序无限阻塞</mark>的常规做法是在 main 函数的最后放置一个 <code>select&#123;&#125;</code></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">go</span> <span class="token function">sum</span><span class="token punctuation">(</span>bigArray<span class="token punctuation">,</span> ch<span class="token punctuation">)</span>		<span class="token comment">// bigArray puts the calculated sum on ch</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// ...do something else for a while</span></pre></td></tr><tr><td data-num="4"></td><td><pre>sum <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch		<span class="token comment">// wait for, and retrieve the sum</span></pre></td></tr></table></figure><blockquote><p>信号量模式</p></blockquote><blockquote><p>并行实现的 for 循环</p></blockquote><ul><li>for 循环并行计算迭代可能带来很好的性能提升，不过所有的迭代都必须是独立完成.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> data <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">go</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span>v <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token function">doSomething</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token operator">...</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>缓冲通道实现信号量</p></blockquote><ol><li>型号量是实现互斥锁 (排外锁) 常见的同步机制，限制对资源的访问，解决读写问题，比如没有实现信号量的 <code>sync</code> 的 Go 包，使用带缓冲的通道可以轻松实现:<ul><li>带缓冲通道的容量和要同步的资源容量相同</li><li>通道的长度 (当前存放的元素个数) 与当前资源被使用的数量相同</li><li>容量减去通道的长度就是未处理资源的个数 (标准信号量的整数值)</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 不论通道中存放的是什么，只关注长度；</pre></td></tr><tr><td data-num="3"></td><td><pre> * 英雌创建一个长度可变但容量为 0 的 (字节) 通道:</pre></td></tr><tr><td data-num="4"></td><td><pre> */</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">type</span> Empty <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">type</span> semaphore <span class="token keyword">chan</span> Empty</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="8"></td><td><pre> * 以可用资源的数量 N 来初始化信号量</pre></td></tr><tr><td data-num="9"></td><td><pre> * semaphore : sem = make (semaphore, N)</pre></td></tr><tr><td data-num="10"></td><td><pre> * 然后直接对信号量进行操作</pre></td></tr><tr><td data-num="11"></td><td><pre> * acquire n resources</pre></td></tr><tr><td data-num="12"></td><td><pre> */</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>s semaphore<span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    e <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Empty<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        s <span class="token operator">&lt;-</span> e</pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// release n resources</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>s semaphore<span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">for</span> i<span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token operator">&lt;-</span> s</pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">/* 实现互斥的案例 */</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">/* mutexes */</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>s semaphore<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    s<span class="token punctuation">.</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>s semaphore<span class="token punctuation">)</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    s<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">/* signal-wait */</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>s semaphore<span class="token punctuation">)</span> <span class="token function">Wait</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    s<span class="token punctuation">.</span><span class="token function">P</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>s semaphore<span class="token punctuation">)</span> <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    s<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>给通道使用 for 循环</p></blockquote><ol><li><code>for</code> 循环的 range 语句可以用在通道 <code>ch</code> 上，从通道获取值</li><li>从指定通道读取数据直到通道关闭，才继续执行下方代码.</li><li>另一个协程必须写入 <code>ch</code> (不然代码就阻塞在 for 循环了), 而且必须在写入完成后才关闭.</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> v <span class="token operator">:=</span> rang ch <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"The Value is %v\n"</span><span class="token punctuation">,</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="4"><li>习惯用法：通道迭代模式<ul><li>生产者 - 消费者模式:<ul><li>通常，需要从包含了地址索引字段 <code>Items</code> 的容器给通道填入元素。为容器的类型定义一个方法 <code>Iter()</code> , 返回一个只读的通道 Items</li></ul></li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>container<span class="token punctuation">)</span> <span class="token function">Iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token keyword">chan</span> item <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> item<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> c<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span> <span class="token comment">//or use a for-range loop</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            ch <span class="token operator">&lt;-</span> c<span class="token punctuation">.</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> ch</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="5"><li>在协程里，一个 for 循环迭代容器 c 中的元素 (对于树或图的算法，简单的 for 循环可以替换为深度优先搜索)</li><li>其运行在自己启动的协程中，所以上边的迭代用到了一个通道和两个协程 (可能运行在不同的线程上).<ul><li>如果在程序结束前，向通道写值的协程未完成工作，则这个协程不会被垃圾回收；</li><li>这是设计使然，这种并不符合预期的行为正式由通道这种线程安全的通信方式所导致的.</li><li>因此，一个协程可能为了写入一个永远无人读取的通道而被挂起成为一个 bug, 并不会被悄悄回收</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//  调用此方法的代码可以如下迭代容器:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> x <span class="token operator">:=</span> <span class="token keyword">range</span> container<span class="token punctuation">.</span><span class="token function">Iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>习惯用法：生产者消费者模式</mark></p><p><code>Produce()</code> 函数 产生 <code>Consume</code> 函数需要的值.</p><p>两者可以运行在独立的协程中，生产者在通道中放入消费者读取的值。整个过程可替换为无限循环</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">Consume</span><span class="token punctuation">(</span><span class="token function">Produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>通道的方向</p></blockquote><p>通道类型可以用注解表示 只发送 或 只接收</p><ul><li>只接收的通道 (&lt;- chan T) 无法关闭，关闭通道是发送者用来表示不再给通道发送值，所以对只接受通道没有意义</li><li>通道创建的时候都是双向的，但也可以分配有方向的通道变量</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> send_only <span class="token keyword">chan</span> <span class="token operator">&lt;-</span> <span class="token builtin">int</span>			<span class="token comment">// channel can only receive data</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> recv_only <span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span>			<span class="token comment">// channel can only send data</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 分配有方向的通道</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// bidirectional</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">go</span> <span class="token function">source</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">go</span> <span class="token function">sink</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">func</span> <span class="token function">source</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span> ch <span class="token operator">&lt;-</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">func</span> <span class="token function">sink</span><span class="token punctuation">(</span>ch <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span> <span class="token operator">&lt;-</span>ch <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>习惯用法：管道和选择器模式</mark></p><p>协程处理从通道接收的数据并发送给输出通道:</p><ul><li>通过方向注解来限制协程对通道的操作</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>sendChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>receiveChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">go</span> <span class="token function">processChannel</span><span class="token punctuation">(</span>sendChan<span class="token punctuation">,</span> receiveChan<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token function">processChannel</span><span class="token punctuation">(</span>in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> inValue <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        result <span class="token operator">:=</span> <span class="token operator">...</span> <span class="token comment">/// processing inValue</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        out <span class="token operator">&lt;-</span> result</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>使用选择器 (' 筛 ') 作为算法，答应输出的素数，每个 prime 都有一个选择器，如下图:</li></ul><p><img data-src="https://i.bmp.ovh/imgs/2022/02/ad0cd46b9ceee000.png" alt="primeSelector"></p><ul><li>协程 <mark>filter(in,out chan int,prime int)</mark> 拷贝整数到输出通道，丢弃可以被 prime 整除的数字，然后每个 prime 又开启一个新的协程，生成器和选择器并发请求</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token string">"fmt"</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 向 channel 通道发送 2,3,4 ... 序列</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token function">generate</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        ch <span class="token operator">&lt;-</span> i <span class="token comment">// Send 'i' to channel 'ch'.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 从 in 通道复制数据到 out 通道</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 去除能被 prime 整除的数</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">func</span> <span class="token function">filter</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> out <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> prime <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>in <span class="token comment">// 从 in 通道中 接收新的 value 赋予 i</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> i<span class="token operator">%</span>prime <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            out <span class="token operator">&lt;-</span> i <span class="token comment">// 将 i 发送到 out 通道</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// 筛选通道序列中的素数</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个新的通道</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">generate</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>      <span class="token comment">// 以协程的方式启动 generate ().</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        prime <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch</pre></td></tr><tr><td data-num="25"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>prime<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">go</span> <span class="token function">filter</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> ch1<span class="token punctuation">,</span> prime<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        ch <span class="token operator">=</span> ch1</pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>实现方式二:</mark></p><ol><li>工厂函数 <code>sieve</code> , <code>generate</code> 和 <code>filter</code> ; 创建通道并返回，使用协程的 <code>lambda</code> 函数.</li><li><code>main</code> 函数短小清晰：调用 <code>sieve()</code> 返回包含素数的通道</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token string">"fmt"</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Send the sequence 2, 3, 4, ... to returned channel</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            ch <span class="token operator">&lt;-</span> i</pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> ch</pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Filter out input values divisible by 'prime', send rest to returned channel</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">func</span> <span class="token function">filter</span><span class="token punctuation">(</span>in <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> prime <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    out <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">if</span> i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>in<span class="token punctuation">;</span> i<span class="token operator">%</span>prime <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                out <span class="token operator">&lt;-</span> i</pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">return</span> out</pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">func</span> <span class="token function">sieve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    out <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        ch <span class="token operator">:=</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            prime <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch</pre></td></tr><tr><td data-num="33"></td><td><pre>            ch <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> prime<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            out <span class="token operator">&lt;-</span> prime</pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">return</span> out</pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    primes <span class="token operator">:=</span> <span class="token function">sieve</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>primes<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="3协程的同步-关闭通道-测试阻塞的通道"><a class="anchor" href="#3协程的同步-关闭通道-测试阻塞的通道">#</a> 3. 协程的同步：关闭通道 - 测试阻塞的通道</h4><ol><li>通道可以被显示的关闭；尽管与文件不同: <code>不必每次都关闭</code> .</li><li>只有在当需要告诉接收者不会再提供新值的时候才需要关闭通道.</li><li>只有发送者需要关闭通道，接收者永远不会需要</li></ol><blockquote><p>通道的关闭</p></blockquote><ol><li>在通道的 <code>sendData()</code> 完成时发送一个信号，用于 <code>getData()</code> 检测通道是否关闭或阻塞<ul><li>通过函数 <code>close(ch)</code> : 将通道标记为无法通过发送操作 <code>&lt;-</code> 接收更多的值；</li><li>给已经关闭的通道发送或者再次关闭都会导致运行时的 <code>panic</code> .</li><li>在创建一个通道后使用 defer 语句是个不错的办法</li></ul></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">float64</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span></pre></td></tr></table></figure><ol start="2"><li>使用 逗号，ok 操作符：用来检测通道是否被关闭.</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 如果 v 接收到值，ok 为 true</span></pre></td></tr><tr><td data-num="2"></td><td><pre>v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch		</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 通常和 if 语句一起使用: </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">process</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 在 for 循环中接收时，当关闭或者阻塞的时候使用 break:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">break</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">process</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>注意事项</p></blockquote><ol><li><p>在通道迭代器中，两个协程经常是一个阻塞另一个.</p></li><li><p>如果程序工作在多核心的机器上，大部分时间只用到了一个处理器。可以通过使用带缓冲的通道来改善.</p><p>例如：缓冲大小为 100, 迭代器在阻塞之前，至少可以从容器获得 100 个元素.</p><p>​ 如果消费者协程在独立的内核运行，就有可能让协程不会出现阻塞.</p></li><li><p>容器中元素的数量通常是已知的，需要让通道有足够的容量放置所有的元素.</p><p>如此 迭代器就不会阻塞 (尽管消费者协程仍然可能阻塞), 但实际上加倍了迭代容器的内存使用量，</p><p>所以通道的容量需要限制一下最大值.</p></li></ol><h4 id="4-使用-select-切换协程"><a class="anchor" href="#4-使用-select-切换协程">#</a> 4. 使用 select 切换协程</h4><ol><li>从不同并发执行的协程中获取值可以通过关键字 <code>select</code> 来完成，和 <code>switch</code> 控制语句非常相似，也被称作通信开关</li><li><code>select</code> 使用轮询机制监听进入通道的数据，也可以是用通道发送值的时候.</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">case</span> u<span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch1<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	<span class="token operator">...</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">case</span> v<span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch2<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    	<span class="token operator">...</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">default</span><span class="token punctuation">:</span>  <span class="token comment">// 没有准备接收的值</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	<span class="token operator">...</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li><p><code>default</code> 语句是可选的； <code>fallthrough</code> 行为，和普通的 <code>Switch</code> 相似，是不允许的.</p><p>在任何一个 <code>case</code> 中执行 <code>break</code> 或者 <code>return</code> , select 就结束了.</p></li><li><p>select 做的就是：选择处理列出的多个通信情况中的一个</p><ul><li><p>如果都阻塞了，会等待其中一个可以处理</p></li><li><p>如果多个可以处理，随机选择一个</p></li><li><p>如果没有通道操作可以处理，并且写了 <code>default</code> 语句，就会执行 <code>default</code> 中的内容</p><p><code>default</code> 永远是可运行的</p></li></ul></li><li><p>在 <code>select</code> 中使用发送操作并且有 <code>default</code> 可以确保发送不被阻塞！如果没有 <code>default</code> ,</p><p><code>select</code> 就会 一直阻塞，select 语句实现了一种监听模式，通常用在 (无限) 循环中；在某种情况下，</p><p>通过 <code>break</code> 语句使循环退出.</p></li></ol><h4 id="5-通道超时和计时器-ticker"><a class="anchor" href="#5-通道超时和计时器-ticker">#</a> 5. 通道，超时和计时器 (Ticker)</h4><blockquote><p>time 包中有一些有趣的功能可以和通道组合使用.</p></blockquote><ol><li><code>time.Ticker</code> 结构体，这个对象以指定的时间间隔重复的向通道 C 发送时间值:</li><li>时间间隔的单位是 ns (纳秒，int64), 在工厂函数 <code>time.NewTicker</code> 中以 <code>Duration</code> 类型的参数传入:</li></ol><p><code>func NewTicker(dur) *Ticker</code></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Ticker <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    C <span class="token operator">&lt;-</span><span class="token keyword">chan</span> Time <span class="token comment">// the channel on which the ticks are delivered.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// contains filtered or unexported fields</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>在协程周期性的执行一些事情 (打印状态日志，输出，计算等等) 的时候非常有用.</li><li>调用 <code>Stop()</code> 使计时器停止，在 <code>defer</code> 语句中使用，都很好的适应 <code>select</code> 语句:</li></ol><figure class="highlight go"><figcaption data-lang="go"><span>o</span></figcaption><table><tr><td data-num="1"></td><td><pre>ticker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>updateInterval<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">defer</span> ticker<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">...</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">case</span> u<span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">case</span> v<span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">case</span> <span class="token operator">&lt;-</span>ticker<span class="token punctuation">.</span>C<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">logState</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token comment">// call some logging function logState</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token comment">// no value ready to be received</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token operator">...</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="5"><li><p><code>time.Tick()</code> 函数声明为 <code>Tick(d Duration) &lt;- chan Time</code> ,</p><p>当想返回一个通道而不必关闭的时候非常有用：以 d 为周期给返回的通道发送时间，d 是纳秒数.</p><p>如果需要如下代码一样，限制处理频率 ( <code>函数 client.Call() 是一个ROC 调用</code> )</p></li></ol><p>这样只会按照指定频率处理请求: <code>chRate</code> 阻塞了更高的频率。每秒处理的频率可以根据机器负载 (和 / 或) 资源的情况变化</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> <span class="token string">"time"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>rate_per_sec <span class="token operator">:=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">var</span> dur Duration <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">/</span> rate_per_sec</pre></td></tr><tr><td data-num="4"></td><td><pre>chRate <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span>dur<span class="token punctuation">)</span> <span class="token comment">// a tick every 1/10th of a second</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> req <span class="token operator">:=</span> <span class="token keyword">range</span> requests <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">&lt;-</span> chRate <span class="token comment">// rate limit our Service.Method RPC calls</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">go</span> client<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"Service.Method"</span><span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="6"><li>定时器 ( <code>Timer</code> ) 结构体与 ( <code>Ticker</code> ) 结构体很像 ( <code>NewTimer(d Duration)</code> ), 但是它只发送一次时间，在 <code>Dration d</code> 之后</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* time.After (d) 函数声明如下:</pre></td></tr><tr><td data-num="3"></td><td><pre>* 在 Duration d 之后，当前时间被发送到返回的通道，与 NewTimer (d).C 等价 类似 Tick ()</pre></td></tr><tr><td data-num="4"></td><td><pre>* 但是 After () 只发送一次时间</pre></td></tr><tr><td data-num="5"></td><td><pre>*/</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">After</span><span class="token punctuation">(</span>d Duration<span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> Time</pre></td></tr></table></figure><ul><li>在 <code>Duration d</code> 之后，当前时间被发到返回的通道；所以和 <code>NewTimer(d).c</code> 是等价的</li><li>类似 <code>Tick</code> , 但是 <code>After()</code> 只发送一次时间.</li></ul><blockquote><p>习惯用法：简单超时模式</p></blockquote><p>从通道 <code>ch</code> 中接收数据，但是最多等待 1 秒.</p><p>先创建一个信号通道。然后启动一个 <code>lambda</code> 协程，协程在发送数据前是休眠的:</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>timeout <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1e9</span><span class="token punctuation">)</span> <span class="token comment">// 休眠一秒</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    timeout <span class="token operator">&lt;-</span> <span class="token boolean">true</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>然后使用 <code>select</code> 语句接收 <code>ch</code> 或 <code>timeout</code> 的数据:</p><p>如果 <code>ch</code> 在 1 秒内没有收到数据，就选择到了 <code>time</code> 分支并放弃了 <code>ch</code> 的读取</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	<span class="token comment">// 一次从 ch 通道的读取已经发生</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>timeout<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    	<span class="token comment">// 从 ch 中读取超时</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    	<span class="token keyword">break</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>第二种形式：取消耗时很长的同步调用</p></blockquote><p>可以使用 <code>time.After()</code> 函数替换 <code>timeout-channel</code> .</p><p>在 <code>select</code> 中通过 <code>time.After()</code> 发送超时信号来停止协程的执行.</p><p><code>timeoutNs</code> 纳秒后执行 <code>select</code> 的 <code>timeout</code> 分支，执行 <code>client.Call</code> 的协程也随之结束，不会给通道 <code>ch</code> 返回值</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">error</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">&lt;-</span> client<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"Service.Method"</span><span class="token punctuation">,</span>args<span class="token punctuation">,</span><span class="token operator">&amp;</span>reply<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">case</span> resp <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch</pre></td></tr><tr><td data-num="5"></td><td><pre>    	<span class="token comment">// 使用接收值并回复</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span> time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>timeoutNs<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    	<span class="token comment">// call time out</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    	<span class="token keyword">break</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>缓冲区大小设置为 1, 避免协程死锁以及确保超时的通道可以被垃圾回收</p></blockquote><p>有多个 <code>case</code> 符合条件时，select 对 case 的选择是伪随机的，在代码中稍作修改</p><p>则 <code>select</code> 语句可能不会在定时器超时信号到来时立刻选中 <code>time.After(timeoutNs)</code> 对应的 <code>case</code></p><p>因此协程可能不会严格按照定时器设置的时间结束</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">&lt;-</span> <span class="token number">1</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>L<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        	<span class="token operator">...</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>timeoutNs<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        	<span class="token comment">// call timed out</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        	<span class="token keyword">break</span> L</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>第三种形式：程序从多个复制的数据库中同时读取。只需要一个答案，需要接收首先到达的答案</p></blockquote><p><code>Query</code> 函数获取数据库的连接切片并请求。并行请求每一个数据库并返回收到的第一个响应:</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">Query</span><span class="token punctuation">(</span>conns <span class="token punctuation">[</span><span class="token punctuation">]</span>Conn<span class="token punctuation">,</span> query <span class="token builtin">string</span><span class="token punctuation">)</span> Result <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Result<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> conn <span class="token operator">:=</span> <span class="token keyword">range</span> conns <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c Conn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> c<span class="token punctuation">.</span><span class="token function">DoQuery</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">default</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">&lt;-</span> ch</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>结果通道 ch 必须是带缓冲的</mark>:</p><p>​	保证第一个发送进来的数据有地方可以存放，确保放入的首个数据总会成功</p><p>​	第一个到达的值会被获取而与执行的顺序无关。正在执行的协程总是可以使用 <code>runtime.Goexit()</code> 来停止.</p><p><mark>在应用中缓存数据</mark>:</p><p>​	应用程序中用到了来自数据库 (或者常见的数据存储) 的数据时，经常会将数据缓存到内存中，</p><p>​	从数据库中获取数据的操作代价很高；如果数据库中的值不发生变化就没有问题.</p><p>​	如果值有变化，则需要一个周期性的从数据库重新读取这些值，缓存值就 (过期) 了</p><h4 id="6协程和恢复-recover"><a class="anchor" href="#6协程和恢复-recover">#</a> 6. 协程和恢复 (recover)</h4><p>用到 <code>recover</code> 的程序，停掉服务器内部的一个失败协程而不影响其他协程的工作.</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span>workChan <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token operator">*</span>Work<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> work <span class="token operator">:=</span> <span class="token keyword">range</span> workChan <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">go</span> <span class="token function">safelyDo</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span> <span class="token comment">// 启动一个工作协程</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">func</span> <span class="token function">safelyDo</span><span class="token punctuation">(</span>work <span class="token operator">*</span>Work<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Work failed with %s in %v"</span><span class="token punctuation">,</span>err<span class="token punctuation">,</span>work<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">do</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><p>如果 <code>do(work)</code> 发生 panic, 错误会被记录且协程会推出并释放而其他协程不受影响.</p></li><li><p><code>recover</code> 总是返回 <code>nil</code> , 除非直接在 defer 修饰的函数中调用</p></li><li><p>defer 修饰的代码可以调用自身可以使用 panic 和 recover 避免失败的库例程 (库函数)</p></li></ul><blockquote><p>案例</p></blockquote><ul><li><code>safelyDo()</code> 中 defer 修饰的函数可能在调用 recover 之前就调用了一个 logging 函数，</li><li><code>panicking</code> 状态不回影响 <code>logging</code> 代码的运行。因为加入了恢复模式</li><li>函数 <code>do</code> (以及其调用的任何东西) 可以通过调用 <code>panic</code> 来摆脱不好的情况</li><li>但是恢复在 <code>panicking</code> 的协程内部的：不能被另一个协程恢复</li></ul><h4 id="7任务和worker-新旧模型对比"><a class="anchor" href="#7任务和worker-新旧模型对比">#</a> 7. 任务和 worker (新旧模型对比)</h4><ol><li>当需要处理很多任务；一个 worker 处理一项任务。任务可以被定义为一个结构体</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Task <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token comment">// some state</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="2"><li>旧模式：使用内存共享进行同步</li></ol><ul><li>由各个任务组成的任务池共享内存；为同步各个 worker 以及避免资源竞争，需要对任务池进行加锁保护:</li><li><mark>sync.Mutex (互斥锁)</mark>: 用来在代码中保护临界区资源，<ul><li>同一时间只有一个 go 协程 (goroutine) 可以进入该临界区.</li><li>如果出现同一时间多个 go 协程进入该临界区，则会产生竞争: Pool 结构就无法保证被正确更新</li></ul></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Pool <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    Mu		sync<span class="token punctuation">.</span>Mutex</pre></td></tr><tr><td data-num="3"></td><td><pre>    Tasks	<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Task</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>传统模式中的 Worker 代码<ul><li>这些 worker 有许多可以保证并发执行，其可以在 go 协程中启动.</li><li>一个 worker 先将 pool 锁定，从 pool 获取第一项任务，再解锁和处理任务.</li><li>加锁保证了同一时间只有一个 go 协程可以进入 pool 中：一项任务有且只能被赋予一个 worker</li><li>如果不加锁，则工作协程可能会在 <code>task := pool.Tasls[0]</code> 发生切换，</li><li>导致 <code>pool.Tasks=pool.Tasks[1:]</code> 结果异常，及一些 worker 获取不到任务，而一些任务可能被多个 worker 得到.</li><li>加锁实现同步的方式在工作协程比较少时可以工作的很好，但是工作协程数量大，任务很多时，处理效率将会因为频繁的加锁 / 解锁开销而降低.</li><li>当工作协程数增加到一个阈值时，程序效率会急剧下降，这就成为了瓶颈</li></ul></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">Worker</span><span class="token punctuation">(</span>pool <span class="token operator">*</span>Pool<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        pool<span class="token punctuation">.</span>Mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// begin critical section:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        task <span class="token operator">:=</span> pool<span class="token punctuation">.</span>Tasks<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>	<span class="token comment">//take the first task 执行第一个任务</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        pool<span class="token punctuation">.</span>Tasks <span class="token operator">=</span> pool<span class="token punctuation">.</span>Tasks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>	<span class="token comment">//update the pool of tasks 更新池中的任务</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// end critical section</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        pool<span class="token punctuation">.</span>Mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">process</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>新模式：使用通道</li></ol><ul><li>使用通道进行同步：使用一个通道接收需要处理的任务，一个通道接收处理完成的任务 (及其结果)</li><li>worker 在协程中启动，其数量 N 应该根据任务数量进行调整.</li></ul><p>主线程扮演着 <code>Master节点角色</code> ，可写成如下形式:</p><ul><li>这里并不使用锁：从通道得到新任务的过程中没有任何竞争.</li><li>随着任务数量增加，worker 数量也相应增加，同时性能不回像第一种方式那样下降明显.</li><li>在 <mark>pending 通道</mark>中存在一份任务的<mark>拷贝</mark>，第一个 worker 从 pending 通道中获取第一个任务并进行处理</li><li>这里并不存在竞争 (对一个通道读取数据和写数据的整个过程是原子性的)</li><li>某一个任务在哪一个 worker 中执行是不可知的，worker 数量的增多也会增加通信的开销，这会对性能有轻微影响</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    pending<span class="token punctuation">,</span> done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Task<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">sendWork</span><span class="token punctuation">(</span>pending<span class="token punctuation">)</span>		<span class="token comment">// put task with work on the channel</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>	<span class="token comment">// start N goroutines to do work</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">go</span> <span class="token function">Worker</span><span class="token punctuation">(</span>pending<span class="token punctuation">,</span> done<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">consumeWork</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>			<span class="token comment">// continue with the processed tasks</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">//worker 的逻辑：从 pending 通道拿任务，处理后将其放到 done 通道中</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">func</span> <span class="token function">Worker</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span>ouyt <span class="token keyword">chan</span> <span class="token operator">*</span>Task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        t <span class="token operator">:=</span> <span class="token operator">&lt;-</span>in</pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">process</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        out <span class="token operator">&lt;-</span> t</pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于任何可以建模为 Master-Worker 范例的问题:</p><ul><li>一个类似于 worker 使用通道进行通信和交互，Master 进行整体协调的方案都能完美解决.</li><li>如果系统部署在多台机器上，各个机器上执行 Worker 协程，Master 和 Worker 之间使用 netchan 或者 RPC 进行通信</li></ul><p><mark>通道和锁的应用场景 :</mark></p><ul><li>使用锁的情景:<ul><li>访问共享数据结构中的缓存信息</li><li>保存应用程序上下文和状态信息数据</li></ul></li><li>使用通道的场景:<ul><li>与异步操作的结果进行交互</li><li>分发任务</li><li>传递数据所有权</li></ul></li></ul><h4 id="8惰性生成器的实现"><a class="anchor" href="#8惰性生成器的实现">#</a> 8. 惰性生成器的实现</h4><p>生成器是指被调用时返回一个序列中下一个值的函数，例如:</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">generateInterger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">generateInterger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">generateInterger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">...</span></pre></td></tr></table></figure><p>生成器每次返回的是序列中下一个值而非整个序列；这种特性也被称之为惰性求值:</p><ul><li>只在需要时进行求值，同时保留相关变量资源 (内存和 CPU), 是一项在需要时对表达式进行求值的技术</li><li>生成一个无限数量的偶数序列：要产生这样一个序列并且一个个的使用可能会很困难，而且内存会溢出，但是含有通道的 go 协程的函数能轻易实现这个需求.</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> resume <span class="token keyword">chan</span> <span class="token builtin">int</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">integers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    yield <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    count <span class="token operator">:=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            yield <span class="token operator">&lt;-</span> count</pre></td></tr><tr><td data-num="8"></td><td><pre>            count<span class="token operator">++</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> yield</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">func</span> <span class="token function">generateInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">&lt;-</span>resume</pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    resume <span class="token operator">=</span> <span class="token function">integers</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">generateInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//=> 0</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">generateInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//=> 1</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">generateInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//=> 2    </span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>从通道读取的值可能会是稍早产生的，并不是在程序被调用时生成的。如果确实需要这样的行为，就需要实现一个请求响应机制.</li><li>当生成器生成数据的过程是计算密集型且各个结果的顺序并不重要时，可以将生成器放入到 go 协程实现并行化</li><li>使用大量的 go 协程的开销可能会超过带来的性能增益</li></ul><p><mark>使用原则 :</mark></p><ol><li>通过巧妙地使用空接口，闭包和高阶函数，实现一个通用的惰性生产器的工厂函数 <code>BuildLazyEvakuator</code></li><li>工厂函数需要一个函数和初始状态作为输入参数，返回一个无参，返回值是生成序列的函数</li><li>传入的函数需要计算出下一个返回值以及下一个状态参数.</li><li>在工厂函数中创建一个通道和无限循环的 go 协程，返回值被放入该通道中，返回函数稍后被调用时从该通道中取得该返回值。每当取得一个值时，下一个值即被计算.</li></ol><h4 id="9实现-futuress-模式"><a class="anchor" href="#9实现-futuress-模式">#</a> 9. 实现 Futuress 模式</h4><p>Futures 模式：</p><ul><li>有时候需要在某一个值之前先对其进行计算.</li><li>可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕了</li></ul><p>Futures 模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于 Futures 需要返回一个值.</p><p><mark>参考案例</mark>:</p><ul><li>假设有一个矩阵类型，需要计算两个矩阵 A 和 B 乘积的逆</li><li>首先通过函数 <code>Inverse(M)</code> 分别对其进行求逆运算，再将结果相乘</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">InverseProduct</span><span class="token punctuation">(</span>a Matrix<span class="token punctuation">,</span> b Matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    a_inv <span class="token operator">:=</span> <span class="token function">Inverse</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    b_inv <span class="token operator">:=</span> <span class="token function">Inverse</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">Product</span><span class="token punctuation">(</span>a_inv<span class="token punctuation">,</span> b_inv<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>a 和 b 的求逆矩阵需要先被计算.</li><li>调用 <code>Product</code> 函数只需要等到 <code>a_inv</code> 和 <code>b_inv</code> 的计算完成</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">InverseProduct</span><span class="token punctuation">(</span>a Matrix<span class="token punctuation">,</span> b Matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    a_inv_future <span class="token operator">:=</span> <span class="token function">InverseFuture</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> 	<span class="token comment">// 启动一个协程</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    b_inv_future <span class="token operator">:=</span> <span class="token function">InverseFuture</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    a_inv <span class="token operator">:=</span> <span class="token operator">&lt;-</span> a_inv_future</pre></td></tr><tr><td data-num="5"></td><td><pre>    b_inv <span class="token operator">:=</span> <span class="token operator">&lt;-</span> b_inv_future</pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">Product</span><span class="token punctuation">(</span>a_inv<span class="token punctuation">,</span> b_inv<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><code>InverseFuture</code> 函数以 <code>goroutine</code> 的形式起了一个闭包，该闭包会将矩阵求逆结果放入到 future 通道中:</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">IncerseFuture</span><span class="token punctuation">(</span>a Matrix<span class="token punctuation">)</span> <span class="token keyword">chan</span> Matrix <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    future <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Matrix<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        future <span class="token operator">&lt;-</span> <span class="token function">Inverse</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> future</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>当开发一个计算密集型库时，Futures 模式设计 API 接口是很有意义的.</li><li>在包中使用 Futures 模式，且能保持友好的 API 接口</li><li>Futures 可以通过一个异步的 API 暴露出来。可以以最小的成本将包中的并行计算移动到用户代码中</li></ul><h4 id="10复用"><a class="anchor" href="#10复用">#</a> 10. 复用</h4><blockquote><p>客户端 / 服务器 (C/S) 模式</p></blockquote><ol><li><p>客户端 - 服务器应用是 <code>goroutines</code> 和 <code>channels</code> 的亮点所在.</p></li><li><p>客户端 (Client) 可以是运行在任意设备上的任意程序，会按需求请求 (request) 至服务器</p></li><li><p>服务器 (Server) 接收到请求后开始响应的工作，然后将响应 (response) 返回给客户端</p></li><li><p>一般是多个客户端 (即多个请求) 对应一个 (或少量) 服务器</p></li></ol><blockquote><p>使用 Go 的服务器通常会在协程中执行向客户端的响应，故而会对每一个客户端请求启动一个协程.</p><p>一个常用的操作方法是客户端请求自身中包含一个通道，而服务器则向这个通道发送响应.</p></blockquote><p>例: <code>Request</code> 结构，其中内嵌了一个 <code>replyc</code> 通道.</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	a<span class="token punctuation">,</span> b	<span class="token builtin">int</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    replyc	<span class="token keyword">chan</span> <span class="token builtin">int</span>	<span class="token comment">// reply channel inside the Request</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 更通俗的形式</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">type</span> Reply <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> arg3 some_type</pre></td></tr><tr><td data-num="10"></td><td><pre>    replyc <span class="token keyword">chan</span> <span class="token operator">*</span>Reply</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>简单形式：服务器会为每一个请求启动一个协程并在其中执行 <code>run()</code> 函数，此类型会将类型为 <code>binOp</code> 的 <code>op</code></p><p>操作返回的 int 值发送到 <code>replyc</code> 通道.</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> binOp <span class="token keyword">func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">func</span> <span class="token function">run</span><span class="token punctuation">(</span>op binOp<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    req<span class="token punctuation">.</span>replyc <span class="token operator">&lt;-</span> <span class="token function">op</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>a<span class="token punctuation">,</span> req<span class="token punctuation">.</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>server</code> 协程会无限循环以从 <code>chan *Request</code> 接收请求，并且为避免被长时间操作堵塞，将为每一个请求启动</p><p>一个协程来做具体的工作:</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span>op binOp<span class="token punctuation">,</span> service <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        req <span class="token operator">:=</span> <span class="token operator">&lt;-</span>service	<span class="token comment">// request arrive here</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// start goroutine for request:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">go</span> <span class="token function">run</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> req<span class="token punctuation">)</span>		<span class="token comment">// 无需等待 op 执行完成</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>server</code> 本身以协程的方式在 <code>startServer</code> 函数中启动:</p><p><code>startServer</code> 则会在 <code>main</code> 协程中被调用.</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">startServer</span><span class="token punctuation">(</span>op binOp<span class="token punctuation">)</span> <span class="token keyword">chan</span> <span class="token operator">*</span>Request <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    reChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">server</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> reqChan<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> reqChan</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>测试案例: 100 个请求会被发送到服务器，只有全部被送达后才会按照相反的顺序检查响应</p><p>(程序仅启动了 100 个协程，然而即使执行 100,000 个协程也能在数秒内完成，Go 协程的轻量)</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    adder <span class="token operator">:=</span> <span class="token function">startServer</span><span class="token punctuation">(</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">const</span> N <span class="token operator">=</span> <span class="token number">100</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">var</span> reqs <span class="token punctuation">[</span>N<span class="token punctuation">]</span>Request</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        req <span class="token operator">:=</span> <span class="token operator">&amp;</span>reqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        req<span class="token punctuation">.</span>a <span class="token operator">=</span> i</pre></td></tr><tr><td data-num="8"></td><td><pre>        req<span class="token punctuation">.</span>b <span class="token operator">=</span> i <span class="token operator">+</span> N</pre></td></tr><tr><td data-num="9"></td><td><pre>        req<span class="token punctuation">.</span>replyc <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        adder <span class="token operator">&lt;-</span> req	<span class="token comment">// adder is a channel of request</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// checks:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// doesn't matter what order</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">if</span> <span class="token operator">&lt;-</span> reqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>replyc <span class="token operator">!=</span> N<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>i <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fail at"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Request"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">"is ok !"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span>    </pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">// 输出:</span></pre></td></tr><tr><td data-num="24"></td><td><pre>Request <span class="token number">99</span> is ok<span class="token operator">!</span></pre></td></tr><tr><td data-num="25"></td><td><pre>Request <span class="token number">99</span> is ok<span class="token operator">!</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token operator">...</span></pre></td></tr><tr><td data-num="27"></td><td><pre>Request <span class="token number">99</span> is ok<span class="token operator">!</span></pre></td></tr><tr><td data-num="28"></td><td><pre>Request <span class="token number">99</span> is ok<span class="token operator">!</span></pre></td></tr><tr><td data-num="29"></td><td><pre>done</pre></td></tr></table></figure><blockquote><p>卸载 (Teardown) : 通过信号通道关闭服务器</p></blockquote><p>上个版本中 <code>server</code> 在 <code>main</code> 函数返回后并没有完全关闭，而被强制结束了.</p><p>改进：提供一个退出通道给 <code>server</code></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">startServer</span><span class="token punctuation">(</span>op binOp<span class="token punctuation">)</span> <span class="token punctuation">(</span>service <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">,</span> quit <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    service <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    quit <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">server</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> service<span class="token punctuation">,</span> quit<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> service<span class="token punctuation">,</span> quit</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>server</code> 函数现在则使用 <code>select</code> 在 <code>service</code> 通道和 <code>quit</code> 通道之间做出选择:</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span>op binOp<span class="token punctuation">,</span> service <span class="token keyword">chan</span> <span class="token operator">*</span>request<span class="token punctuation">,</span> quit <span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">case</span> req <span class="token operator">:=</span> <span class="token operator">&lt;-</span> service<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            	<span class="token keyword">go</span> <span class="token function">run</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span>req<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>quit<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            	<span class="token keyword">return</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当 <code>quit</code> 通道接收到 <code>true</code> 值时， <code>server</code> 就会返回并结束.</p><p>在 <code>main</code> 函数中做出如下更改:</p><p>在 <code>main</code> 函数的结尾处放入: <code>quit &lt;- true</code></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>adder<span class="token punctuation">,</span> quite <span class="token operator">:=</span> <span class="token function">startServer</span><span class="token punctuation">(</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="11-限制同时处理的请求数"><a class="anchor" href="#11-限制同时处理的请求数">#</a> 11. 限制同时处理的请求数</h4><ol><li><p>使用带缓冲区的通道很容易实现这一点，其缓冲区容量就是同时处理请求的最大数量.</p></li><li><p>超过 <code>MAXREQS</code> 的请求将不会被同时处理，当信号通道表示缓冲去已满是 <code>handle</code> 函数将不会阻塞</p><p>且不在处理其他请求，直到某个请求从 <code>sem</code> 中被溢出.</p></li><li><p><code>sem</code> 就像一个信号量，(程序中表示特定条件的标志量)</p></li><li><p>应用程序可以通过使用缓冲通道 (通道被用作信号量) 使协程同步其对该资源的使用，从而充分利用优先资源</p></li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> MAXREQS <span class="token operator">=</span> <span class="token number">50</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">var</span> sem <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> MAXREQS<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    a<span class="token punctuation">,</span>b <span class="token builtin">int</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    replyc <span class="token keyword">chan</span> <span class="token builtin">int</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// do something</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">func</span> <span class="token function">handle</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    sem <span class="token operator">&lt;-</span><span class="token number">1</span> <span class="token comment">// doesn't matter what we put in it</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">process</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token operator">&lt;-</span> sem  <span class="token comment">// one empty place in the buffer: the next request can start</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span>service <span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        request <span class="token operator">:=</span> <span class="token operator">&lt;-</span> service</pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">go</span> <span class="token function">handle</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    service <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">server</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="12链式协程"><a class="anchor" href="#12链式协程">#</a> 12. 链式协程</h4><p><mark>演示案例 :</mark></p><p>​	chaining.go 展示了启动巨量的 Go 协程时多么容易，协程已全部在 main 函数中的 for 循环里启动。当循环完成后，</p><p>一个 0 被写入到最右边的通道里，于是 100,000 个协程开始执行，接着所有结果会在 1.5 秒内被打印出来</p><ul><li>主线程的 right &lt;- 0, right 不是最初循环的那个 right, 而是最终循环的 right</li><li>for 循环中最初的 go f (left,right) 因为没有发送者一直出于等待状态</li><li>当主线程的 right &lt;- 0 执行时，类似于递归函数在最内层产生返回值一般</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token string">"flag"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">"fmt"</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">var</span> ngoroutine <span class="token operator">=</span> flag<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"how many goroutines"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>left <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token operator">&lt;-</span>right<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    leftmost <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">var</span> left<span class="token punctuation">,</span> right <span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> leftmost</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token operator">*</span>ngoroutine<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> right<span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">go</span> <span class="token function">f</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre>    right <span class="token operator">&lt;-</span> <span class="token number">0</span> 		<span class="token comment">// bang!</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>leftmost	<span class="token comment">// wait for completion</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>	<span class="token comment">// 100000, ongeveer 1,5 s</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    </pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="13-在多核心上并行计算"><a class="anchor" href="#13-在多核心上并行计算">#</a> 13. 在多核心上并行计算</h4><p><mark>(经典信号量模式) 案例:</mark></p><p><mark>运行时需将 GOMAXPROCS 设置为 NCPU</mark></p><p>假设有 <code>NCPU</code> 个 CPU 核心: <code>const NCPU = 4 //对应一个四核处理器</code> ，</p><p>目标：将计算量分成 <code>NCPU</code> 个部分，没一个部分都和其他部分并行运行.</p><ul><li><p><code>DoAll()</code> 函数创建了一个 <code>sem</code> 通道，每个并行计算都将在其发送完成信号，在 for 循环中 <code>NCPU</code> 个协程被</p><p>启动了，每个协程会承担 <code>1/NCPU</code> 的工作量。每一个 <code>DoPart()</code> 协程都会向 <code>sem</code> 通道发送完成信号.</p></li><li><p><code>DoAll()</code> 会在 for 循环中等待 <code>NCPU</code> 个协程完成: <code>sem</code> 通道就像一个信号量，</p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">DoAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    sem <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> NCPU<span class="token punctuation">)</span> <span class="token comment">// Buffering optional but sensible</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NCPU<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">go</span> <span class="token function">DoPart</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// Drain the channel sem, waiting for NCPU tasks to complete</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NCPU<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token operator">&lt;-</span>sem <span class="token comment">// wait for one task to complete</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// All done.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">func</span> <span class="token function">DoPart</span><span class="token punctuation">(</span>sem <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// do the part of the computation</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    sem <span class="token operator">&lt;-</span><span class="token number">1</span> <span class="token comment">// signal that this piece is done</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span>NCPU<span class="token punctuation">)</span> <span class="token comment">// runtime.GOMAXPROCS = NCPU</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">DoAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="14-并行化大量数据的计算"><a class="anchor" href="#14-并行化大量数据的计算">#</a> 14. 并行化大量数据的计算</h4><p>使用场景：处理数量巨大且互不相关的数据项，它们从一个 <code>in</code> 通道被传递进来，当处理完成后将其放入 <code>out</code> 通道</p><p>处理流程: Prepocess (预处理) / StepA (步骤 A) / StepB (步骤 B) /.../ PostProcess (后处理)</p><ul><li>一个用于解决按顺序执行每个步骤的顺序流水线算法如下:</li><li>一次只执行一个步骤，且按照顺序处理，在项目没有被 <code>PostProcess</code> 且放入 <code>out</code> 通道之前不会处理下一个项目</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">SerialProcessData</span><span class="token punctuation">(</span>in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token operator">*</span>Data<span class="token punctuation">,</span>out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token operator">*</span>Data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> data <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        tempA <span class="token operator">:=</span> <span class="token function">PreprocessData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        tempB <span class="token operator">:=</span> <span class="token function">ProcessSetpA</span><span class="token punctuation">(</span>tempA<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        tempc <span class="token operator">:=</span> <span class="token function">ProcessSetpB</span><span class="token punctuation">(</span>tempB<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        out <span class="token operator">&lt;-</span> <span class="token function">PostProcessData</span><span class="token punctuation">(</span>tmpC<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>更高效的计算方式：让每一个处理步骤作为一个协程独立工作。每一个步骤从上一步的输出通道中获得输入数据</li><li>这种方式仅有极少数时间会被浪费，而大部分时间所有步骤都一直在执行中</li><li>调整通道的缓冲区大小可进一步优化整个过程</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> ParallelProcessData <span class="token punctuation">(</span>in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token operator">*</span>Data<span class="token punctuation">,</span> out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token operator">*</span>Data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// make channels:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    preOut <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Data<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    stepAOut <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Data<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    stepBOut <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Data<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    stepCOut <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Data<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// start parallel computations:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">PreprocessData</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> preOut<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">ProcessStepA</span><span class="token punctuation">(</span>preOut<span class="token punctuation">,</span>StepAOut<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">ProcessStepB</span><span class="token punctuation">(</span>StepAOut<span class="token punctuation">,</span>StepBOut<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">ProcessStepC</span><span class="token punctuation">(</span>StepBOut<span class="token punctuation">,</span>StepCOut<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">go</span> <span class="token function">PostProcessData</span><span class="token punctuation">(</span>StepCOut<span class="token punctuation">,</span>out<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="15漏桶算法"><a class="anchor" href="#15漏桶算法">#</a> 15. 漏桶算法</h4><p>客户端 - 服务器结构:</p><ol><li>客户端协程执行一个无限循环从某个源头 (也许是网络) 接收数据；数据读取到 <code>Buffer</code> 类型的缓冲区.</li></ol><p>为避免分配过多的缓冲区以及释放缓冲区，保留一份空闲缓冲区列表，并且使用一个缓冲通道来表示此列表: <code>var freelist = make(chan *Buffer,100)</code></p><ol start="2"><li>这个可重用的缓冲区队列 (freeList) 与服务器是共享的。当接收数据时，客户端尝试从 <code>freeList</code></li></ol><p>获取缓冲区；如果此时通道为空，则会分配新的缓冲区。一旦消息被加载后，将被发送到服务器的 <code>serverChan</code></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> serverChan <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Buffer<span class="token punctuation">)</span></pre></td></tr></table></figure><p>客户端算法代码:</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">var</span> b <span class="token operator">*</span>Buffer</pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// Grab a buffer if available; allocate if not</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">case</span> b <span class="token operator">=</span> <span class="token operator">&lt;-</span> freeList<span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>            	<span class="token comment">// Got one; nothing more to do</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">default</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            	<span class="token comment">// None free, so allocate a new one</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            b <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">loadInto</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>				<span class="token comment">// Read next message from the network</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        serverChan <span class="token operator">&lt;-</span> b			<span class="token comment">// Send to server</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>服务器循环接收来自客户端的信息并处理，然后尝试将缓冲区返回给共享的空闲缓冲区:</p><ul><li>此方法在 <code>freeList</code> 通道已满时，无法放入空闲 <code>freeList</code> 通道缓冲区会被抛弃由垃圾收集器回收</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        b <span class="token operator">:=</span> <span class="token operator">&lt;-</span>serverChan		<span class="token comment">// wait for work</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">process</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// Reuse buffer if three's room</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">case</span> freeList <span class="token operator">&lt;-</span> b<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            	<span class="token comment">// Reuse buffer is free slot on freeList; nothing more to do</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">default</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>           	 	<span class="token comment">// Free list full, just carry on : the buffer is 'dropped'</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="16使用通道并发访问对象"><a class="anchor" href="#16使用通道并发访问对象">#</a> 16. 使用通道并发访问对象</h4><ol><li>为了保护对象被并发访问修改，可以使用协程在后台顺序执行匿名函数来替代使用同步互斥锁.</li><li>如下案例中有一个类型 <code>Person</code> 其中包含一个字段 <code>chF</code> , 这是一个用于存放匿名函数的通道.</li><li>这个结构在构造函数 <code>NewPerson()</code> 中初始化的同时会启动一个后台协程 <code>backend</code> .</li><li><code>backend</code> 方法会在一个无限循环中执行 <code>chF</code> 中放置的所有函数，有效的将其序列化从而提供安全的并发访问</li><li>更改和读取 <code>salary</code> 方法会通过将一个匿名函数写入 <code>chF</code> 通道中，然后 <code>backend()</code> 按顺序执行</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token string">"fmt"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">"strconv"</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    Name   <span class="token builtin">string</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    salary <span class="token builtin">float64</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    chF    <span class="token keyword">chan</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">func</span> <span class="token function">NewPerson</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> salary <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token operator">*</span>Person <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    p <span class="token operator">:=</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">&#123;</span>name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">go</span> p<span class="token punctuation">.</span><span class="token function">backend</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> p</pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">backend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">for</span> f <span class="token operator">:=</span> <span class="token keyword">range</span> p<span class="token punctuation">.</span>chF <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// Set salary.</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">SetSalary</span><span class="token punctuation">(</span>sal <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    p<span class="token punctuation">.</span>chF <span class="token operator">&lt;-</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> p<span class="token punctuation">.</span>salary <span class="token operator">=</span> sal <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">// Retrieve salary.</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">Salary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    fChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">float64</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    p<span class="token punctuation">.</span>chF <span class="token operator">&lt;-</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> fChan <span class="token operator">&lt;-</span> p<span class="token punctuation">.</span>salary <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">&lt;-</span>fChan</pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">return</span> <span class="token string">"Person - name is: "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>Name <span class="token operator">+</span> <span class="token string">" - salary is: "</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">FormatFloat</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">Salary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'f'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    bs <span class="token operator">:=</span> <span class="token function">NewPerson</span><span class="token punctuation">(</span><span class="token string">"Smith Bill"</span><span class="token punctuation">,</span> <span class="token number">2500.5</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    bs<span class="token punctuation">.</span><span class="token function">SetSalary</span><span class="token punctuation">(</span><span class="token number">4000.25</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Salary changed:"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token comment">// 输出</span></pre></td></tr><tr><td data-num="43"></td><td><pre>Person <span class="token operator">-</span> name is<span class="token punctuation">:</span> Smith Bill <span class="token operator">-</span> salary is<span class="token punctuation">:</span> <span class="token number">2500.50</span></pre></td></tr><tr><td data-num="44"></td><td><pre>Salary changed<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="45"></td><td><pre>Person <span class="token operator">-</span> name is<span class="token punctuation">:</span> Smith Bill <span class="token operator">-</span> salary is<span class="token punctuation">:</span> <span class="token number">4000.25</span></pre></td></tr></table></figure><div class="tags"><a href="/tags/GoLang/" rel="tag"><i class="ic i-tag"></i> GoLang</a> <a href="/tags/Go%E6%A0%87%E5%87%86%E5%BA%93/" rel="tag"><i class="ic i-tag"></i> Go标准库</a> <a href="/tags/goroutine/" rel="tag"><i class="ic i-tag"></i> goroutine</a> <a href="/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/" rel="tag"><i class="ic i-tag"></i> 文件读写</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-06-30 14:44:07" itemprop="dateModified" datetime="2022-06-30T14:44:07+08:00">2022-06-30</time> </span><span id="2022/06/29/GoLang/GoLang入门篇(下)/" class="item leancloud_visitors" data-flag-title="GoLang协程与标准库" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>MuBai <i class="ic i-at"><em>@</em></i>源夢</li><li class="link"><strong>本文链接：</strong> <a href="https://proudmubai.github.io/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8B)/" title="GoLang协程与标准库">https://proudmubai.github.io/2022/06/29/GoLang/GoLang入门篇(下)/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/06/29/NodeJs/FrontEnd/webKnowLedge/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevarprfj20zk0m8npd.jpg" title="Http基础知识"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> web前端</span><h3>Http基础知识</h3></a></div><div class="item right"><a href="/2022/06/29/Database/MySQL/NodeQuerySQL/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfdu6exj20zk0m87hw.jpg" title="Mysql非常用语法"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Mysql</span><h3>Mysql非常用语法</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">GoLang 学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1gopackage"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.Go(package)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%A0%87%E5%87%86%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1. 标准库概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2regexp-%E5%8C%85"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">2.regexp 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%94%81%E5%92%8C-sync%E5%8C%85"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">3. 锁和 sync 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%B2%BE%E5%AF%86%E8%AE%A1%E7%AE%97%E5%92%8Cbig%E5%8C%85"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">4. 精密计算和 big 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">5. 自定义包和可见性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%BB%93%E6%9E%84%E4%BD%93struct"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. 结构体 (struct)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">1. 结构体定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%BB%93%E6%9E%84%E4%BD%93%E5%B7%A5%E5%8E%82"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">2. 结构体工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">3. 使用自定义包的结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">4. 带标签的结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E5%92%8C%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">5. 匿名字段和内嵌结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">6. 结构体方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.0.2.6.0.1.</span> <span class="toc-text">1. 定义方法的一般格式 :</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E5%BA%94%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%9F%9F"><span class="toc-number">1.0.2.6.0.2.</span> <span class="toc-text">2. 类型和对应方法的定义域</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.2.6.0.3.</span> <span class="toc-text">3. 函数和方法的区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E6%8C%87%E9%92%88%E6%88%96%E5%80%BC%E4%BD%9C%E4%B8%BA%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">1.0.2.6.0.4.</span> <span class="toc-text">4. 指针或值作为接收者</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E6%96%B9%E6%B3%95%E5%92%8C%E6%9C%AA%E5%AF%BC%E5%87%BA%E5%AD%97%E6%AE%B5"><span class="toc-number">1.0.2.6.0.5.</span> <span class="toc-text">5. 方法和未导出字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E5%86%85%E5%B5%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">1.0.2.6.0.6.</span> <span class="toc-text">6. 内嵌类型的方法和继承</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%8A%9F%E8%83%BD"><span class="toc-number">1.0.2.6.0.7.</span> <span class="toc-text">7. 在类型中嵌入功能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.0.2.6.0.8.</span> <span class="toc-text">8. 多重继承</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D"><span class="toc-number">1.0.2.6.0.9.</span> <span class="toc-text">9. 通用方法和方法命名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#10-go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%85%B6%E4%BB%96%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.2.6.0.10.</span> <span class="toc-text">10. Go 语言的方法和其他面向对象语言比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E7%B1%BB%E5%9E%8B%E7%9A%84string%E6%96%B9%E6%B3%95%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">7. 类型的 String 方法和格式化描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8Csetfinalizer"><span class="toc-number">1.0.2.8.</span> <span class="toc-text">8. 垃圾回收和 SetFinalizer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%8E%A5%E5%8F%A3interface%E4%B8%8E%E5%8F%8D%E5%B0%84reflection"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. 接口 (Interface) 与反射 (Reflection)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">1. 接口的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">2. 接口嵌套接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">3. 类型断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">4. 类型判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%9F%90%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">5. 测试一个值是否实现了某个接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95%E9%9B%86%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.3.6.</span> <span class="toc-text">6. 方法集与接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E4%BD%BF%E7%94%A8-sorter%E6%8E%A5%E5%8F%A3%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.3.7.</span> <span class="toc-text">7. 使用 Sorter 接口排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E8%AF%BB%E5%92%8C%E5%86%99"><span class="toc-number">1.0.3.8.</span> <span class="toc-text">8. 读和写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.3.9.</span> <span class="toc-text">9. 空接口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%88%96%E8%80%85%E5%8C%85%E5%90%AB%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.3.9.0.1.</span> <span class="toc-text">1. 构建通用类型或者包含不同类型变量的数组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%E8%87%B3%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%88%87%E7%89%87"><span class="toc-number">1.0.3.9.0.2.</span> <span class="toc-text">2. 复制数据切片至空接口切片</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%8F%8D%E5%B0%84%E5%8C%85"><span class="toc-number">1.0.3.9.0.3.</span> <span class="toc-text">3. 反射包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E8%AE%BE%E7%BD%AE%E5%80%BC"><span class="toc-number">1.0.3.9.0.4.</span> <span class="toc-text">4. 通过反射修改 (设置) 值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E5%8F%8D%E5%B0%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.3.9.0.5.</span> <span class="toc-text">5. 反射结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10printf%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-number">1.0.3.10.</span> <span class="toc-text">10.Printf 和反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.3.11.</span> <span class="toc-text">11. 接口与动态类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12go%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.3.12.</span> <span class="toc-text">12.Go 中的面向对象</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. 读写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">1. 读取用户的输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">2. 文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.4.2.0.1.</span> <span class="toc-text">1. 读文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.4.2.0.2.</span> <span class="toc-text">2. 写文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">3. 从命令行读取参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-buffer-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">4. buffer 读取文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%87%E7%89%87%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">5. 切片读写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-defer-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.4.6.</span> <span class="toc-text">6. defer 关闭文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B-fmtfprintf"><span class="toc-number">1.0.4.7.</span> <span class="toc-text">7. 接口使用实际案例: fmt.Fprintf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.0.4.8.</span> <span class="toc-text">8. JSON 数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9xml%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.0.4.9.</span> <span class="toc-text">9.XML 数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10gob%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.4.10.</span> <span class="toc-text">10.Gob 传输数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11go-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86"><span class="toc-number">1.0.4.11.</span> <span class="toc-text">11.Go 数据加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">1.0.5.</span> <span class="toc-text">5. 错误处理与测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">1. 错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8Cpanic"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">2. 运行时异常和 panic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%8Epanic-%E4%B8%AD%E6%81%A2%E5%A4%8D-recover"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">3. 从 panic 中恢复 (Recover)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C-panicking"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">4. 自定义包中的错误处理和 panicking</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%97%AD%E5%8C%85%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">4. 闭包处理错误的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%90%AF%E5%8A%A8%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.5.6.</span> <span class="toc-text">5. 启动外部命令和程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-go%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">1.0.5.7.</span> <span class="toc-text">6. Go 中的单元测试和基准测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95-%E5%88%86%E6%9E%90%E5%B9%B6%E4%BC%98%E5%8C%96go%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.5.8.</span> <span class="toc-text">7. 性能调试 (分析并优化 Go 程序)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93"><span class="toc-number">1.0.6.</span> <span class="toc-text">6. 协程与通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">1. 并发，并行和协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%8F%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BF%A1%E9%81%93"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">2. 协程间的信道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5-%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93-%E6%B5%8B%E8%AF%95%E9%98%BB%E5%A1%9E%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">3. 协程的同步：关闭通道 - 测试阻塞的通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-select-%E5%88%87%E6%8D%A2%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">4. 使用 select 切换协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%9A%E9%81%93%E8%B6%85%E6%97%B6%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8-ticker"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">5. 通道，超时和计时器 (Ticker)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E5%8D%8F%E7%A8%8B%E5%92%8C%E6%81%A2%E5%A4%8D-recover"><span class="toc-number">1.0.6.6.</span> <span class="toc-text">6. 协程和恢复 (recover)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E4%BB%BB%E5%8A%A1%E5%92%8Cworker-%E6%96%B0%E6%97%A7%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">1.0.6.7.</span> <span class="toc-text">7. 任务和 worker (新旧模型对比)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E6%83%B0%E6%80%A7%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.6.8.</span> <span class="toc-text">8. 惰性生成器的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E5%AE%9E%E7%8E%B0-futuress-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.6.9.</span> <span class="toc-text">9. 实现 Futuress 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E5%A4%8D%E7%94%A8"><span class="toc-number">1.0.6.10.</span> <span class="toc-text">10. 复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E9%99%90%E5%88%B6%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%E7%9A%84%E8%AF%B7%E6%B1%82%E6%95%B0"><span class="toc-number">1.0.6.11.</span> <span class="toc-text">11. 限制同时处理的请求数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E9%93%BE%E5%BC%8F%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.0.6.12.</span> <span class="toc-text">12. 链式协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%9C%A8%E5%A4%9A%E6%A0%B8%E5%BF%83%E4%B8%8A%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">1.0.6.13.</span> <span class="toc-text">13. 在多核心上并行计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.0.6.14.</span> <span class="toc-text">14. 并行化大量数据的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.6.15.</span> <span class="toc-text">15. 漏桶算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E4%BD%BF%E7%94%A8%E9%80%9A%E9%81%93%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.6.16.</span> <span class="toc-text">16. 使用通道并发访问对象</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8A)/" rel="bookmark" title="GoLang入门学习">GoLang入门学习</a></li><li class="active"><a href="/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8B)/" rel="bookmark" title="GoLang协程与标准库">GoLang协程与标准库</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="MuBai" data-src="/images/avatar.jpg"><p class="name" itemprop="name">MuBai</p><div class="description" itemprop="description">萌新小白 & 学习点滴</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">21</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">27</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Byb3VkTXVCYWk=" title="https:&#x2F;&#x2F;github.com&#x2F;ProudMuBai"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item telegram" data-url="aHR0cHM6Ly90Lm1lL011YmFpQ3M=" title="https:&#x2F;&#x2F;t.me&#x2F;MubaiCs"><i class="ic i-paper-plane"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>链环</a><ul class="submenu"><li class="item"><a href="/links/friends" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/links/tool/" rel="section"><i class="ic i-star"></i>网址</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/06/29/NodeJs/FrontEnd/webKnowLedge/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/06/29/Database/MySQL/NodeQuerySQL/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E5%85%B7/" title="分类于 数据库工具">数据库工具</a></div><span><a href="/2022/06/29/Database/MySQL/Navicat/" title="Navicat">Navicat</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/NodeJs/" title="分类于 NodeJs">NodeJs</a></div><span><a href="/2022/06/29/NodeJs/Node/NodeConfig/" title="NodeJS安装与配置">NodeJS安装与配置</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/golang/" title="分类于 GoLang">GoLang</a> <i class="ic i-angle-right"></i> <a href="/categories/golang/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" title="分类于 编程语言">编程语言</a></div><span><a href="/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8B)/" title="GoLang协程与标准库">GoLang协程与标准库</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/config/" title="Step.2 基本配置">Step.2 基本配置</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/2022/07/01/Blog/Hexo/command/" title="Hexo入门指南">Hexo入门指南</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a></div><span><a href="/2023/01/01/NodeJs/FrontEnd/sprcial/" title="前端冷知识">前端冷知识</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/2022/06/29/NodeJs/Vue/vite/" title="Vite前端构建开发工具">Vite前端构建开发工具</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/2022/06/29/NodeJs/Vue/%E5%89%8D%E7%AB%AF%E6%96%87%E6%A1%A3/" title="前端常用API">前端常用API</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/database/Mysql/" title="分类于 Mysql">Mysql</a></div><span><a href="/2022/06/29/Database/MySQL/NodeQuerySQL/" title="Mysql非常用语法">Mysql非常用语法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/2022/06/29/NodeJs/Vue/vue3/" title="Vue3.0语法变化">Vue3.0语法变化</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022.06.30 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">MuBai @ MuBai Boat</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">209k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:10</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/06/29/GoLang/GoLang入门篇(下)/",favicon:{show:"(*^▽^*) 源起, 寻心逐夢",hide:"(๑‾᷅^‾᷅๑) 终了, 无悔"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->