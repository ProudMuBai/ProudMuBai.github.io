<!-- build time:Wed May 31 2023 19:36:13 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="源夢" href="https://proudmubai.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="源夢" href="https://proudmubai.github.io/atom.xml"><link rel="alternate" type="application/json" title="源夢" href="https://proudmubai.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="GoLang,Go基础学习"><link rel="canonical" href="https://proudmubai.github.io/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8A)/"><title>GoLang入门学习 - 编程语言 - GoLang | MuBai Boat = 源夢 = 人生如逆旅, 我亦是行人</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="loader-container"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">GoLang入门学习</h1><div class="meta"><span class="item" title="创建时间：2022-06-29 18:26:39"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-06-29T18:26:39+08:00">2022-06-29</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">MuBai Boat</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://www.dmoe.cc/random.php?589263"></li><li class="item" data-background-image="https://www.dmoe.cc/random.php?22197"></li><li class="item" data-background-image="https://www.dmoe.cc/random.php?948517"></li><li class="item" data-background-image="https://www.dmoe.cc/random.php?62166"></li><li class="item" data-background-image="https://www.dmoe.cc/random.php?57960"></li><li class="item" data-background-image="https://www.dmoe.cc/random.php?208878"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/golang/" itemprop="item" rel="index" title="分类于 GoLang"><span itemprop="name">GoLang</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/golang/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="item" rel="index" title="分类于 编程语言"><span itemprop="name">编程语言</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://proudmubai.github.io/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8A)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="MuBai"><meta itemprop="description" content="人生如逆旅, 我亦是行人, 萌新小白 & 学习点滴"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="源夢"></span><div class="body md" itemprop="articleBody"><h1 id="golang学习笔记"><a class="anchor" href="#golang学习笔记">#</a> GoLang 学习笔记</h1><h2 id="基础命令"><a class="anchor" href="#基础命令">#</a> 基础命令</h2><h3 id="1go-环境变量"><a class="anchor" href="#1go-环境变量">#</a> 1.go 环境变量</h3><p>1. 在系统环境变量中新建 <mark>GoPath</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>变量值<span class="token punctuation">:</span> 	D<span class="token punctuation">:</span>\Environment\GO</pre></td></tr></table></figure><p>2. 在系统<mark> path</mark> 末尾添加</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">%</span>GoPath<span class="token operator">%</span>\bin</pre></td></tr></table></figure><p>3.go 环境变量相关配置</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">go</span> env <span class="token operator">-</span>w GO111MODULE<span class="token operator">=</span>on		<span class="token comment">// 开启 go mod 模式，可选值 on off auto (默认)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>set GOPATH<span class="token operator">=</span>项目路径				 <span class="token comment">// 设置 GoPath 路径，包引用相关</span></pre></td></tr></table></figure><h2 id="go基本命令"><a class="anchor" href="#go基本命令">#</a> go 基本命令</h2><h3 id="1go-build命令"><a class="anchor" href="#1go-build命令">#</a> 1.go build 命令</h3><blockquote><p>go build 无参数编译</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 编译，生成可执行文件</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">go</span> build <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token keyword">go</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 运行可执行文件，windows 上会加上 exe，linux 没有后缀</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span><span class="token operator">/</span>可执行文件</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">//go build + 文件列表，会生成多个可执行文件</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">go</span> build <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token keyword">go</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token keyword">go</span> ……</pre></td></tr></table></figure><blockquote><p>go build 参数设置</p></blockquote><table><thead><tr><th>参数</th><th>备注</th></tr></thead><tbody><tr><td>-o</td><td>编译的包名</td></tr><tr><td>-v</td><td>编译时显示包名</td></tr><tr><td>-p n</td><td>开启并发编译，默认情况下该值为 CPU 逻辑核数</td></tr><tr><td>-a</td><td>强制重新构建</td></tr><tr><td>-n</td><td>打印编译时会用到的所有命令，但不真正执行</td></tr><tr><td>-x</td><td>打印编译时会用到的所有命令</td></tr><tr><td>-race</td><td>开启竞态检测</td></tr></tbody></table><h3 id="2go-clean-命令"><a class="anchor" href="#2go-clean-命令">#</a> 2.go clean 命令</h3><blockquote><p>go clean 命令是用来移除当前源码包和关联源码包里面编译生成的文件。这些文件包括：</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>_obj<span class="token operator">/</span> 旧的 object 目录，由 Makefiles 遗留</pre></td></tr><tr><td data-num="2"></td><td><pre>_test<span class="token operator">/</span> 旧的 test 目录，由 Makefiles 遗留</pre></td></tr><tr><td data-num="3"></td><td><pre>_testmain<span class="token punctuation">.</span><span class="token keyword">go</span> 旧的 gotest 文件，由M akefiles 遗留</pre></td></tr><tr><td data-num="4"></td><td><pre>test<span class="token punctuation">.</span>out 旧的 test 记录，由 Makefiles 遗留</pre></td></tr><tr><td data-num="5"></td><td><pre>build<span class="token punctuation">.</span>out 旧的 test 记录，由 Makefiles 遗留</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">[</span>568ao<span class="token punctuation">]</span> object 文件，由 Makefiles 遗留</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">DIR</span><span class="token punctuation">(</span><span class="token punctuation">.</span>exe<span class="token punctuation">)</span> 由 <span class="token keyword">go</span> build 产生</pre></td></tr><tr><td data-num="8"></td><td><pre>DIR<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">.</span>exe<span class="token punctuation">)</span> 由 <span class="token keyword">go</span> test <span class="token operator">-</span>c 产生</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">MAINFILE</span><span class="token punctuation">(</span><span class="token punctuation">.</span>exe<span class="token punctuation">)</span> 由 <span class="token keyword">go</span> build MAINFILE<span class="token punctuation">.</span><span class="token keyword">go</span> 产生</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token operator">*</span><span class="token punctuation">.</span>so 由 SWIG 产生</pre></td></tr></table></figure><blockquote><p>参数说明:</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 一般使用 go clean -i -n</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">-</span>i 清除关联的安装的包和可运行文件，也就是通过 <span class="token keyword">go</span> install 安装的文件</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">-</span>n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">-</span>r 循环的清除在 <span class="token keyword">import</span> 中引入的包</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">-</span>x 打印出来执行的详细命令，其实就是 <span class="token operator">-</span>n 打印的执行版本</pre></td></tr></table></figure><h3 id="3go-run-命令"><a class="anchor" href="#3go-run-命令">#</a> 3.go run 命令</h3><blockquote><p>go run 编译源码，并且执行源码的 main () 函数，不会留下可执行文件。</p></blockquote><p>go run 不能使用 “go run + 包” 的方式进行编译，如需快速编译运行包，需要使用如下步骤来代替：</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//(编译并运行)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>使用 <span class="token keyword">go</span> build 生成可执行文件。</pre></td></tr><tr><td data-num="3"></td><td><pre>运行可执行文件。</pre></td></tr></table></figure><h3 id="4go-fmt命令"><a class="anchor" href="#4go-fmt命令">#</a> 4.go fmt 命令</h3><blockquote><p>格式化代码文件</p></blockquote><ul><li>go fmt -w -l src，可以格式化整个项目。所以 go fmt 是 gofmt 的上层一个包装的命令。</li></ul><blockquote><p>参数介绍</p></blockquote><ul><li>-l 显示那些需要格式化的文件</li><li>-w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。</li><li>-r 添加形如 “a [b:len (a)] -&gt; a [b:]” 的重写规则，方便我们做批量替换</li><li>-s 简化文件中的代码</li><li>-d 显示格式化前后的 diff 而不是写入文件，默认是 false</li><li>-e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前 10 个错误。</li><li>-cpuprofile 支持调试模式，写入相应的 cpufile 到指定的文件</li></ul><h3 id="5go-install命令"><a class="anchor" href="#5go-install命令">#</a> 5.go install 命令</h3><blockquote><p>(编译并安装) go install 将编译的中间文件放在 GOPATH 的 pkg 目录，将编译结果放在 GOPATH 的 bin 目录下</p></blockquote><ul><li>第 1 步是生成结果文件（可执行文件或者 .a 包），</li><li>第 2 步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。</li></ul><blockquote><p>go install 的编译过程有如下规律：</p></blockquote><ul><li>go install 是建立在 GOPATH 上的，无法在独立的目录里使用 go install。</li><li>GOPATH 下的 bin 目录放置的是使用 go install 生成的可执行文件，可执行文件的名称来自于编译时的包名。</li><li>go install 输出目录始终为 GOPATH 下的 bin 目录，无法使用 - o 附加参数进行自定义。</li><li>GOPATH 下的 pkg 目录放置的是编译期间的中间文件。</li></ul><h3 id="6-go-get-命令"><a class="anchor" href="#6-go-get-命令">#</a> 6. go get 命令</h3><blockquote><p>获取包，编译并安装</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">go</span> get <span class="token operator">-</span>u <span class="token operator">+</span> 远程包</pre></td></tr></table></figure><blockquote><p>参数介绍：</p></blockquote><ul><li>-d 只下载不安装</li><li>-f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对</li><li>于本地 fork 的包特别有用</li><li>-fix 在获取源码之后先运行 fix，然后再去做其他的事情</li><li>-t 同时也下载需要为运行测试所需要的包</li><li>-u 强制使用网络去更新包和它的依赖包</li><li>-v 显示执行的命令</li></ul><h3 id="7go-generate命令"><a class="anchor" href="#7go-generate命令">#</a> 7.go generate 命令</h3><p>go generate 命令是用于在编译前自动化生成某类代码。</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* 在同一目录下执行 go generate 就会自动运行命令 command arg1 arg2。</pre></td></tr><tr><td data-num="3"></td><td><pre>*command 可以是在 PATH 中的任何命令，应用非常广泛。</pre></td></tr><tr><td data-num="4"></td><td><pre>*/</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">//go:generate command arg1 arg2</span></pre></td></tr></table></figure><blockquote><p>注意事项：</p></blockquote><ul><li>该特殊注释必须在 .go 源码文件中。</li><li>每个源码文件可以包含多个 generate 特殊注释时。</li><li>显示运行 go generate 命令时，才会执行特殊注释后面的命令。</li><li>命令串行执行的，如果出错，就终止后面的执行。</li><li>特殊注释必须以 &quot;//go:generate&quot; 开头，双斜线后面没有空格。</li></ul><h3 id="8go-test命令"><a class="anchor" href="#8go-test命令">#</a> 8.go test 命令</h3><blockquote><p>测试命令	go test 命令，会自动读取源码目录下的 *_test.go 文件，生成并运行测试用的可执行文件。</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>主要提供“单元测试”和“基准测试”两种方案</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>单元测试——测试和验证代码的框架</pre></td></tr><tr><td data-num="4"></td><td><pre>– <span class="token number">1</span><span class="token punctuation">)</span> 单元测试命令行</pre></td></tr><tr><td data-num="5"></td><td><pre>– <span class="token number">2</span><span class="token punctuation">)</span> 运行指定单元测试用例</pre></td></tr><tr><td data-num="6"></td><td><pre>– <span class="token number">3</span><span class="token punctuation">)</span> 标记单元测试结果</pre></td></tr><tr><td data-num="7"></td><td><pre>– <span class="token number">4</span><span class="token punctuation">)</span> 单元测试日志</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>基准测试——获得代码内存占用和运行效率的性能数据</pre></td></tr><tr><td data-num="10"></td><td><pre>– <span class="token number">1</span><span class="token punctuation">)</span> 基础测试基本使用</pre></td></tr><tr><td data-num="11"></td><td><pre>– <span class="token number">2</span><span class="token punctuation">)</span> 基准测试原理</pre></td></tr><tr><td data-num="12"></td><td><pre>– <span class="token number">3</span><span class="token punctuation">)</span> 自定义测试时间</pre></td></tr><tr><td data-num="13"></td><td><pre>– <span class="token number">4</span><span class="token punctuation">)</span> 测试内存</pre></td></tr><tr><td data-num="14"></td><td><pre>– <span class="token number">5</span><span class="token punctuation">)</span> 控制计时器</pre></td></tr></table></figure><h3 id="9go-pprof命令"><a class="anchor" href="#9go-pprof命令">#</a> 9.go pprof 命令</h3><blockquote><p>性能分析命令	go pprof 可以帮助开发者快速分析及定位各种性能问题，如 CPU 消耗、内存分配及阻塞分析。</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>性能分析首先需要使用 runtime<span class="token punctuation">.</span>pprof 包嵌入到待分析程序的入口和结束处。runtime<span class="token punctuation">.</span>pprof 包在运行时对程序进行每秒 <span class="token number">100</span> 次的采样，最少采样 <span class="token number">1</span> 秒。然后将生成的数据输出，让开发者写入文件或者其他媒介上进行分析。</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">go</span> pprof 工具链配合 Graphviz 图形化工具可以将 runtime<span class="token punctuation">.</span>pprof 包生成的数据转换为 PDF 格式，以图片的方式展示程序的性能分析结果。</pre></td></tr></table></figure><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 安装第三方图形化显式分析数据工具（Graphviz）</span></pre></td></tr><tr><td data-num="2"></td><td><pre>yum install graphiviz</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 安装第三方性能分析来分析代码包</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">go</span> get github<span class="token punctuation">.</span>com<span class="token operator">/</span>pkg<span class="token operator">/</span>profile</pre></td></tr></table></figure><h2 id="go-语言基础"><a class="anchor" href="#go-语言基础">#</a> GO 语言基础</h2><h3 id="1格式化输出"><a class="anchor" href="#1格式化输出">#</a> 1. 格式化输出</h3><ul><li>Println 换行输出</li><li>Printf 格式化输出</li><li>Fprintf 格式化并输出</li><li>Sprintf 格式化并返回一个字 符串而不带任何输出。</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span>			<span class="token comment">// 判断变量类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stderr<span class="token punctuation">,</span> <span class="token string">"格式化 %s\n"</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>格式</th></tr></thead><tbody><tr><td>%d</td><td>十进制整数</td></tr><tr><td>%x %o %b</td><td>十六进制，八进制，二进制整数</td></tr><tr><td>%f %g %e</td><td>浮点数: 3.141593 3.141592653589793 3.141593e+00</td></tr><tr><td>%t</td><td>布尔：true 或 false</td></tr><tr><td>%c</td><td>字符（rune） (Unicode 码点)</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%q</td><td>带双引号的字符串 &quot;abc&quot; 或带单引号的字符 'c'</td></tr><tr><td>%v</td><td>变量的自然形式（natural format）</td></tr><tr><td>%+v</td><td>在 % v 的基础上额外输出字段名</td></tr><tr><td>%#v</td><td>在 %+v 的基础上额外输出类型名</td></tr><tr><td>%T</td><td>变量的类型</td></tr><tr><td>%%</td><td>字面上的百分号标志（无操作数）</td></tr><tr><td>%U</td><td>Unicode 格式 : U+1234; 与 &quot;U + %04x&quot; 相同</td></tr><tr><td>%2.2f</td><td>输出时的间隔 2 格式化 % f 精度 2</td></tr><tr><td>%p</td><td>格式化指针的标识符</td></tr><tr><td>%[n]v</td><td>使用第几个变量格式化</td></tr></tbody></table><h3 id="2常量"><a class="anchor" href="#2常量">#</a> 2. 常量</h3><blockquote><p>常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据。</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>显式类型定义： <span class="token keyword">const</span> b <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"abc"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>隐式类型定义： <span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token string">"abc"</span></pre></td></tr></table></figure><h3 id="3变量"><a class="anchor" href="#3变量">#</a> 3. 变量</h3><ul><li>变量声明</li></ul><pre><code class="language-Go">
var 变量名字 类型 = 表达式
其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
//如果初始化表达式被省略，那么将用零值初始化该变量。
数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, &quot;four&quot; // bool, float64, string
</code></pre><ul><li><p>简短变量声明</p><p>简短变量声明语句的形式可用于声明和初始化局部变量。	“名字 := 表达式” 形式</p><pre><code class="language-Go">//简短变量声明
anim := gif.GIF&#123;LoopCount: nframes&#125;
freq := rand.Float64() * 3.0
t := 0.0
//简短变量声明一组变量
i, j := 0, 1
/**
*第一个语句声明了in和err两个变量。
*在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作。
*/

in, err := os.Open(infile)
out, err := os.Create(outfile)
</code></pre><p>第一个语句声明了 in 和 err 两个变量。在第二个语句只声明了 out 一个变量，然后对已经声明的 err 进行了赋值操作。</p><pre><code class="language-Go">in, err := os.Open(infile)

out, err := os.Create(outfile)
</code></pre><p>简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：</p><pre><code class="language-Go">f, err := os.Open(infile)
//解决的方法是第二个简短变量声明语句改用普通的多重赋值语句。
f, err := os.Create(outfile) // compile error: no new variables
</code></pre></li></ul><h3 id="4指针"><a class="anchor" href="#4指针">#</a> 4. 指针</h3><ul><li><p>&quot;var x int&quot; 声明语句声明一个 x 变量</p></li><li><p>&amp;x 表达式（取 x 变量的内存地址）将产生一个指向该整数变量的指针，</p><p>指针对应的数据类型是 <code>*int</code> ，指针被称之为 “指向 int 类型的指针”</p></li><li><p>如果指针名字为 p，那么可以说 “p 指针指向变量 x”，或者说 “p 指针保存了 x 变量的内存地址”。</p><p>同时 <code>*p</code> 表达式对应 p 指针指向的变量的值</p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>x <span class="token operator">:=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre>p <span class="token operator">:=</span> <span class="token operator">&amp;</span>x         <span class="token comment">// p, of type *int, points to x</span></pre></td></tr><tr><td data-num="3"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token comment">// "1"</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">2</span>          <span class="token comment">// equivalent to x = 2</span></pre></td></tr><tr><td data-num="5"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment">// "2"</span></pre></td></tr></table></figure><ul><li>变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受 <code>&amp;</code> 取地址操作。</li><li>任何类型的指针的零值都是 nil。如果 p 指向某个有效变量，那么 <code>p != nil</code> 测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是 nil 时才相等。</li></ul><pre><code class="language-Go">var x, y int
fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == nil) // &quot;true false false&quot;
</code></pre><h3 id="5strings常用方法"><a class="anchor" href="#5strings常用方法">#</a> 5.strings 常用方法</h3><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">strings.HasSuffix(s, suffix string)bool</td><td style="text-align:center">s : 目标字符串 prefix : 前缀字符</td><td style="text-align:center">判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头</td></tr><tr><td style="text-align:center">strings.HasPrefix(s, prefix string)bool</td><td style="text-align:center">s : 目标字符串 prefix : 结尾字符</td><td style="text-align:center">判断字符串 <code>s</code> 是否以 <code>prefix</code> 结尾</td></tr><tr><td style="text-align:center">strings.Contains(s, substr string)bool</td><td style="text-align:center">s : 目标字符串 substr : 子字符串</td><td style="text-align:center">判断字符串 <code>s</code> 是否包含 substr</td></tr><tr><td style="text-align:center">strings.Index(s, str string)int</td><td style="text-align:center">s : 目标字符串 str : 子字符串</td><td style="text-align:center"><code>str</code> 在字符串 <code>s</code> 中的索引</td></tr><tr><td style="text-align:center">strings.LastIndex(s, str string)int</td><td style="text-align:center">s : 目标字符串 str : 子字符串</td><td style="text-align:center"><code>str</code> 在字符串 <code>s</code> 中最后出现位置的索引</td></tr><tr><td style="text-align:center">strings.IndexRune(s string, r rune)int</td><td style="text-align:center">s : 目标字符串 r : 字节</td><td style="text-align:center">查询非 ASCII 编码的字符 r 在 str 中的位置</td></tr><tr><td style="text-align:center">strings.Replace(str, old,new, n)string</td><td style="text-align:center" n="">(string){str|old|new}|(index)</td><td style="text-align:center">将 str 中的前 n 个字符 <code>old</code> 替换为 <code>new</code></td></tr><tr><td style="text-align:center">strings.Count(s, str string)int</td><td style="text-align:center">s: 原字符串 str 子串</td><td style="text-align:center">计算 <code>str</code> 在 <code>s</code> 中出现的非重叠次数</td></tr><tr><td style="text-align:center">strings.Repeat(s, count int)string</td><td style="text-align:center">s: 原字符串 count 重复次数</td><td style="text-align:center">返回重复 <code>count</code> 次字符串 <code>s</code> 的结果</td></tr><tr><td style="text-align:center">strings.ToLower(s)string</td><td style="text-align:center">s 原字符串</td><td style="text-align:center">字符转为小写字符</td></tr><tr><td style="text-align:center">strings.ToUpper(s)string</td><td style="text-align:center">s 原字符串</td><td style="text-align:center">字符转为大写字符</td></tr><tr><td style="text-align:center">strings.TrimSpace(s)</td><td style="text-align:center">s 原字符串</td><td style="text-align:center">剔除字符串开头和结尾的空白</td></tr><tr><td style="text-align:center">strings.TrimLeft(s)</td><td style="text-align:center">s 原字符串</td><td style="text-align:center">剔除字符串开头的空白</td></tr><tr><td style="text-align:center">strings.TrimRight(s)</td><td style="text-align:center">s 原字符串</td><td style="text-align:center">剔除字符串结尾的空白</td></tr><tr><td style="text-align:center">strings.Fields(s)</td><td style="text-align:center">s 原字符串</td><td style="text-align:center">以 (1,) 个空白字符空分割目标字符串</td></tr><tr><td style="text-align:center">strings.Split(s, sep)</td><td style="text-align:center">s 原字符串 sep 分割字符</td><td style="text-align:center">用 sep 分割目标字符串</td></tr><tr><td style="text-align:center">strings.Join(sl []string, sep string)string</td><td style="text-align:center">sl 切片数组 sep 分割字符</td><td style="text-align:center">将 sl 以 sepl 连接成一个字符串</td></tr><tr><td style="text-align:center">strings.NewReader(str)</td><td style="text-align:center">read := strings.NewReader(str)</td><td style="text-align:center">生成 reader 并读取字符串中内容</td></tr><tr><td style="text-align:center">Package : strconv</td><td style="text-align:center">类型转换</td><td style="text-align:center">字符串转换工具类</td></tr></tbody></table><h3 id="6时间和日期"><a class="anchor" href="#6时间和日期">#</a> 6. 时间和日期</h3><blockquote><p>时间常用方法</p></blockquote><table><thead><tr><th>方法名</th><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>func Now() Time</td><td>无</td><td style="text-align:center">获取当前时间</td></tr><tr><td>time.Now().Year()|.Month()|.Day()</td><td>time 对象</td><td style="text-align:center">获取时间对象的年月日</td></tr><tr><td>func Parse(layout, value string) (Time, error)</td><td>字符串格式化成时间</td><td style="text-align:center">layout 必须时 Go 的诞生时间</td></tr><tr><td>func (t Time) Format(layout string) string</td><td>时间转为字符串</td><td style="text-align:center">根据参考时间转换成字符串</td></tr><tr><td>time.Now().Unix</td><td>无</td><td style="text-align:center">获取当前时间时间戳</td></tr><tr><td>func Unix(sec int64, nsec int64) Time</td><td>秒数和纳秒数</td><td style="text-align:center">将时间戳转换为时间</td></tr><tr><td>func (t Time) Equal (u Time) bool 或 = =</td><td>time t time u</td><td style="text-align:center">比较两个时间是否相同 (含时区)</td></tr><tr><td>func (t Time) Before(u Time) bool</td><td>time t time u</td><td style="text-align:center">时间 t 是否在 u 之前</td></tr><tr><td>func (t Time) After(u Time) bool</td><td>time t time u</td><td style="text-align:center">时间 t 是否在 u 之后</td></tr><tr><td>func (t Time) Date() (year int, month Month, day int)</td><td>time</td><td style="text-align:center">返回时间 t 的年月日</td></tr><tr><td>func (t Time) Clock() (hour, min, sec int)</td><td>time</td><td style="text-align:center">返回时间 t 的时分秒</td></tr></tbody></table><blockquote><p>时间运算</p></blockquote><table><thead><tr><th>方法名</th><th>参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>func (t Time) Add(d Duration) Time</td><td>time</td><td style="text-align:center">返回 t+d 后的时间点</td></tr><tr><td>func (t Time) AddDate(years int, months int, days int) Time</td><td>Y-M-D</td><td style="text-align:center">返回 t+YMD 后的时间点</td></tr><tr><td>func (t Time) Sub(u Time) Duration</td><td>t u</td><td style="text-align:center">返回 t-u 的时间段 (h-m-s)</td></tr><tr><td>func (t Time) Round(d Duration) Time</td><td>t d</td><td style="text-align:center">返回距离 t 最近的时间</td></tr><tr><td>func (t Time) Truncate(d Duration) Time</td><td>t d</td><td style="text-align:center">返回最接近但早于 t 的时间</td></tr></tbody></table><blockquote><p>Timer 定时器</p></blockquote><table><thead><tr><th>方法名</th><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>func NewTimer(d Duration) *Timer</td><td>d</td><td>在最少过去时间段 d 后到期，自己的 C 通道发送当时的时间</td></tr><tr><td>func After(d Duration) &lt;-chan Time</td><td>d</td><td>在另一线程经过时间段 d 后向返回值发送当前时间</td></tr><tr><td>func AfterFunc(d Duration, f func()) *Timer</td><td>d f</td><td>等待时间 d 然后调用函数 f</td></tr><tr><td>func Sleep(d Duration)</td><td>d</td><td>Sleep 阻塞当前 go 程至少 d 代表的时间段</td></tr><tr><td>func Tick(d Duration) &lt;-chan Time</td><td>d</td><td>只提供对 Ticker 的通道的访问，无法关闭</td></tr></tbody></table><h3 id="7控制结构"><a class="anchor" href="#7控制结构">#</a> 7. 控制结构</h3><blockquote><p>if-else 结构</p></blockquote><ul><li>if 和 else 之后的 { 必须和关键字同行</li><li>f 结构内有 break、continue、goto 或者 return 语句时，省略 else</li><li>使用简短方式 := 声明的变量的作用域只存在于 if 结构中 (如果在 if 之前被声明，那原有的值会被隐藏)</li></ul><blockquote><p>Switch 结构</p></blockquote><ul><li>{ 必须和 switch 关键字在同一行</li><li>case 多个符合条件的值 case val1, val2, val3 :</li><li>Go 执行完分支就会退出 Switch 代码块，所以不需要使用 <mark>break</mark> 表示结束</li><li>进入分支后继续执行下方分支时使用 <mark>fallthrough</mark> 继续执行后续分支</li></ul><blockquote><p>for 结构</p></blockquote><ol><li>for 基本语法</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> 初始化语句<span class="token punctuation">;</span> 条件语句<span class="token punctuation">;</span> 修饰语句 <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="2"><li>for 循环的三种形式</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1.</span>完整形态</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">2.</span>基于条件判断的迭代</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span> i <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">3.</span>无限循环</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="3"><li>for-range 结构</li></ol><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> ix<span class="token punctuation">,</span> val <span class="token operator">:=</span> <span class="token keyword">range</span> coll <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>Break 与 continue</p></blockquote><p><mark>Break 的作用效果</mark></p><ul><li>break 的作用范围为该语句出现后的最内部的结构</li><li>在 switch 或 select 语句中，break 作用结果是跳过整个代码块，执行后续的代码</li><li>嵌套的循环体，break 只会退出最内层的循环：</li></ul><p><mark>Continue 的作用效果</mark></p><ul><li>continue 忽略剩余的循环体而直接进入下一次循环的过程，但不是无条件执行下一次循环，执行之前依旧需要满足循环的判断条件</li></ul><blockquote><p>标签 与 goto</p></blockquote><p><mark>标签 (Label)</mark></p><ul><li>for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（ <code>:</code> ）结尾的单词</li><li>标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母</li></ul><p><mark>go to</mark></p><ul><li>指向到对应标签继续运行代码 (不会干扰到已经存在的变量值)</li></ul><h3 id="8函数-function"><a class="anchor" href="#8函数-function">#</a> 8. 函数 Function</h3><h4 id="1函数参数与返回值"><a class="anchor" href="#1函数参数与返回值">#</a> 1. 函数参数与返回值</h4><blockquote><p><strong>niladic</strong> 函数（niladic function）</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 函数定义时，它的形参一般是有名字的，也可以定义没有形参名的函数，只有相应的形参类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">float64</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="2按值传递call-by-value-按引用传递call-by-reference"><a class="anchor" href="#2按值传递call-by-value-按引用传递call-by-reference">#</a> 2. 按值传递（call by value） 按引用传递（call by reference）</h4><p><mark>按值传递</mark> : Go 默认使用按值传递来传递参数，也就是传递参数的副本</p><p><mark>按引用传递</mark>：如果需要函数直接修改参数的值，要将参数的地址（比如 &amp;variable）传递给函数</p><ul><li><p>在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递</p></li><li><p>如果一个函数需要返回多个值，可以传递一个<mark>切片</mark>给函数（如果返回值具有相同类型）或者是传递一个<mark>结构体</mark>（如果返回值具有不同的类型）</p></li></ul><h4 id="3命名的返回值-named-return-variables"><a class="anchor" href="#3命名的返回值-named-return-variables">#</a> 3. 命名的返回值 (named return variables)</h4><blockquote><p>命名的返回值作为结果形参，需要返回时 <mark>直接 return</mark> 即可</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 没有命名的返回值 函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">namedFunc</span><span class="token punctuation">(</span>input <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> input<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> input</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 命名的返回值函数</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">getX2AndX3_2</span><span class="token punctuation">(</span>input <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x2 <span class="token builtin">int</span><span class="token punctuation">,</span> x3 <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    x2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> input</pre></td></tr><tr><td data-num="8"></td><td><pre>    x3 <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> input</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// return x2, x3</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>return 或 return var 都是可以的。</li><li>return var = expression（表达式） 会引发一个编译错误：syntax error: unexpected =, expecting semicolon or newline or }</li></ul><h4 id="4空白符blank-identifier"><a class="anchor" href="#4空白符blank-identifier">#</a> 4. 空白符（blank identifier）</h4><blockquote><p>空白符用来匹配一些不需要的值，然后丢弃</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">ThreeValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">float32</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7.5</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 函数有三个返回值，第二个使用空白符接收后即被自动丢弃</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    i1<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> f1 <span class="token operator">=</span> <span class="token function">ThreeValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="5改变外部变量outside-variable"><a class="anchor" href="#5改变外部变量outside-variable">#</a> 5. 改变外部变量（outside variable）</h4><ul><li>传递指针给函数可以节省内存，而且赋予函数直接修改外部变量的能力</li><li>修改变量不在需要使用 return 返回</li><li><code>reply</code> 是一个指向 <code>int</code> 变量的指针，通过这个指针，我们在函数内修改了这个 <code>int</code> 变量的数值</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">Multiply</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">,</span> reply <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">*</span>reply <span class="token operator">=</span> a <span class="token operator">*</span> b</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 在方法中使用指针直接修改外地传递的变量的原值</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    n <span class="token operator">:=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    reply <span class="token operator">:=</span> <span class="token operator">&amp;</span>n</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Multiply</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> reply<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Multiply:"</span><span class="token punctuation">,</span> <span class="token operator">*</span>reply<span class="token punctuation">)</span> <span class="token comment">// Multiply: 50</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="6传递可变长度参数"><a class="anchor" href="#6传递可变长度参数">#</a> 6. 传递可变长度参数</h4><ul><li>可变参数形式 <mark>...type</mark> , 将切片拆解为多个参数 <mark>slice...</mark></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> <span class="token function">F1</span><span class="token punctuation">(</span>s <span class="token operator">...</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>不同类型的可变参数 (<mark>存储所有可能的参数的结构体</mark>)</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 包含所有可能的参数的结构体  </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> Options <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     par1 type1<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     par2 type2<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>     <span class="token operator">...</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 使用方法时第三个参数为结构体</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">func</span> <span class="token function">F1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> Options <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>使用默认的空接口 (interface {})</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// F1(a, b, Options &#123;par1:val1, par2:val2&#125;)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>values …<span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> values <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">switch</span> v <span class="token operator">:=</span> value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            caseint<span class="token punctuation">:</span>…</pre></td></tr><tr><td data-num="6"></td><td><pre>            casefloat<span class="token punctuation">:</span>…</pre></td></tr><tr><td data-num="7"></td><td><pre>            casestring<span class="token punctuation">:</span>…</pre></td></tr><tr><td data-num="8"></td><td><pre>            casebool<span class="token punctuation">:</span>…</pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">default</span><span class="token punctuation">:</span>…</pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="7-defer-代码追踪"><a class="anchor" href="#7-defer-代码追踪">#</a> 7. defer 代码追踪</h4><ul><li>关键字 <mark>defer</mark> 允许推迟到 <mark>函数返回之前</mark> 或 任意位置执行 <mark>return 语句</mark> 之后</li><li>一般用于释放某些已分配的资源</li></ul><blockquote><p>defer 记录函数的参数与返回值</p></blockquote><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">package</span> main</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token string">"io"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">"log"</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">func1</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"func1(%q) = %d, %v"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> n<span class="token punctuation">,</span> err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">7</span><span class="token punctuation">,</span> io<span class="token punctuation">.</span>EOF</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token string">"Go"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>输出结果 <span class="token punctuation">:</span> Output<span class="token punctuation">:</span> <span class="token number">2011</span><span class="token operator">/</span><span class="token number">10</span><span class="token operator">/</span><span class="token number">04</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token number">46</span><span class="token punctuation">:</span><span class="token number">11</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token string">"Go"</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span> EOF</pre></td></tr></table></figure><h4 id="8内置函数"><a class="anchor" href="#8内置函数">#</a> 8. 内置函数</h4><p>Go 语言拥有一些不需要导入就可以使用的内置函数</p><table><thead><tr><th style="text-align:left">称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">close</td><td style="text-align:left">用于管道通信</td></tr><tr><td style="text-align:left">len、cap</td><td style="text-align:left">len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td style="text-align:left">new、make</td><td style="text-align:left">new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new (type)、make (type)。new (T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型： <code>v := new(int)</code> 。make (T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作（详见第 7.2.3/4 节、第 8.1.1 节和第 14.2.1 节）<strong>new () 是一个函数，不要忘记它的括号</strong></td></tr><tr><td style="text-align:left">copy、append</td><td style="text-align:left">用于复制和连接切片</td></tr><tr><td style="text-align:left">panic、recover</td><td style="text-align:left">两者均用于错误处理机制</td></tr><tr><td style="text-align:left">print、println</td><td style="text-align:left">底层打印函数 ，在部署环境中建议使用 fmt 包</td></tr><tr><td style="text-align:left">complex、real imag</td><td style="text-align:left">用于创建和操作<mark>复数</mark></td></tr></tbody></table><h4 id="9递归函数"><a class="anchor" href="#9递归函数">#</a> 9. 递归函数</h4><blockquote><p>在函数体内 调用自身</p></blockquote><p><mark>栈溢出</mark>：大量的递归调用导致的程序栈内存分配耗尽</p><h4 id="10-将函数作为参数"><a class="anchor" href="#10-将函数作为参数">#</a> 10. 将函数作为参数</h4><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> fun01 <span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">,</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> fun02 <span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    str <span class="token operator">:=</span> <span class="token function">fun01</span><span class="token punctuation">(</span><span class="token function">fun02</span><span class="token punctuation">(</span><span class="token char">'沐'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"这是一段示例文本!"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="11-闭包函数"><a class="anchor" href="#11-闭包函数">#</a> 11. 闭包函数</h4><ul><li>关键字 <code>defer</code> （详见第 6.4 节）经常配合匿名函数使用，它可以用于改变函数的命名返回值。</li><li>匿名函数还可以配合 <code>go</code> 关键字来作为 goroutine 使用</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 匿名函数赋值给变量</span></pre></td></tr><tr><td data-num="2"></td><td><pre>f <span class="token operator">:=</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 匿名函数自调用</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="12应用闭包"><a class="anchor" href="#12应用闭包">#</a> 12. 应用闭包</h4><ul><li>应用闭包：将函数作为返回值</li><li>闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明</li><li>闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 给未添加文件后缀的文件名添加后缀</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">AutoAddSuffix</span><span class="token punctuation">(</span>suffix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>		<span class="token keyword">if</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">HasSuffix</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>suffix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>			<span class="token keyword">return</span> name <span class="token operator">+</span> suffix</pre></td></tr><tr><td data-num="6"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>		<span class="token keyword">return</span> name</pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">&#125;</span>	</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 斐波那契数列 闭包实现</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">func</span> <span class="token function">fibFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	 num1<span class="token punctuation">,</span>num2 <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	 <span class="token keyword">return</span> <span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	 	num1<span class="token punctuation">,</span>num2 <span class="token operator">=</span> num2<span class="token punctuation">,</span>num1<span class="token operator">+</span>num2</pre></td></tr><tr><td data-num="16"></td><td><pre>	 	<span class="token keyword">return</span> num2</pre></td></tr><tr><td data-num="17"></td><td><pre>	 <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">func</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    addGo <span class="token operator">:=</span> <span class="token function">AutoAddSuffix</span><span class="token punctuation">(</span><span class="token string">".go"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	addHtml <span class="token operator">:=</span> <span class="token function">AutoAddSuffix</span><span class="token punctuation">(</span><span class="token string">".html"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token function">addGo</span><span class="token punctuation">(</span><span class="token string">"goLang"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span><span class="token function">addHtml</span><span class="token punctuation">(</span><span class="token string">"index"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    </pre></td></tr><tr><td data-num="26"></td><td><pre>    f <span class="token operator">:=</span> <span class="token function">fibFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	arr <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>		arr <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"切片长度为%d,容量为%d\n"</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="13闭包调试"><a class="anchor" href="#13闭包调试">#</a> 13. 闭包调试</h4><blockquote><p>获取正在执行的文件中的函数 : <mark>runtime</mark> 中的 <mark>Caller()</mark> 方法 或 <mark>log</mark></p></blockquote><ul><li>使用 where () 闭包函数和 runtime 中的 Caller ()</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>where <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token boolean">_</span><span class="token punctuation">,</span> file<span class="token punctuation">,</span> line<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> runtime<span class="token punctuation">.</span><span class="token function">Caller</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s:%d"</span><span class="token punctuation">,</span> file<span class="token punctuation">,</span> line<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// some code</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// some more code</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>使用 log 包中的 flag 参数实现</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>log<span class="token punctuation">.</span><span class="token function">SetFlags</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span>Llongfile<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 简短实现</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">var</span> where <span class="token operator">=</span> log<span class="token punctuation">.</span>Print</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token operator">...</span> some code</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token operator">...</span> some code</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="14计算函数执行时间"><a class="anchor" href="#14计算函数执行时间">#</a> 14. 计算函数执行时间</h4><p>计算函数执行开始到完成所消耗的时间</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">longCalculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>end <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>delta <span class="token operator">:=</span> end<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"longCalculation took this amount of time: %s\n"</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="15通过内存缓存提升性能"><a class="anchor" href="#15通过内存缓存提升性能">#</a> 15. 通过内存缓存提升性能</h4><ul><li><p>进行大量的计算时 <mark>提升性能</mark> 最有效的方式就是 避免重复计算.</p><p>通过<mark>在内存中缓存</mark>和<mark>重复利用相同计算的结果</mark>，称之为缓存.</p></li><li><p>内存缓存在使用<mark>计算成本相对昂贵的函数</mark>时非常有用，譬如 大量进行相同参数的运算，</p><p>还可用于输入想通透输出必定获得相同输出的纯函数中.</p></li></ul><h3 id="9切片与数组"><a class="anchor" href="#9切片与数组">#</a> 9. 切片与数组</h3><p>容器：包含大量条目 (item) 的数据结构，例如 <mark>数组 []</mark>,<mark> 切片 (slice)</mark> 和 <mark>map</mark> .</p><h4 id="1数组的声明和初始化"><a class="anchor" href="#1数组的声明和初始化">#</a> 1. 数组的声明和初始化</h4><ul><li>数组是 <mark>值类型</mark></li><li>数组时具有<mark>唯一类型</mark> 的 一组已编号且长度固定的数据序列</li><li>类型可以是任意的原始类型：整数，字符或自定义类型</li><li>数组长度必须是一个常量表达式或非负整数</li><li>数组长度也是数组类型的一部分，即不同长度的数组属于不同类型</li><li>数组声明时，其中的所有元素都会自动初始化为默认值</li><li>数组赋值可通过 <code>arr[i] = value</code></li><li>如果数组索引越界时 编译会通过而运行时会 panic</li></ul><p><mark>声明格式</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> indetifier <span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">]</span><span class="token keyword">type</span></pre></td></tr><tr><td data-num="2"></td><td><pre>例 <span class="token punctuation">:</span> <span class="token keyword">var</span> arr <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token builtin">int</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 初始化</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">var</span> slice1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 部分值初始化</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">"arr3"</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">:</span> <span class="token string">"arr4"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">var</span> slice2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">"slice3"</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">:</span> <span class="token string">"slice4"</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="2数组常量"><a class="anchor" href="#2数组常量">#</a> 2. 数组常量</h4><ul><li>如果数组值已知，则可以通过 <mark>数组常量</mark> 的方法来初始化数组</li><li>数组常量赋值的三种形式</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 形式一 从左往右依次赋值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 形式二 不定长度数组</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 形式三  key:value 形式</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">var</span> arrValue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">"arr3"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">:</span> <span class="token string">"arr5"</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="3数组"><a class="anchor" href="#3数组">#</a> 3. 数组</h4><ul><li>数组通常是一维的，但是可以用来组装成多为数组，例如: <code>[3][5]int</code></li></ul><h4 id="4将数组传递给函数"><a class="anchor" href="#4将数组传递给函数">#</a> 4. 将数组传递给函数</h4><ul><li>使用数组的指针</li><li>使用数组的切片</li></ul><h4 id="5切片"><a class="anchor" href="#5切片">#</a> 5. 切片</h4><ul><li>切片（slice）是对数组一个<mark>连续片段的引用</mark> （该数组我们称之为相关数组，通常是匿名的）</li><li>切片是 <mark>引用数据类型</mark></li><li>切片是可以索引的，并且可以由 <code>len()</code> 函数获取长度</li><li>切片的长度可以在运行时修改，是一个 <mark>长度可变的数组</mark></li><li>切片提供了计算容量的函数 <code>cap(s)</code> cap (s) = s [0] 到 s [len (s)-1] 的长度</li><li>切片最长可达 = 切片长度 + 数组除切片之外的长度 所以 <mark>0&lt;=len(s)&lt;= cap(s)</mark> 恒成立</li><li>多个切片表示同一个数组的片段时，可以<mark>共享数据</mark>；数组实际上是切片的构建块.</li><li>切片是引用，所以不需要使用额外的内存，比数组更有效率</li><li>切片扩展到大小上限 s = s [:cap (s)]</li><li>字符是不可变的字节数组，所以也可以被切分成切片</li><li>切片追加元素 <mark>append(slice, element)</mark></li><li>切片扩容时，会分配新的切片来保证已有切片元素和新增元素的存储 ( <code>内存指向地址会改变</code> )</li><li>切片不被其他切片引用时扩容，地址不变，长度扩容，(有其他切片共享时，直接生成新切片，起始地址变更)</li></ul><p><mark>切片声明</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 切片初始化之前默认为 nil</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> identifier <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span> 	<span class="token punctuation">(</span>无需指明长度<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 切片的初始化格式 (通过数组进行初始化)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">var</span> slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>star<span class="token punctuation">:</span>end<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 使用类似数组的方式初始化</span></pre></td></tr><tr><td data-num="6"></td><td><pre>s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>切片截取部分数组</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 声明一个容量为 end 的数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> arr <span class="token operator">=</span>  <span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 截取数组进行初始化的格式 [start,end)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">var</span> slice1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">:</span>end<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 得到完整的数组</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">var</span> slice2 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 得到数组从 start 到末尾的部分</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">var</span> slice3 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">:</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 得到数组从开始到 end 的部分</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">var</span> slice4 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>end<span class="token punctuation">]</span></pre></td></tr></table></figure><p><mark>切片传递给函数</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">func</span> sum <span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">sum</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>make () 创建一个切片</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> slice <span class="token punctuation">[</span><span class="token punctuation">]</span>typr <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>简写 <span class="token punctuation">:</span> slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 创建一个只占用数组 len 个数项的切片</span></pre></td></tr><tr><td data-num="4"></td><td><pre>slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">,</span><span class="token builtin">cap</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">//make 使用的基本方式</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">,</span><span class="token builtin">cap</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><mark>new () 和 make ()</mark> 的区别</p><ul><li><p>new (T) 为 T 分配一片内存， <code>初始化为0</code> , 返回 <code>*T的内存地址</code></p><p>返回值时一个指向类型为 T 值为 0 的地址的指针，适用于 值类型 (数组和结构体)</p></li><li><p>make (T) 返回一个类型为 T 的初始值，只适用于 3 中内建的引用类型 : <code>切片</code> | <code>map</code> | <code>channel</code></p></li></ul><p><mark>多维切片</mark></p><p>切片可以由一维组合成高维，通过分片的分片 (切片的数组), 长度可以任意动态变化</p><p>Go 语言的多维切片可以任意切分，但内层的切片必须单独分配 (<mark>通过 make 函数</mark>)</p><h4 id="6-bytes"><a class="anchor" href="#6-bytes">#</a> 6. bytes</h4><ul><li>类型 [] byte 的切片十分常见，Go 语言有<mark> bytes</mark> 包解决相关问题</li><li>bytes 包和字符串包类似，而且包含 <mark>Buffer</mark> 类型</li></ul><p>长度可变的 bytes 的 buffer</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span><span class="token string">"bytes"</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">type</span> Bufferstruct<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">...</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>读写 未知长度的 bytes 最好使用 buffer</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//Buffer 定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> buffer bytes<span class="token punctuation">.</span>Buffer</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//new () 获得 Buffer 指针</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">var</span> r <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 通过函数创建 Buffer 对象 并且用 buf 初始化</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">NewBuffer</span><span class="token punctuation">(</span>buf <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token operator">*</span>Buffer</pre></td></tr></table></figure><p>通过 buffer 串联字符串 (比使用 <code>+=</code> 要更节省内存和 CPU)</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* 通过 buffer.WriteString (s) 方法 将字符串 s 追加到末尾</pre></td></tr><tr><td data-num="3"></td><td><pre>* 最后通过 buffer.String () 方法将 buffer 转换为 string</pre></td></tr><tr><td data-num="4"></td><td><pre>*/</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">var</span> buffer bytes<span class="token punctuation">.</span>Buffer</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> s<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">getNextString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span><span class="token comment">//method getNextString() not shown here</span></pre></td></tr><tr><td data-num="8"></td><td><pre>         buffer<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   		 <span class="token keyword">break</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"\n"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="7-切片重组"><a class="anchor" href="#7-切片重组">#</a> 7. 切片重组</h4><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 初始化一个数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre>slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span><span class="token punctuation">,</span>start_length<span class="token punctuation">,</span>capacity<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 切片的初始长度  </span></pre></td></tr><tr><td data-num="4"></td><td><pre>start_length</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 切片的初始容量</span></pre></td></tr><tr><td data-num="6"></td><td><pre>capacity</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 切片达到容量上限后进行扩容 (切片重组)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>slice1 <span class="token operator">=</span> slice<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>end<span class="token punctuation">]</span> <span class="token comment">//end 为新的末尾索引</span></pre></td></tr><tr><td data-num="9"></td><td><pre>sl <span class="token operator">=</span> sl<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>sl<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr></table></figure><h4 id="8切片的复制与追加"><a class="anchor" href="#8切片的复制与追加">#</a> 8. 切片的复制与追加</h4><ul><li>slice... 切片解构</li><li>增加切片容量：创建新的大容量切片 复制原切片内容到新切片中</li><li><code>func append(s []T,x ...T) []T</code> 将 n 个相同类型的元素追加到切片后面，并返回新切片</li><li><code>func copy(dst,src []T) int</code> 将切片 src 拷贝到 dst 并覆盖 dst 的相关元素</li></ul><h4 id="9字符串生成切片"><a class="anchor" href="#9字符串生成切片">#</a> 9. 字符串生成切片</h4><ul><li><p><code>c:= []byte(s)</code> 获取一个字节的切片</p></li><li><p><code>c := []byte(string)</code> | <code>copy(dst []byte,src string)</code> 直接通过字符串转字节切片</p></li><li><p><code>r := []rune(s)</code> 字符串中<mark>字节对应整数</mark>，因此可以转为 rune 切片</p></li><li><p><code>substr := str[start:end]</code> 获取字符串从索引 start~end-1 位置的字符串</p></li><li><p><code>str[start:]</code> 获取从 start 到 len (str)-1 位置的<mark>子字符串</mark></p></li><li><p><code>star[:end]</code> 表示获取从 0 开始到 end-1 的<mark>子字符串</mark></p></li></ul><p><mark>修改字符串中的字符</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>* Go 语言中字符串不可变，所以 str [index] 表达式不能进行赋值</pre></td></tr><tr><td data-num="3"></td><td><pre>* 通过将字符串转为字节数组，然后修改数组中的元素 </pre></td></tr><tr><td data-num="4"></td><td><pre>* 最后键个字节数组转换回字符串格式</pre></td></tr><tr><td data-num="5"></td><td><pre>*/</pre></td></tr><tr><td data-num="6"></td><td><pre>s <span class="token operator">:=</span> <span class="token string">"GoLang"</span></pre></td></tr><tr><td data-num="7"></td><td><pre>c <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'g'</span></pre></td></tr><tr><td data-num="9"></td><td><pre>s2 <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">></span> <span class="token string">"goLang"</span></pre></td></tr></table></figure><p><mark>切片和数组的排序与搜索</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 标准库 sort 实现搜索和排序</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">/* 排序 */</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">func</span> <span class="token function">Ints</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>						<span class="token comment">// 对数组进行排序</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">func</span> <span class="token function">IntsAreSorted</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> 		<span class="token comment">// 检查数组是否被排序</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">func</span> <span class="token function">Float64s</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">)</span>				<span class="token comment">// 排序 float64 元素数组</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">func</span> <span class="token function">Strings</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>				<span class="token comment">// 排序字符串元素</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">/* 搜索指定元素 */</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">func</span> SearchInts <span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">func</span> SearchFloat64s <span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span>x <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">func</span> <span class="token function">SearchStrings</span><span class="token punctuation">(</span>a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span>x <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span></pre></td></tr></table></figure><p><mark>append 函数</mark></p><ul><li>将切片 b 追加到切片 a 之后 : a = append (a,b...)</li><li>复制 切片 a 的元素到 切片 b 中 <code>b = make([]T,len(a))</code> <code>copy(b,a)</code></li><li>删除索引为 i 的元素 : <code>a = append(a[:i],a[i+1:]...)</code></li><li>切除切片 a 中，从索引 i 至 j 位置的元素: <code>a = append(a[:i],a[j:]...)</code></li><li>切片拓展 j 个元素长度: <code>a = append(a,make([]T,j)...)</code></li><li>在索引 i 出插入元素 x : <code>a = append(a[:i],append([]T&#123;x&#125;,a[i:]...)...)</code></li><li>在索引 i 处 插入长度为 j 的新切片: <code>a = append(a[:i],append(make([]T,j),a[i:]...)...)</code></li><li>在索引 i 处插入切片 b 的所有元素: <code>a = append(a[:i],append(b,a[i:]...)...)</code></li><li>取出切片 a 最末尾的元素 x : <code>x,a = a[len(a)-1],a[:len(a)-1]</code></li><li>将元素 x 追加到切片 a: <code>a = append(a,x)</code></li></ul><h4 id="10切片和垃圾回收"><a class="anchor" href="#10切片和垃圾回收">#</a> 10. 切片和垃圾回收</h4><p>切片底层指向一个数组，只有在没有任何切片指向时，底层数组内存才会释放 (可能会导致程序占用多余内存)</p><h3 id="10-map"><a class="anchor" href="#10-map">#</a> 10. Map</h3><ul><li>map 是一种特殊的数据结构：一种元素对 (pair) 的无序集合，pair 的元素是 <code>key : value</code> 键值对，</li></ul><p>​	所以 这种结构也被称为 字典 或 关联数组。是一种 <mark>快速寻值的结构</mark>，能够基于指定的 key 进行迅速定位</p><ul><li>map 数据结构在其他编程语言中也被称为 字典，hash,HashTable</li></ul><h4 id="1声明初始化-和-make"><a class="anchor" href="#1声明初始化-和-make">#</a> 1. 声明，初始化 和 make</h4><ul><li>map 是引用类型，未初始化的 map 的值是 nil</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> <span class="token keyword">map</span> <span class="token keyword">map</span><span class="token punctuation">[</span>keyType<span class="token punctuation">]</span>valueType</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">var</span> map1 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span></pre></td></tr></table></figure><ul><li>key 是任意可以使用 = = 或！= 操作符比较的类型 (数组，切片 和 含有数组，切片的结构体不能作为 key), <mark>指针和接口</mark> 类型可以为 key</li><li>value 可以是任意类型，通过空接口类型，可以存储任意值，但需要先进行一次断言</li><li>map 传递代价很小，通过 key 在 map 中寻值很快，但任然比切片和数组通过索引读取慢 100 倍</li><li>map 可以用函数作为自己的值 &lt;map 作为分支结构，key 用于选择执行的函数&gt;</li><li>map 取值 : <code>map[key1] = val</code> | <code>v := map[key1]</code> &lt;key 不存在时，获取的是值类型的空值&gt;</li><li>获取 map 中 pair 的数目， <code>len(map)</code> ,map-pairs 可以在运行时动态添加和删除</li></ul><p><mark>map 初始化</mark></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> map01 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 创建并赋值</span></pre></td></tr><tr><td data-num="3"></td><td><pre>mapLit <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token string">"one"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 创建空 map, 动态添加数据</span></pre></td></tr><tr><td data-num="5"></td><td><pre>mapCreated <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">float32</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>mapCreated<span class="token punctuation">[</span><span class="token string">"key1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6.6</span></pre></td></tr><tr><td data-num="7"></td><td><pre>mapCreated<span class="token punctuation">[</span><span class="token string">"key2"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6.66</span></pre></td></tr></table></figure><ul><li><p>map 是引用类型：内存用 make 方法分配</p></li><li><p>map 的初始化 : <code>var map1 = make(map[keyType]valueType)</code> 相当于</p><p>map1 := make(map[keyType]valueType){}</p></li><li><p>不要使用 new, 永远使用 make 来构造 map, new 可能会分配一个空引用的指针，</p><p>进行赋值时会编译报错</p></li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>mapCreated <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">float32</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 编译报错</span></pre></td></tr><tr><td data-num="3"></td><td><pre>mapCreated<span class="token punctuation">[</span><span class="token string">"key1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4.5</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token string">`invalid operation: mapCreated["key1"] (index of type *map[string]float32).`</span></pre></td></tr></table></figure><p><mark>map 容量</mark></p><p>map 可以根据新增的 key-value 动态伸缩，因为 map 没有固定长度和最大限制，</p><p>但可以标明 map 的初始容量 <code>capacity</code> , 例: <code>make(map[keyType]valueType,cap)</code></p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 创建时声明 map 的初始容量</span></pre></td></tr><tr><td data-num="2"></td><td><pre>map2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">float32</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="4"></td><td><pre>* map 增加到容量上限时，继续增加 key-value 对</pre></td></tr><tr><td data-num="5"></td><td><pre>* map 的大小会自动 +1, 但出于性能考虑，对于 大的 map </pre></td></tr><tr><td data-num="6"></td><td><pre>* 或 会快速扩张的 map, 应当赋予一个初始化容量</pre></td></tr><tr><td data-num="7"></td><td><pre>*</pre></td></tr><tr><td data-num="8"></td><td><pre>*/</pre></td></tr></table></figure><p><mark>切片作为 map 的值</mark></p><p>map 的 key 只能对应一个 value, 当 value 为原始类型，且 key 对应多个值，</p><p>可以将 value 定义为 [] type 切片优雅的解决问题</p><h4 id="2测试map的键值是否存在及删除元素"><a class="anchor" href="#2测试map的键值是否存在及删除元素">#</a> 2. 测试 Map 的键值是否存在及删除元素</h4><ul><li><p><code>val = map[key]</code> 获取到 key 对应的值，如果 map 中不存在 key,val 就是值类型的空值</p><p>(<mark>但也有可能值为空值</mark>)</p></li><li><p><code>val, isPresent = map[key]</code> val 对应 value 值，<mark>isPresent(bool)</mark> 表示 key</p><p>是否存在，存在为 true, 不存在为 false</p></li><li><p><code>delete(map,key)</code> 从 map 中删除 key 对应的键值 (<mark>key 不存在时不会产生错误</mark>)</p></li></ul><h4 id="3for-range-构造遍历map"><a class="anchor" href="#3for-range-构造遍历map">#</a> 3.for-range 构造，遍历 map</h4><p>for-range 循环中，返回值为 ket,value, 可选择性接收对应的值</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 遍历 map 的 k,v 键值对</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token keyword">map</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ···</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 只遍历 map 的 value 值</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token keyword">map</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    ···</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 只遍历 map 的 key</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">for</span> key <span class="token punctuation">:</span> <span class="token keyword">range</span> <span class="token keyword">map</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="4map-类型的切片"><a class="anchor" href="#4map-类型的切片">#</a> 4.map 类型的切片</h4><p>map 类型的切片需要使用<mark>两次 make () 函数</mark>，第一次分配切片，第二次分配切片中的 map 元素</p><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 声明一个存放 map 元素的切片</span></pre></td></tr><tr><td data-num="2"></td><td><pre>items <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 遍历初始化切片中的元素</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> i<span class="token operator">:=</span> <span class="token keyword">range</span> items <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    key <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s%d%s"</span><span class="token punctuation">,</span><span class="token string">"items["</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token string">"][key]"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 通过切片索引进行赋值才能初始化 map</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Version A : Value of items : %v\n"</span><span class="token punctuation">,</span>items<span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="5map的排序"><a class="anchor" href="#5map的排序">#</a> 5.map 的排序</h4><ul><li>map 默认是无序的，无论按照 key 或是 value 默认都不排序</li><li>map 排序，需要将 key (或者 value) 拷贝到一个切片，在对切片进行排序</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">var</span> barVal <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span>···<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>keys <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>barVal<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>i <span class="token operator">:=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> k<span class="token punctuation">,</span><span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> barVal <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> k</pre></td></tr><tr><td data-num="6"></td><td><pre>    i<span class="token operator">++</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>sort<span class="token punctuation">.</span><span class="token function">Strings</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span>k <span class="token operator">:=</span> <span class="token keyword">range</span> keys <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"key: %v,Value: %v\n"</span><span class="token punctuation">,</span>k<span class="token punctuation">,</span>barVal<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>需要一个排序好的列表，使用结构体切片更有效</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">type</span> name <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    key <span class="token builtin">string</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    value <span class="token builtin">int</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="6map-键值对调"><a class="anchor" href="#6map-键值对调">#</a> 6.map 键值对调</h4><ul><li>调换 map 集合的 key 和 value. &lt;map 的值类型可以作为 key, 且所有的 value 必须是唯一的&gt;</li><li>原始 value 值不唯一时会报错，且对调后的 map 可能没有包含原 map 的所有键值对！</li></ul><figure class="highlight go"><figcaption data-lang="go"></figcaption><table><tr><td data-num="1"></td><td><pre>invMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>barVal<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> barVal <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    invMap<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> k</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="3go数据类型分类"><a class="anchor" href="#3go数据类型分类">#</a> 3.Go 数据类型分类</h2><h3 id="1基本数据类型"><a class="anchor" href="#1基本数据类型">#</a> 1. 基本数据类型</h3><h5 id="1-值类型与引用类型"><a class="anchor" href="#1-值类型与引用类型">#</a> 1. 值类型与引用类型</h5><ul><li>值类型: 变量直接存储值，内存通常在栈中分配 <code>(值类型数据: int,float,bool,string, 数组, struct)</code></li><li>引用类型：变量存储的是一个地址，这个地址存储最终的值，内存通常在堆中分配，通过 GC 回收，</li><li><code>引用类型数据: 指针, slice, map, chan</code></li></ul><h5 id="2-整型"><a class="anchor" href="#2-整型">#</a> 2. 整型</h5><ul><li><p>长度划分: <code>int8, int16, int32, int64</code> (int32 等价 rune 类型)</p></li><li><p>无符号整型: <code>uint8, uint16, uint32, uint64</code> (uint8 等价 byte 类型，)</p></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号 8 位整型 (有效值为：0 到 255)</td></tr><tr><td>uint16</td><td>无符号 16 位整型 (有效值为：0 到 65535)</td></tr><tr><td>uint32</td><td>无符号 32 位整型 (有效值为：0 到 4294967295)</td></tr><tr><td>uint64</td><td>无符号 64 位整型 (有效值为：0 到 18446744073709551615)</td></tr><tr><td>int8</td><td>有符号 8 位整型 (有效值为：-128 到 127)</td></tr><tr><td>int16</td><td>有符号 16 位整型 (有效值为：-32768 到 32767)</td></tr><tr><td>int32</td><td>有符号 32 位整型 (有效值为：-2147483648 到 2147483647)</td></tr><tr><td>int64</td><td>有符号 64 位整型 (有效值为：-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h5 id="3特殊类型"><a class="anchor" href="#3特殊类型">#</a> 3. 特殊类型</h5><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint</td><td>32 位操作系统上就是 uint32，64 位操作系统上就是 uint64</td></tr><tr><td>int</td><td>32 位操作系统上就是 int32，64 位操作系统上就是 int64</td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr></tbody></table><h5 id="4浮点型"><a class="anchor" href="#4浮点型">#</a> 4. 浮点型</h5><ul><li>Go 语言支持两种浮点型数: float32 和 float64</li><li>float32 的浮点数的最大范围约为 3.4e38</li><li>float64 的浮点数的最大范围约为 1.8e308</li></ul><h5 id="5-布尔值"><a class="anchor" href="#5-布尔值">#</a> 5. 布尔值</h5><ul><li>Go 语言中以 bool 类型进行声明 布尔类型数据，true | false</li><li>布尔类型变量的默认值为 false</li><li>Go 语言中不允许将整型强制转换为布尔型</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换</li></ul><h5 id="6-字符串"><a class="anchor" href="#6-字符串">#</a> 6. 字符串</h5><ul><li>Go 语言中的字符串为原生数据类型，使用字符串同其他原生数据类型一样</li><li>Go 语言的字符串内部实现使用 UTF-8 编码。字符串的值为 双引号中的内容，字符的值为单引号中内容</li><li>可以在 Go 语言源码中直接添加非 ASCLL 码字符: ( <code>s := &quot;Hello GoLang&quot;</code> )</li></ul><p><mark>转义字符 (反引号中的转译字符无效)</mark></p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>'</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\</td><td>反斜线</td></tr></tbody></table><h5 id="7指针类型"><a class="anchor" href="#7指针类型">#</a> 7. 指针类型</h5><ol><li><p>普通类型:	变量存的就是值，也叫值类型</p></li><li><p>获取变量的地址，用 <code>&amp;</code> , 例如: <code>var a int, 获取a的内存地址: &amp;a</code></p></li><li><p>指针类型，变量存的是一个地址，这个地址中存放的才是值，变量找到值通过指针来指定</p></li><li><p>获取指针类型所指向的值，例如: <code>var p int, 使用 *p获取p指向的值</code></p></li><li><p>指针的地址是可以改变的</p></li><li><p>byte 类型和 rune 类型</p></li></ol><ul><li>uint8 类型，或叫 byte 型，代表 ASCLL 的一个字符</li><li>rune 类型，代表一个 UTF-8 字符</li><li>处理 中文，日文或其他复合字符时，需要使用 rune 类型，rune 类型实际是一个 int32</li><li>Go 使用特殊的 rune 类型来处理 Unicode, 也可以使用 byte 型进行默认字符串处理</li></ul><div class="tags"><a href="/tags/GoLang/" rel="tag"><i class="ic i-tag"></i> GoLang</a> <a href="/tags/Go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="ic i-tag"></i> Go基础学习</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-06-30 16:11:39" itemprop="dateModified" datetime="2022-06-30T16:11:39+08:00">2022-06-30</time> </span><span id="2022/06/29/GoLang/GoLang入门篇(上)/" class="item leancloud_visitors" data-flag-title="GoLang入门学习" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>MuBai <i class="ic i-at"><em>@</em></i>源夢</li><li class="link"><strong>本文链接：</strong> <a href="https://proudmubai.github.io/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8A)/" title="GoLang入门学习">https://proudmubai.github.io/2022/06/29/GoLang/GoLang入门篇(上)/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/06/29/GoLang/%E5%9F%BA%E7%A1%80%E6%8B%93%E5%B1%95/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;www.dmoe.cc&#x2F;random.php?603736" title="计算机基础知识"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机基础</span><h3>计算机基础知识</h3></a></div><div class="item right"><a href="/2022/06/29/Git/Git/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;www.dmoe.cc&#x2F;random.php?296051" title="Git常用命令"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 版本控制</span><h3>Git常用命令</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">GoLang 学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1go-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.go 环境变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">go 基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1go-build%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.go build 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2go-clean-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.go clean 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3go-run-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.go run 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4go-fmt%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.go fmt 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5go-install%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.go install 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-go-get-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. go get 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7go-generate%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.go generate 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8go-test%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.8.</span> <span class="toc-text">8.go test 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9go-pprof%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.9.</span> <span class="toc-text">9.go pprof 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">GO 语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%8C%87%E9%92%88"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5strings%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.5.</span> <span class="toc-text">5.strings 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 时间和日期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.7.</span> <span class="toc-text">7. 控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E5%87%BD%E6%95%B0-function"><span class="toc-number">1.3.8.</span> <span class="toc-text">8. 函数 Function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">1. 函数参数与返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92call-by-value-%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92call-by-reference"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">2. 按值传递（call by value） 按引用传递（call by reference）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%91%BD%E5%90%8D%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC-named-return-variables"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">3. 命名的返回值 (named return variables)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%A9%BA%E7%99%BD%E7%AC%A6blank-identifier"><span class="toc-number">1.3.8.4.</span> <span class="toc-text">4. 空白符（blank identifier）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%94%B9%E5%8F%98%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8Foutside-variable"><span class="toc-number">1.3.8.5.</span> <span class="toc-text">5. 改变外部变量（outside variable）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E4%BC%A0%E9%80%92%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.8.6.</span> <span class="toc-text">6. 传递可变长度参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-defer-%E4%BB%A3%E7%A0%81%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.3.8.7.</span> <span class="toc-text">7. defer 代码追踪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.8.8.</span> <span class="toc-text">8. 内置函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.8.9.</span> <span class="toc-text">9. 递归函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.8.10.</span> <span class="toc-text">10. 将函数作为参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.8.11.</span> <span class="toc-text">11. 闭包函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E5%BA%94%E7%94%A8%E9%97%AD%E5%8C%85"><span class="toc-number">1.3.8.12.</span> <span class="toc-text">12. 应用闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E9%97%AD%E5%8C%85%E8%B0%83%E8%AF%95"><span class="toc-number">1.3.8.13.</span> <span class="toc-text">13. 闭包调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">1.3.8.14.</span> <span class="toc-text">14. 计算函数执行时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.8.15.</span> <span class="toc-text">15. 通过内存缓存提升性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E5%88%87%E7%89%87%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.9.</span> <span class="toc-text">9. 切片与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">1. 数组的声明和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%95%B0%E7%BB%84%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">2. 数组常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.9.3.</span> <span class="toc-text">3. 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%B0%86%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92%E7%BB%99%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.9.4.</span> <span class="toc-text">4. 将数组传递给函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%88%87%E7%89%87"><span class="toc-number">1.3.9.5.</span> <span class="toc-text">5. 切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-bytes"><span class="toc-number">1.3.9.6.</span> <span class="toc-text">6. bytes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%88%87%E7%89%87%E9%87%8D%E7%BB%84"><span class="toc-number">1.3.9.7.</span> <span class="toc-text">7. 切片重组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E5%88%87%E7%89%87%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%BF%BD%E5%8A%A0"><span class="toc-number">1.3.9.8.</span> <span class="toc-text">8. 切片的复制与追加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%9F%E6%88%90%E5%88%87%E7%89%87"><span class="toc-number">1.3.9.9.</span> <span class="toc-text">9. 字符串生成切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E5%88%87%E7%89%87%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.9.10.</span> <span class="toc-text">10. 切片和垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-map"><span class="toc-number">1.3.10.</span> <span class="toc-text">10. Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%A3%B0%E6%98%8E%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%92%8C-make"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">1. 声明，初始化 和 make</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%B5%8B%E8%AF%95map%E7%9A%84%E9%94%AE%E5%80%BC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%8F%8A%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">2. 测试 Map 的键值是否存在及删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3for-range-%E6%9E%84%E9%80%A0%E9%81%8D%E5%8E%86map"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">3.for-range 构造，遍历 map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4map-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%87%E7%89%87"><span class="toc-number">1.3.10.4.</span> <span class="toc-text">4.map 类型的切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5map%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.10.5.</span> <span class="toc-text">5.map 的排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6map-%E9%94%AE%E5%80%BC%E5%AF%B9%E8%B0%83"><span class="toc-number">1.3.10.6.</span> <span class="toc-text">6.map 键值对调</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3go%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">3.Go 数据类型分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.0.1.</span> <span class="toc-text">1. 值类型与引用类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B4%E5%9E%8B"><span class="toc-number">1.4.1.0.2.</span> <span class="toc-text">2. 整型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.0.3.</span> <span class="toc-text">3. 特殊类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">1.4.1.0.4.</span> <span class="toc-text">4. 浮点型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">1.4.1.0.5.</span> <span class="toc-text">5. 布尔值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.1.0.6.</span> <span class="toc-text">6. 字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.0.7.</span> <span class="toc-text">7. 指针类型</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8A)/" rel="bookmark" title="GoLang入门学习">GoLang入门学习</a></li><li><a href="/2022/06/29/GoLang/GoLang%E5%85%A5%E9%97%A8%E7%AF%87(%E4%B8%8B)/" rel="bookmark" title="GoLang协程与标准库">GoLang协程与标准库</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="MuBai" data-src="/images/avatar.jpg"><p class="name" itemprop="name">MuBai</p><div class="description" itemprop="description">萌新小白 & 学习点滴</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">21</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">27</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Byb3VkTXVCYWk=" title="https:&#x2F;&#x2F;github.com&#x2F;ProudMuBai"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item telegram" data-url="aHR0cHM6Ly90Lm1lL011YmFpQ3M=" title="https:&#x2F;&#x2F;t.me&#x2F;MubaiCs"><i class="ic i-paper-plane"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>链环</a><ul class="submenu"><li class="item"><a href="/links/friends" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/links/tool/" rel="section"><i class="ic i-star"></i>网址</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/06/29/GoLang/%E5%9F%BA%E7%A1%80%E6%8B%93%E5%B1%95/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/06/29/Git/Git/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/Axios/" title="分类于 Axios">Axios</a></div><span><a href="/2022/06/29/NodeJs/Vue/Axios/" title="Axios 异步通讯">Axios 异步通讯</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/nodejs/" title="分类于 web前端">web前端</a> <i class="ic i-angle-right"></i> <a href="/categories/nodejs/React/" title="分类于 React">React</a></div><span><a href="/2022/06/29/NodeJs/React/React%E5%85%A5%E9%97%A8%E7%AF%87/" title="React入门学习">React入门学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/2022/07/01/Blog/Hexo/command/" title="Hexo入门指南">Hexo入门指南</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/config/" title="Step.2 基本配置">Step.2 基本配置</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/" title="Hexo主题Shoka &amp; multi-markdown-it渲染器使用说明">Hexo主题Shoka & multi-markdown-it渲染器使用说明</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/dependents/" title="Step.1 依赖插件">Step.1 依赖插件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/special/" title="Step.4 主题特殊功能">Step.4 主题特殊功能</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/golang/" title="分类于 GoLang">GoLang</a> <i class="ic i-angle-right"></i> <a href="/categories/golang/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" title="分类于 计算机基础">计算机基础</a></div><span><a href="/2022/06/29/GoLang/%E5%9F%BA%E7%A1%80%E6%8B%93%E5%B1%95/" title="计算机基础知识">计算机基础知识</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/computer-science/note/theme-shoka-doc/display/" title="Step.3 界面显示">Step.3 界面显示</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/git/" title="分类于 版本控制">版本控制</a></div><span><a href="/2022/06/29/Git/Git/" title="Git常用命令">Git常用命令</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022.06.30 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">MuBai @ MuBai Boat</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">209k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:10</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/06/29/GoLang/GoLang入门篇(上)/",favicon:{show:"(*^▽^*) 源起, 寻心逐夢",hide:"(๑‾᷅^‾᷅๑) 终了, 无悔"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->